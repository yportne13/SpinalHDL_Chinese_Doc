<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>目录 &mdash; SpinalHDL_Chinese_Doc  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Welcome to SpinalHDL_Chinese_Doc’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> SpinalHDL_Chinese_Doc
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">目录</a></li>
<li class="toctree-l1"><a class="reference internal" href="#spinalhdl-about-spinalhdl">关于SpinalHDL(About SpinalHDL)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#faq">FAQ</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#spinalhdlrtlvhdl-verilog">一、SpinalHDL生成的RTL与手工书写VHDL/Verilog相比额外硬件开销有多少？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spinalhdl">二、SpinalHDL未来可能会不支持吗？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spinalhdlvhdl-verilog">三、SpinalHDL生成的VHDL/Verilog是否保持备注？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">四、SpinalHDL可以扩展到大工程吗？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">五、SpinalHDL如何产生的？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vhdl-verilog-systemverilog">六、为什么有VHDL/Verilog/SystemVerilog还要开发新语言？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#git-spinalhdl">七、如何使用未发布(但是已经提交到git)的SpinalHDL版本？</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#support">支持(Support)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#communication-channels">一、联系渠道(Communication channels)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#commercial-support">二、商业支持(Commercial support)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#users">用户(Users)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#companies">一、公司(Companies)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#repositories">二、仓库(Repositories)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#getting-started">开始入门(Getting Started)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id4">开始入门(Getting Started)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#requirements-things-to-download-to-get-started">一、开始所要下载的必要条件/事情(Requirements/Things to download to get started)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spinalhdl-how-to-start-programming-with-spinalhdl">二、如何开始用SpinalHDL编程(How to start programming with SpinalHDL)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spinalhdl-a-very-simple-spinalhdl-example">三、一个非常简单的SpinalHDL例子(A very simple SpinalHDL example)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-to-do-next">四、接下来做什么?(What to do next?)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#motivation">目的(Motivation)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#presentation">表现(Presentation)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#scala-scala-guide">Scala指导手册(Scala Guide)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basics">简介(Basics)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">一、基础</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coding-conventions">二、代码约束(Coding conventions)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">三、交互</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vhdl-help-for-vhdl-people">对VHDL的支持(Help for VHDL people)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#vhdl-vhdl-comparison">一、VHDL对比(VHDL comparison)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vhdl-vhdl-equivalences">二、VHDL等效(VHDL equivalences)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#data-types">数据类型(Data types)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">简介(Introduction)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bool">Bool</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#description">一、描述(Description)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#declaration">二、声明(Declaration)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operators">三、操作符(Operators)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bits">Bits</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id7">一、描述(Description)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">二、声明(Declaration)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">三、操作符(Operators)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#uint-sint">UInt/SInt</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id10">一、描述(Description)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">二、声明(Declaration)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">三、操作符(Operators)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fixpoint-operations">四、定点数操作(FixPoint operations)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#spinalenum">SpinalEnum</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id13">一、描述(Description)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">二、声明(Declaration)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">三、操作符(Operators)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bundle">Bundle</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id16">一、描述(Description)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">二、声明(Declaration)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id18">三、操作符(Operators)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#io-io-element-direction">四、IO类型指导(IO Element direction)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vec">Vec</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id19">一、描述(Description)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id20">二、声明(Declaration)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id21">三、操作符(Operators)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ufix-sfix">UFix/SFix</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id22">一、描述(Description)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id23">二、声明(Declaration)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#assignments">三、赋值(Assignments)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#raw-raw-value">四、Raw值(Raw value)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id24">五、操作符(Operators)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#floating">Floating</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id25">一、描述(Description)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id26">二、声明(Declaration)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id27">三、操作符(Operators)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#afix-afixspinal">AFix(AFix是最新版Spinal新增的数据结构，不知为何该板块有些代码无法通过编译)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id28">一、描述(Description)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id29">二、声明(Declaration)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mathematical-operations">三、数学操作(Mathematical Operations)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inequality-operators">四、不相等操作(Inequality Operators)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bit-bitshifting">五、Bit移位(Bitshifting)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#saturation-and-rounding">六、近似和饱和(Saturation and Rounding)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#assignment">七、赋值(Assignment)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#structuring">结构(Structuring)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#component-and-hierarchy">模块和层次(Component and hierarchy)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id30">一、简介(Introduction)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#input-output-definition">二、输入/输出定义(Input/output definition)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pruned-signals">三、信号剪枝(Pruned signals)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generic-vhdl-parameter-verilog">四、参数化硬件电路(”Generic”——VHDL, “Parameter”——Verilog)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synthesized-component-names">五、综合模块名(Synthesized component names)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#area">区域(Area)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id31">一、简介(Introduction)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#function">函数(Function)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id32">一、简介(Introduction)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rga-rgb-to-grey">二、RGA到灰度(RGB to grey)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#validready-valid-ready-payload-bus">三、Valid和Ready负载总线(Valid Ready Payload bus)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#clock-domains">时钟域(Clock domains)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id33">一、简介(Introduction)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#instantiation">二、例化(Instantiation)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#clock-domain-crossing">三、跨时钟域(Clock domain crossing)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#clocking-areas">四、特殊的时序区域(clocking areas)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vhdlverilog-ip-instantiate-vhdl-and-verilog-ip">VHDL例化和Verilog IP(Instantiate VHDL and Verilog IP)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id34">一、描述(Description)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-an-blackbox">二、定义黑盒(Defining an blackbox)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generics">三、范式(Generics)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#instantiating-a-blackbox">四、例化黑盒(Instantiating a blackbox)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#clock-and-reset-mapping">五、时钟和复位的布局(Clock and reset mapping)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#io-io-prefix">六、io前缀(io prefix)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#io-rename-all-io-of-a-blackbox">七、重命名黑盒的所有io(Rename all io of a blackbox)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rtl-add-rtl-source">八、添加RTL源(Add RTL source)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vhdl-vhdl-no-numeric-type">九、VHDL——非数字类型(VHDL-No numeric type)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#preserving-names">保留名称(Preserving names)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id35">一、简介(Introduction)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nameable-base-class">二、可命名的基础类(Nameable base class)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scala-name-extraction-from-scala">三、从Scala中提取名字(Name extraction from Scala)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#area-in-a-component">四、模块中的区域(Area in a Component)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#area-in-a-function">五、函数中的区域(Area in a function)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composite-in-a-function">六、在函数中组合(Composite in a function)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composite-chains">七、组合链(Composite chains)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bundle-composite-in-a-bundle-s-function">八、Bundle函数中的组合(Composite in a Bundle’s function)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unamed-signal-handling">九、处理未命名信号(Unamed signal handling)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#parametrization">参数化(Parametrization)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id36">一、简介(Introduction)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#elaboration-time-parameters">二、细化阶段的参数(Elaboration time parameters)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#optional-hardware">三、可选择的硬件生成(Optional hardware)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#semantic">语义(Semantic)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id37">赋值(Assignments)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id38">一、赋值(Assignments)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#width-checking">二、位宽检查(Width checking)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#combinatorial-loops">三、组合逻辑环路(Combinatorial loops)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#when-switch-mux">When/Switch/Mux</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#when">一、When</a></li>
<li class="toctree-l3"><a class="reference internal" href="#switch">二、Switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="#local-declaration">三、本地声明(Local declaration)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mux">四、Mux</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bit-bitwise-selection">五、Bit级选择(Bitwise selection)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rules">规则(Rules)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id39">一、简介(Introduction)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#concurrency">二、并行性(Concurrency)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#last-valid-assignment-wins">三、以最后赋值为准(Last valid assignment wins)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scala-signal-and-register-interactions-with-scala-oop">四、Scala下的信号和寄存器的内在联系(Signal and register interactions with Scala)(OOP引用+函数)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#sequential-logic">时序逻辑(Sequential logic)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#registers">寄存器(Registers)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id40">一、简介(Introduction)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id41">二、例化(Instantiation)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reset-value">三、复位值(Reset value)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initialization-value-for-simulation">四、仿真下的例化(Initialization value for simulation)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#register-vectors">五、寄存器向量(Register vectors)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transforming-a-wire-into-a-register">六、把线类型转化为寄存器(Transforming a wire into a register)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ram-rom">RAM/ROM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#syntax">一、语义(Syntax)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quirk-synchronous-enable-quirk">二、同步使能quirk(Synchronous enable quirk)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#read-under-write-policy">三、读下写原则(Read-under-write policy)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ram-mixed-width-ram">四、混合宽度ram(Mixed-width ram)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mem-automatic-blackboxing">五、自动化mem黑盒(Automatic blackboxing)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#design-errors">设计错误(Design Errors)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id42">简介(Introduction)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#assignment-overlap">赋值覆盖(Assignment Overlap)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id43">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id44">二、例子</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#clock-crossing-violation">跨时钟域违例(Clock crossing violation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id45">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id46">二、例子</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#combinatorial-loop">组合环(Combinatorial loop)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id47">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id48">二、例子</a></li>
<li class="toctree-l3"><a class="reference internal" href="#false-positives">三、假阳性(false-positives)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hierarchy-violation">层次违例(Hierarchy violation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id49">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id50">二、例子</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#io">IO包</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id51">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id52">二、例子</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#latch-detected">锁存器检测(Latch detected)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id53">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id54">二、例子</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#no-driver-on">无驱动检测(no driver on)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id55">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id56">二、例子</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#nullpointerexception">排除空指针(NullPointerException)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id57">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id58">二、例子</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#register-defined-as-component-input">定义为组件输入的寄存器(Register defined as component input)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id59">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id60">二、例子</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#scope-violation">作用域违例(Scope violation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id61">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id62">二、例子</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#spinal-spinal-cant-clone-class">Spinal无法克隆类(Spinal can’t clone class)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id63">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id64">二、例子1</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id65">二、例子2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#unassigned-register">未分配的寄存器(Unassigned register)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id66">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id67">二、例子</a></li>
<li class="toctree-l3"><a class="reference internal" href="#register-with-only-init">三、只有初始化的寄存器(Register with only init)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#is-unreachable-is-statement">无法实现的is表述(Unreachable is statement)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id68">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id69">二、例子</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#width-mismatch">位宽不匹配(Width mismatch)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id70">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id71">二、分配赋值例子</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id72">三、操作实例</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#other-language-features">其他语言特征(Other language features)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id73">简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="#utils">工具(Utils)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id74">一、 总览</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cloning-hardware-datatypes">二、克隆硬件数据类型(Cloning hardware datatypes)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#passing-a-datatype-as-construction-parameter">三、传递数据类型作为结构参数(Passing a datatype as construction parameter)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#frequency-and-time">四、频率与时间(Frequency and time)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binary-prefix">五、二进制前缀(Binary prefix)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#stub">Stub (存根)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#assertions">Assertions(断言)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#report">Report(报告)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#scopeproperty">ScopeProperty(作用域属性)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#analog-and-inout-io">Analog and inout (模拟与IO口)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id75">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#analog">二、Analog(模拟)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inout-io">三、Inout(IO口)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inoutwrapper-io">四、InOutWrapper(IO口封装)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#manually-driving-analog-bundles">五、Manually driving Analog bundles(手动驱动模拟束)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vhdlverilog-vhdl-and-verilog-generation">VHDL和Verilog生成(VHDL and Verilog generation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#spinalhdlvhdlverilog-generate-vhdl-and-verilog-from-a-spinalhdl-component">一、从一个SpinalHDL组件生成VHDL或Verilog代码(Generate VHDL and Verilog from a SpinalHDL Component)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vhdlverilog-generated-vhdl-and-verilog">二、已生成的VHDL或Verilog(Generated VHDL and Verilog)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vhdlverilog-vhdl-and-verilog-attributes">三、VHDL与Verilog属性(VHDL and Verilog attributes)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#libraries">Libraries(库)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id76">简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id77">Utils(实用工具)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#state-less-utilities">一、State less utilities(免状态工具)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#state-full-utilities">二、State full utilities(全状态工具)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#special-utilities">三、特殊工具(Special utilities)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#stream">流(Stream)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#specification">一、规范(Specification)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semantics">二、语义(Semantics)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions">三、函数(Functions)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id78">四、工具(Utils)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#flow">Flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id79">一、规范(Specification)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id80">二、函数(Functions)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#code-example">三、代码实例(code example)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fragment">片段(Fragment)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id81">一、规范(Specification)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id82">二、函数(Functions)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#state-machine">状态机(State machine)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id83">一、简介(Introduction)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#statemachine">二、状态机(StateMachine)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#states">三、状态(States)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vexriscv-rv32im-cpu">VexRiscv(RV32IM CPU)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bus-slave-factory">从端总线库(Bus Slave Factory)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id84">一、简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functionality">二、功能性(Functionality)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fiber-framework">纤程框架(Fiber Framework)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#simple-dummy-example">一、简单的样例(Simple dummy example)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#handle-t">二、Handle[T]</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#binary-system">二进制系统(Binary System)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id85">一、规范(Specification)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#int-long-bigint-string-to-int-long-bigint">二、字符串转Int/Long/BigInt(String to Int/Long/BigInt)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#int-long-bigint-string">三、Int/Long/BigInt 转为 String</a></li>
<li class="toctree-l3"><a class="reference internal" href="#int-long-bigint-binary-list">四、Int/Long/BigInt 转为 Binary-List</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binary-list-int-long-bigint">五、Binary-List 转为 Int/Long/BigInt</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bigint-bigint-enricher">六、BigInt放大器(BigInt enricher)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#regif">寄存器接口(RegIf)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#automatic-allocation">一、自动分配(Automatic allocation)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#access-types">二、28种可支持类型(28 Access Types)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#automatic-documentation-generation">三、自动文献生成(Automatic documentation generation)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id86">四、例子</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interrupt-factory">五、中断库(Interrupt Factory)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#interrupt-design-spec">中断设计规范(Interrupt Design Spec)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ip-ip-level-interrupt-factory">一、IP级中断库(IP level interrupt Factory)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sys-level-interrupt-merge">二、系统级中断合并(SYS level interrupt merge)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spinal-spinal-factory">三、Spinal库(Spinal Factory)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">四、例子(Example)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#developers-area">五、开发区域(Developers Area)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bus">总线(bus)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ahb-lite3">一、AHB-Lite3</a></li>
<li class="toctree-l3"><a class="reference internal" href="#apb3">二、Apb3</a></li>
<li class="toctree-l3"><a class="reference internal" href="#avalonmm">四、AvalonMM</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#com">Com</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#uart">一、UART</a></li>
<li class="toctree-l3"><a class="reference internal" href="#usb">二、USB设备</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id87">IO口</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#readableopendrain">一、ReadableOpenDrain</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tristate">二、三态(Tristate)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#graphics">图形(Graphics)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id88">一、颜色</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vga">二、VGA</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#eda">自动设计工具(EDA)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#qsysify">一、QSysify</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quartusflow">二、QuartusFlow</a></li>
<li class="toctree-l3"><a class="reference internal" href="#for-an-existing-project">三、对于一个已存在的项目(For an existing project)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#misc">Misc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#plic">一、Plic映射器</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#simulation">仿真(Simulation)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id89">介绍(Introduction)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#spinalhdlverilator-how-spinalhdl-simulates-the-hardware-with-verilator-backend">一、SpinalHDL如何用Verilator仿真(How SpinalHDL simulates the hardware with Verilator backend)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spinalhdlghdl-icarus-how-spinalhdl-simulates-the-hardware-with-ghdl-icarus-backend">二、SpinalHDL如何用GHDL/Icarus仿真(How SpinalHDL simulates the hardware with GHDL/Icarus backend)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spinalhdlsynopsys-vcs-how-spinalhdl-simulates-the-hardware-with-synopsys-vcs-backend">三、SpinalHDL如何用Synopsys VCS仿真(How SpinalHDL simulates the hardware with Synopsys VCS backend)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id90">四、性能</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#installation-instructions">安装指南(Installation instructions)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#scala">一、Scala</a></li>
<li class="toctree-l3"><a class="reference internal" href="#backend-dependent-installation-instructions">二、后端相关的安装指南(Backend-dependent installation instructions)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#boot-a-simulation">启动仿真(Boot a Simulation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id91">一、介绍(Introduction)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuration">二、配置(Configuration)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#running-multiple-tests-on-the-same-hardware">三、在同一硬件上运行多个测试用例(Running multiple tests on the same hardware)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#throw-success-or-failure-of-the-simulation-from-a-thread">四、从线程中报告仿真的成功或失败(Throw Success or Failure of the simulation from a thread)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#accessing-signals-of-the-simulation">访问仿真信号(Accessing signals of the simulation)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#read-and-write-signals">一、读写信号(Read and write signals)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-signals-inside-the-component-s-hierarchy">二、在模块层次访问信号(Accessing signals inside the component’s hierarchy)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id92">时钟域(Clock domains)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#api-stimulus-api">一、激励API(Stimulus API)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#api-wait-api">二、等待API(Wait API)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#api-callback-api">三、传回API(Callback API)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#default-clockdomain">四、默认时钟域(Default ClockDomain)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#new-clockdomain">五、新时钟域(New ClockDomain)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#api-thread-full-api">满线程API(Thread-full API)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fork-and-join-simulation-threads">一、仿真线程的分叉和汇合(Fork and Join simulation threads)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sleep-and-waituntil">二、休眠和等待(Sleep and WaitUntil)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#api-thread-less-api">少线程API(Thread-less API)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#api-sensitive-api">敏感API(Sensitive API)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simulation-engine">仿真引擎(Simulation engine)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id93">例子(Examples)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#asychronous-adder">一、异步加法器(Asychronous adder)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fifo-dual-clock-fifo">二、双时钟FIFO(Dual clock FIFO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fifo-single-clock-fifo">三、单时钟FIFO(Single clock FIFO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synchronous-adder">四、同步加法器(Synchronous adder)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uart-decoder">五、串口译码器(Uart decoder)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uart-encoder">六、串口编码器(Uart encoder)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#formal-verification">形式验证(Formal verification)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#general">通常(General)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#formal-backend">形式后端(Formal backend)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#installing-requirements">安装需求(Installing requirements)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id94">举例(Example)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#external-assertions">一、外部断言(External assertions)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#internal-assertions">二、内部断言(Internal assertions)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#external-stimulus">三、外部激励(External stimulus)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#more-assertions-past">四、更多的断言/传递(More assertions/past)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#assuming-memory-content">五、假设存储内容(Assuming memory content)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#utilities-and-primitives">实用程序和原语(Utilities and primitives)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#assertions-clock-reset">一、断言/时钟/复位(Assertions/clock/reset)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#specifying-the-initial-value-of-a-signal">二、给定信号初始值(Specifying the initial value of a signal)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#specifying-a-initial-assumption">三、给定初始化声明(Specifying a initial assumption)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-content">四、存储内容(Memory content)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#specifying-assertion-in-the-reset-scope">五、在复位区域内给定断言(Specifying assertion in the reset scope)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#formal-primitives">六、形式化原语(Formal primitives)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#limitations">限制(Limitations)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id95">四、例子(Example)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id96">五、开发区域(Developers Area)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id97">总线(bus)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id98">一、AHB-Lite3</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id99">二、Apb3</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id100">四、AvalonMM</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id101">Com</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id102">一、UART</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id103">二、USB设备</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id104">IO口</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id105">一、ReadableOpenDrain</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id106">二、三态(Tristate)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id107">图形(Graphics)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id108">一、颜色</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id109">二、VGA</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id110">自动设计工具(EDA)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id111">一、QSysify</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id112">二、QuartusFlow</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id113">三、对于一个已存在的项目(For an existing project)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id114">Misc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id115">一、Plic映射器</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id116">例子(Examples)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id117">简单的实例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id118">一、APB3</a></li>
<li class="toctree-l3"><a class="reference internal" href="#carry-adder">二、进位加法器(Carry Adder)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#color-summing">三、颜色求和(Color Summing)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#counter-with-clear">四、带清除的计数器(Counter with clear)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pll-blackbox-and-reset-controller">五、锁相环黑盒与复位控制器(PLL BlackBox and reset controller)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rgb">六、RGB转灰度图</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rom-sinus-rom">七、正弦ROM(Sinus rom)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id119">进阶实例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fractal-calculator">一、分形计算器(Fractal calculator)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id120">二、UART</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id121">三、VGA</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id122">高级实例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#jtag-tap">一、JTAG TAP</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uart-memory-mapped-uart">二、内存映射UART(Memory mapped UART)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pinesec">三、Pinesec</a></li>
<li class="toctree-l3"><a class="reference internal" href="#timer">四、计时器(Timer)</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SpinalHDL_Chinese_Doc</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>目录</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/SpinalHDL_Chinese_Doc.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p></br></br></br></br></br></br></p>
<div align=center>
<img src="image/SpinalHDL_icon.png">
</div><p></br></br></br></p>
<center> <font size=30> SpinalHDL</br></br>中文手册 </font> </center><p></br></br></br></br></br></br></br></br></br></br></br></br></br></br></br>
</br></br></br></br></br></p>
<center> 原作者: Charles Papon </center>
<center> 译作者: 谷江源  回浩嘉  吴其谍 </center><div STYLE="page-break-after: always;"></div><p></br></br></br></p>
<center> <font size=24> 注序</br> </font> </center></br><ol class="simple">
<li><p>本团队对SpinalHDL-Doc的翻译工作及其成果非商业目的，所有公司、团队、个人均可无任何限制地免费试用，如有收费行为与本团队无关，为收费者个人行为。</p></li>
<li><p>感谢原作者Charles Papon对本团队翻译的支持和认可，更感谢他开发了SpinalHDL，让我们硬件工程师有更加灵活便捷的硬件语言生成工具，让大规模架构的设计变得更加可参数化、可模型化、可配置化。同时本团队也希望该译本能够帮助更多的国内硬件工程师开发和设计灵活的硬件电路，为集成电路设计行业注入新的活力。</p></li>
<li><p>该译本尽可能地保证了与原文档表述的一致性，文中出现的绝大多数专用词汇也均有其对应的英文表述，方便大家对照Scala和SpinalHDL进行学习。此外，在原文档的基础上，该中文译本为每个可生成Verilog的SpinalHDL代码增加了其对应的生成结果，方便各位读者对比学习。最后，本团队为EE出身，专注于硬件架构设计，文中如有翻译不到位的地方，请各位读者参考作者的原文档: https://spinalhdl.github.io/SpinalDoc-RTD/master/index.html。此外，请各位读者注意，该译本所翻译的SpinalHDL版本为v1.7.2，不同版本之间可能有所差异，请各位读者在编程的时候注意工程下build.sbt中的版本号。</p></li>
<li><p>本团队归属于清华大学尹首一教授课题组可重构计算团队，热烈欢迎大家加入我们团队！</p></li>
</ol>
<div STYLE="page-break-after: always;"></div><section id="id1">
<h1>目录<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h1>
<ul class="simple">
<li><p><a class="reference external" href="#%E7%9B%AE%E5%BD%95">目录</a></p></li>
<li><p><a class="reference external" href="#%E5%85%B3%E4%BA%8Espinalhdlabout-spinalhdl">关于SpinalHDL(About SpinalHDL)</a></p>
<ul>
<li><p><a class="reference external" href="#faq">FAQ</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80spinalhdl%E7%94%9F%E6%88%90%E7%9A%84rtl%E4%B8%8E%E6%89%8B%E5%B7%A5%E4%B9%A6%E5%86%99vhdlverilog%E7%9B%B8%E6%AF%94%E9%A2%9D%E5%A4%96%E7%A1%AC%E4%BB%B6%E5%BC%80%E9%94%80%E6%9C%89%E5%A4%9A%E5%B0%91">一、SpinalHDL生成的RTL与手工书写VHDL/Verilog相比额外硬件开销有多少？</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Cspinalhdl%E6%9C%AA%E6%9D%A5%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%B8%8D%E6%94%AF%E6%8C%81%E5%90%97">二、SpinalHDL未来可能会不支持吗？</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89spinalhdl%E7%94%9F%E6%88%90%E7%9A%84vhdlverilog%E6%98%AF%E5%90%A6%E4%BF%9D%E6%8C%81%E5%A4%87%E6%B3%A8">三、SpinalHDL生成的VHDL/Verilog是否保持备注？</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9Bspinalhdl%E5%8F%AF%E4%BB%A5%E6%89%A9%E5%B1%95%E5%88%B0%E5%A4%A7%E5%B7%A5%E7%A8%8B%E5%90%97">四、SpinalHDL可以扩展到大工程吗？</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94spinalhdl%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84">五、SpinalHDL如何产生的？</a></p></li>
<li><p><a class="reference external" href="#%E5%85%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89vhdlverilogsystemverilog%E8%BF%98%E8%A6%81%E5%BC%80%E5%8F%91%E6%96%B0%E8%AF%AD%E8%A8%80">六、为什么有VHDL/Verilog/SystemVerilog还要开发新语言？</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%83%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%AA%E5%8F%91%E5%B8%83%E4%BD%86%E6%98%AF%E5%B7%B2%E7%BB%8F%E6%8F%90%E4%BA%A4%E5%88%B0git%E7%9A%84spinalhdl%E7%89%88%E6%9C%AC">七、如何使用未发布(但是已经提交到git)的SpinalHDL版本？</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E6%94%AF%E6%8C%81support">支持(Support)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E8%81%94%E7%B3%BB%E6%B8%A0%E9%81%93communication-channels">一、联系渠道(Communication channels)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%95%86%E4%B8%9A%E6%94%AF%E6%8C%81commercial-support">二、商业支持(Commercial support)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E7%94%A8%E6%88%B7users">用户(Users)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E5%85%AC%E5%8F%B8companies">一、公司(Companies)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BB%93%E5%BA%93repositories">二、仓库(Repositories)</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%BC%80%E5%A7%8B%E5%85%A5%E9%97%A8getting-started">开始入门(Getting Started)</a></p>
<ul>
<li><p><a class="reference external" href="#%E5%BC%80%E5%A7%8B%E5%85%A5%E9%97%A8getting-started-1">开始入门(Getting Started)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E5%BC%80%E5%A7%8B%E6%89%80%E8%A6%81%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E4%BA%8B%E6%83%85requirementsthings-to-download-to-get-started">一、开始所要下载的必要条件/事情(Requirements/Things to download to get started)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B%E7%94%A8spinalhdl%E7%BC%96%E7%A8%8Bhow-to-start-programming-with-spinalhdl">二、如何开始用SpinalHDL编程(How to start programming with SpinalHDL)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%E7%9A%84spinalhdl%E4%BE%8B%E5%AD%90a-very-simple-spinalhdl-example">三、一个非常简单的SpinalHDL例子(A very simple SpinalHDL example)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E6%8E%A5%E4%B8%8B%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88what-to-do-next">四、接下来做什么?(What to do next?)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E7%9B%AE%E7%9A%84motivation">目的(Motivation)</a></p></li>
<li><p><a class="reference external" href="#%E8%A1%A8%E7%8E%B0presentation">表现(Presentation)</a></p></li>
<li><p><a class="reference external" href="#scala%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8Cscala-guide">Scala指导手册(Scala Guide)</a></p>
<ul>
<li><p><a class="reference external" href="#%E7%AE%80%E4%BB%8Bbasics">简介(Basics)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%80%E5%9F%BA%E7%A1%80">一、基础</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BB%A3%E7%A0%81%E7%BA%A6%E6%9D%9Fcoding-conventions">二、代码约束(Coding conventions)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E4%BA%A4%E4%BA%92">三、交互</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%AF%B9vhdl%E7%9A%84%E6%94%AF%E6%8C%81help-for-vhdl-people">对VHDL的支持(Help for VHDL people)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80vhdl%E5%AF%B9%E6%AF%94vhdl-comparison">一、VHDL对比(VHDL comparison)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Cvhdl%E7%AD%89%E6%95%88vhdl-equivalences">二、VHDL等效(VHDL equivalences)</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bdata-types">数据类型(Data types)</a></p>
<ul>
<li><p><a class="reference external" href="#%E7%AE%80%E4%BB%8Bintroduction">简介(Introduction)</a></p></li>
<li><p><a class="reference external" href="#bool">Bool</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E6%8F%8F%E8%BF%B0description">一、描述(Description)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%A3%B0%E6%98%8Edeclaration">二、声明(Declaration)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E6%93%8D%E4%BD%9C%E7%AC%A6operators">三、操作符(Operators)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#bits">Bits</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E6%8F%8F%E8%BF%B0description-1">一、描述(Description)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%A3%B0%E6%98%8Edeclaration-1">二、声明(Declaration)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E6%93%8D%E4%BD%9C%E7%AC%A6operators-1">三、操作符(Operators)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#uintsint">UInt/SInt</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E6%8F%8F%E8%BF%B0description-2">一、描述(Description)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%A3%B0%E6%98%8Edeclaration-2">二、声明(Declaration)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E6%93%8D%E4%BD%9C%E7%AC%A6operators-2">三、操作符(Operators)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E5%AE%9A%E7%82%B9%E6%95%B0%E6%93%8D%E4%BD%9Cfixpoint-operations">四、定点数操作(FixPoint operations)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#spinalenum">SpinalEnum</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E6%8F%8F%E8%BF%B0description-3">一、描述(Description)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%A3%B0%E6%98%8Edeclaration-3">二、声明(Declaration)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E6%93%8D%E4%BD%9C%E7%AC%A6operators-3">三、操作符(Operators)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#bundle">Bundle</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E6%8F%8F%E8%BF%B0description-4">一、描述(Description)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%A3%B0%E6%98%8Edeclaration-4">二、声明(Declaration)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E6%93%8D%E4%BD%9C%E7%AC%A6operators-4">三、操作符(Operators)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9Bio%E7%B1%BB%E5%9E%8B%E6%8C%87%E5%AF%BCio-element-direction">四、IO类型指导(IO Element direction)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#vec">Vec</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E6%8F%8F%E8%BF%B0description-5">一、描述(Description)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%A3%B0%E6%98%8Edeclaration-5">二、声明(Declaration)</a></p>
<ul>
<li><p><a class="reference external" href="#examples">Examples</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E4%B8%89%E6%93%8D%E4%BD%9C%E7%AC%A6operators-5">三、操作符(Operators)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#ufixsfix">UFix/SFix</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E6%8F%8F%E8%BF%B0description-6">一、描述(Description)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%A3%B0%E6%98%8Edeclaration-6">二、声明(Declaration)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E8%B5%8B%E5%80%BCassignments">三、赋值(Assignments)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9Braw%E5%80%BCraw-value">四、Raw值(Raw value)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E6%93%8D%E4%BD%9C%E7%AC%A6operators">五、操作符(Operators)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#floating">Floating</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E6%8F%8F%E8%BF%B0description-7">一、描述(Description)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%A3%B0%E6%98%8Edeclaration-7">二、声明(Declaration)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E6%93%8D%E4%BD%9C%E7%AC%A6operators-6">三、操作符(Operators)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#afixafix%E6%98%AF%E6%9C%80%E6%96%B0%E7%89%88spinal%E6%96%B0%E5%A2%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8D%E7%9F%A5%E4%B8%BA%E4%BD%95%E8%AF%A5%E6%9D%BF%E5%9D%97%E6%9C%89%E4%BA%9B%E4%BB%A3%E7%A0%81%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91">AFix(AFix是最新版Spinal新增的数据结构，不知为何该板块有些代码无法通过编译)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E6%8F%8F%E8%BF%B0description-8">一、描述(Description)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%A3%B0%E6%98%8Edeclaration-8">二、声明(Declaration)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E6%95%B0%E5%AD%A6%E6%93%8D%E4%BD%9Cmathematical-operations">三、数学操作(Mathematical Operations)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E4%B8%8D%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9Cinequality-operators">四、不相等操作(Inequality Operators)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94bit%E7%A7%BB%E4%BD%8Dbitshifting">五、Bit移位(Bitshifting)</a></p></li>
<li><p><a class="reference external" href="#%E5%85%AD%E8%BF%91%E4%BC%BC%E5%92%8C%E9%A5%B1%E5%92%8Csaturation-and-rounding">六、近似和饱和(Saturation and Rounding)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%83%E8%B5%8B%E5%80%BCassignment">七、赋值(Assignment)</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#%E7%BB%93%E6%9E%84structuring">结构(Structuring)</a></p>
<ul>
<li><p><a class="reference external" href="#%E6%A8%A1%E5%9D%97%E5%92%8C%E5%B1%82%E6%AC%A1component-and-hierarchy">模块和层次(Component and hierarchy)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8Bintroduction">一、简介(Introduction)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%AE%9A%E4%B9%89inputoutput-definition">二、输入/输出定义(Input/output definition)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E4%BF%A1%E5%8F%B7%E5%89%AA%E6%9E%9Dpruned-signals">三、信号剪枝(Pruned signals)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E5%8F%82%E6%95%B0%E5%8C%96%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AFgenericvhdl-parameterverilog">四、参数化硬件电路(”Generic”——VHDL, “Parameter”——Verilog)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E7%BB%BC%E5%90%88%E6%A8%A1%E5%9D%97%E5%90%8Dsynthesized-component-names">五、综合模块名(Synthesized component names)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%8C%BA%E5%9F%9Farea">区域(Area)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8Bintroduction-1">一、简介(Introduction)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%87%BD%E6%95%B0function">函数(Function)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8Bintroduction-2">一、简介(Introduction)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Crga%E5%88%B0%E7%81%B0%E5%BA%A6rgb-to-grey">二、RGA到灰度(RGB to grey)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89valid%E5%92%8Cready%E8%B4%9F%E8%BD%BD%E6%80%BB%E7%BA%BFvalid-ready-payload-bus">三、Valid和Ready负载总线(Valid Ready Payload bus)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E6%97%B6%E9%92%9F%E5%9F%9Fclock-domains">时钟域(Clock domains)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8Bintroduction-3">一、简介(Introduction)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%8C%96instantiation">二、例化(Instantiation)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9Fclock-domain-crossing">三、跨时钟域(Clock domain crossing)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E7%89%B9%E6%AE%8A%E7%9A%84%E6%97%B6%E5%BA%8F%E5%8C%BA%E5%9F%9Fclocking-areas">四、特殊的时序区域(clocking areas)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#vhdl%E4%BE%8B%E5%8C%96%E5%92%8Cverilog-ipinstantiate-vhdl-and-verilog-ip">VHDL例化和Verilog IP(Instantiate VHDL and Verilog IP)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E6%8F%8F%E8%BF%B0description-9">一、描述(Description)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%AE%9A%E4%B9%89%E9%BB%91%E7%9B%92defining-an-blackbox">二、定义黑盒(Defining an blackbox)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E8%8C%83%E5%BC%8Fgenerics">三、范式(Generics)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E4%BE%8B%E5%8C%96%E9%BB%91%E7%9B%92instantiating-a-blackbox">四、例化黑盒(Instantiating a blackbox)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E6%97%B6%E9%92%9F%E5%92%8C%E5%A4%8D%E4%BD%8D%E7%9A%84%E5%B8%83%E5%B1%80clock-and-reset-mapping">五、时钟和复位的布局(Clock and reset mapping)</a></p></li>
<li><p><a class="reference external" href="#%E5%85%ADio%E5%89%8D%E7%BC%80io-prefix">六、io前缀(io prefix)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%83%E9%87%8D%E5%91%BD%E5%90%8D%E9%BB%91%E7%9B%92%E7%9A%84%E6%89%80%E6%9C%89iorename-all-io-of-a-blackbox">七、重命名黑盒的所有io(Rename all io of a blackbox)</a></p></li>
<li><p><a class="reference external" href="#%E5%85%AB%E6%B7%BB%E5%8A%A0rtl%E6%BA%90add-rtl-source">八、添加RTL源(Add RTL source)</a></p></li>
<li><p><a class="reference external" href="#%E4%B9%9Dvhdl%E9%9D%9E%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8Bvhdl-no-numeric-type">九、VHDL——非数字类型(VHDL-No numeric type)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E4%BF%9D%E7%95%99%E5%90%8D%E7%A7%B0preserving-names">保留名称(Preserving names)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8Bintroduction-4">一、简介(Introduction)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%8F%AF%E5%91%BD%E5%90%8D%E7%9A%84%E5%9F%BA%E7%A1%80%E7%B1%BBnameable-base-class">二、可命名的基础类(Nameable base class)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E4%BB%8Escala%E4%B8%AD%E6%8F%90%E5%8F%96%E5%90%8D%E5%AD%97name-extraction-from-scala">三、从Scala中提取名字(Name extraction from Scala)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%9F%9Farea-in-a-component">四、模块中的区域(Area in a Component)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%9F%9Farea-in-a-function">五、函数中的区域(Area in a function)</a></p></li>
<li><p><a class="reference external" href="#%E5%85%AD%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%BB%84%E5%90%88composite-in-a-function">六、在函数中组合(Composite in a function)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%83%E7%BB%84%E5%90%88%E9%93%BEcomposite-chains">七、组合链(Composite chains)</a></p></li>
<li><p><a class="reference external" href="#%E5%85%ABbundle%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%BB%84%E5%90%88composite-in-a-bundles-function">八、Bundle函数中的组合(Composite in a Bundle’s function)</a></p></li>
<li><p><a class="reference external" href="#%E4%B9%9D%E5%A4%84%E7%90%86%E6%9C%AA%E5%91%BD%E5%90%8D%E4%BF%A1%E5%8F%B7unamed-signal-handling">九、处理未命名信号(Unamed signal handling)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%8F%82%E6%95%B0%E5%8C%96parametrization">参数化(Parametrization)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8Bintroduction-5">一、简介(Introduction)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E7%BB%86%E5%8C%96%E9%98%B6%E6%AE%B5%E7%9A%84%E5%8F%82%E6%95%B0elaboration-time-parameters">二、细化阶段的参数(Elaboration time parameters)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E5%8F%AF%E9%80%89%E6%8B%A9%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%94%9F%E6%88%90optional-hardware">三、可选择的硬件生成(Optional hardware)</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#%E8%AF%AD%E4%B9%89semantic">语义(Semantic)</a></p>
<ul>
<li><p><a class="reference external" href="#%E8%B5%8B%E5%80%BCassignments">赋值(Assignments)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E8%B5%8B%E5%80%BCassignments">一、赋值(Assignments)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BD%8D%E5%AE%BD%E6%A3%80%E6%9F%A5width-checking">二、位宽检查(Width checking)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%8E%AF%E8%B7%AFcombinatorial-loops">三、组合逻辑环路(Combinatorial loops)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#whenswitchmux">When/Switch/Mux</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80when">一、When</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Cswitch">二、Switch</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E6%9C%AC%E5%9C%B0%E5%A3%B0%E6%98%8Elocal-declaration">三、本地声明(Local declaration)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9Bmux">四、Mux</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94bit%E7%BA%A7%E9%80%89%E6%8B%A9bitwise-selection">五、Bit级选择(Bitwise selection)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E8%A7%84%E5%88%99rules">规则(Rules)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8Bintroduction-6">一、简介(Introduction)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%B9%B6%E8%A1%8C%E6%80%A7concurrency">二、并行性(Concurrency)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E4%BB%A5%E6%9C%80%E5%90%8E%E8%B5%8B%E5%80%BC%E4%B8%BA%E5%87%86last-valid-assignment-wins">三、以最后赋值为准(Last valid assignment wins)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9Bscala%E4%B8%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%86%85%E5%9C%A8%E8%81%94%E7%B3%BBsignal-and-register-interactions-with-scalaoop%E5%BC%95%E7%94%A8%E5%87%BD%E6%95%B0">四、Scala下的信号和寄存器的内在联系(Signal and register interactions with Scala)(OOP引用+函数)</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91sequential-logic">时序逻辑(Sequential logic)</a></p>
<ul>
<li><p><a class="reference external" href="#%E5%AF%84%E5%AD%98%E5%99%A8registers">寄存器(Registers)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8Bintroduction-7">一、简介(Introduction)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%8C%96instantiation-1">二、例化(Instantiation)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E5%A4%8D%E4%BD%8D%E5%80%BCreset-value">三、复位值(Reset value)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E4%BB%BF%E7%9C%9F%E4%B8%8B%E7%9A%84%E4%BE%8B%E5%8C%96initialization-value-for-simulation">四、仿真下的例化(Initialization value for simulation)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E5%AF%84%E5%AD%98%E5%99%A8%E5%90%91%E9%87%8Fregister-vectors">五、寄存器向量(Register vectors)</a></p></li>
<li><p><a class="reference external" href="#%E5%85%AD%E6%8A%8A%E7%BA%BF%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%AF%84%E5%AD%98%E5%99%A8transforming-a-wire-into-a-register">六、把线类型转化为寄存器(Transforming a wire into a register)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#ramrom">RAM/ROM</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E8%AF%AD%E4%B9%89syntax">一、语义(Syntax)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%90%8C%E6%AD%A5%E4%BD%BF%E8%83%BDquirksynchronous-enable-quirk">二、同步使能quirk(Synchronous enable quirk)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E8%AF%BB%E4%B8%8B%E5%86%99%E5%8E%9F%E5%88%99read-under-write-policy">三、读下写原则(Read-under-write policy)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E6%B7%B7%E5%90%88%E5%AE%BD%E5%BA%A6rammixed-width-ram">四、混合宽度ram(Mixed-width ram)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E8%87%AA%E5%8A%A8%E5%8C%96mem%E9%BB%91%E7%9B%92automatic-blackboxing">五、自动化mem黑盒(Automatic blackboxing)</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#%E8%AE%BE%E8%AE%A1%E9%94%99%E8%AF%AFdesign-errors">设计错误(Design Errors)</a></p>
<ul>
<li><p><a class="reference external" href="#%E7%AE%80%E4%BB%8Bintroduction-1">简介(Introduction)</a></p></li>
<li><p><a class="reference external" href="#%E8%B5%8B%E5%80%BC%E8%A6%86%E7%9B%96assignment-overlap">赋值覆盖(Assignment Overlap)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%AD%90">二、例子</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E8%BF%9D%E4%BE%8Bclock-crossing-violation">跨时钟域违例(Clock crossing violation)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-1">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%AD%90-1">二、例子</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E7%BB%84%E5%90%88%E7%8E%AFcombinatorial-loop">组合环(Combinatorial loop)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-2">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%AD%90-2">二、例子</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E5%81%87%E9%98%B3%E6%80%A7false-positives">三、假阳性(false-positives)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%B1%82%E6%AC%A1%E8%BF%9D%E4%BE%8Bhierarchy-violation">层次违例(Hierarchy violation)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-3">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%AD%90-3">二、例子</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#io%E5%8C%85">IO包</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-4">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%AD%90-4">二、例子</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E9%94%81%E5%AD%98%E5%99%A8%E6%A3%80%E6%B5%8Blatch-detected">锁存器检测(Latch detected)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-5">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%AD%90-5">二、例子</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E6%97%A0%E9%A9%B1%E5%8A%A8%E6%A3%80%E6%B5%8Bno-driver-on">无驱动检测(no driver on)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-6">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%AD%90-6">二、例子</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E6%8E%92%E9%99%A4%E7%A9%BA%E6%8C%87%E9%92%88nullpointerexception">排除空指针(NullPointerException)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-7">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%AD%90-7">二、例子</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%AE%9A%E4%B9%89%E4%B8%BA%E7%BB%84%E4%BB%B6%E8%BE%93%E5%85%A5%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8register-defined-as-component-input">定义为组件输入的寄存器(Register defined as component input)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-8">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%AD%90-8">二、例子</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%BF%9D%E4%BE%8Bscope-violation">作用域违例(Scope violation)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-9">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%AD%90-9">二、例子</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#spinal%E6%97%A0%E6%B3%95%E5%85%8B%E9%9A%86%E7%B1%BBspinal-cant-clone-class">Spinal无法克隆类(Spinal can’t clone class)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-10">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%AD%901">二、例子1</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%AD%902">二、例子2</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E6%9C%AA%E5%88%86%E9%85%8D%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8unassigned-register">未分配的寄存器(Unassigned register)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-11">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%AD%90-10">二、例子</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E5%8F%AA%E6%9C%89%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8register-with-only-init">三、只有初始化的寄存器(Register with only init)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E6%97%A0%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%9A%84is%E8%A1%A8%E8%BF%B0unreachable-is-statement">无法实现的is表述(Unreachable is statement)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-12">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BE%8B%E5%AD%90-11">二、例子</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E4%BD%8D%E5%AE%BD%E4%B8%8D%E5%8C%B9%E9%85%8Dwidth-mismatch">位宽不匹配(Width mismatch)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-13">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%88%86%E9%85%8D%E8%B5%8B%E5%80%BC%E4%BE%8B%E5%AD%90">二、分配赋值例子</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B">三、操作实例</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%B9%E5%BE%81other-language-features">其他语言特征(Other language features)</a></p>
<ul>
<li><p><a class="reference external" href="#%E7%AE%80%E4%BB%8B">简介</a></p></li>
<li><p><a class="reference external" href="#%E5%B7%A5%E5%85%B7utils">工具(Utils)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80-%E6%80%BB%E8%A7%88">一、 总览</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%85%8B%E9%9A%86%E7%A1%AC%E4%BB%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bcloning-hardware-datatypes">二、克隆硬件数据类型(Cloning hardware datatypes)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%84%E5%8F%82%E6%95%B0passing-a-datatype-as-construction-parameter">三、传递数据类型作为结构参数(Passing a datatype as construction parameter)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E9%A2%91%E7%8E%87%E4%B8%8E%E6%97%B6%E9%97%B4frequency-and-time">四、频率与时间(Frequency and time)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%89%8D%E7%BC%80binary-prefix">五、二进制前缀(Binary prefix)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#stub-%E5%AD%98%E6%A0%B9">Stub (存根)</a></p></li>
<li><p><a class="reference external" href="#assertions%E6%96%AD%E8%A8%80">Assertions(断言)</a></p></li>
<li><p><a class="reference external" href="#report%E6%8A%A5%E5%91%8A">Report(报告)</a></p></li>
<li><p><a class="reference external" href="#scopeproperty%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B1%9E%E6%80%A7">ScopeProperty(作用域属性)</a></p></li>
<li><p><a class="reference external" href="#analog-and-inout-%E6%A8%A1%E6%8B%9F%E4%B8%8Eio%E5%8F%A3">Analog and inout (模拟与IO口)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-14">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Canalog%E6%A8%A1%E6%8B%9F">二、Analog(模拟)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89inoutio%E5%8F%A3">三、Inout(IO口)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9Binoutwrapperio%E5%8F%A3%E5%B0%81%E8%A3%85">四、InOutWrapper(IO口封装)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94manually-driving-analog-bundles%E6%89%8B%E5%8A%A8%E9%A9%B1%E5%8A%A8%E6%A8%A1%E6%8B%9F%E6%9D%9F">五、Manually driving Analog bundles(手动驱动模拟束)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#vhdl%E5%92%8Cverilog%E7%94%9F%E6%88%90vhdl-and-verilog-generation">VHDL和Verilog生成(VHDL and Verilog generation)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E4%BB%8E%E4%B8%80%E4%B8%AAspinalhdl%E7%BB%84%E4%BB%B6%E7%94%9F%E6%88%90vhdl%E6%88%96verilog%E4%BB%A3%E7%A0%81generate-vhdl-and-verilog-from-a-spinalhdl-component">一、从一个SpinalHDL组件生成VHDL或Verilog代码(Generate VHDL and Verilog from a SpinalHDL Component)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%B7%B2%E7%94%9F%E6%88%90%E7%9A%84vhdl%E6%88%96veriloggenerated-vhdl-and-verilog">二、已生成的VHDL或Verilog(Generated VHDL and Verilog)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89vhdl%E4%B8%8Everilog%E5%B1%9E%E6%80%A7vhdl-and-verilog-attributes">三、VHDL与Verilog属性(VHDL and Verilog attributes)</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#libraries%E5%BA%93">Libraries(库)</a></p>
<ul>
<li><p><a class="reference external" href="#%E7%AE%80%E4%BB%8B-1">简介</a></p></li>
<li><p><a class="reference external" href="#utils%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7">Utils(实用工具)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80state-less-utilities%E5%85%8D%E7%8A%B6%E6%80%81%E5%B7%A5%E5%85%B7">一、State less utilities(免状态工具)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Cstate-full-utilities%E5%85%A8%E7%8A%B6%E6%80%81%E5%B7%A5%E5%85%B7">二、State full utilities(全状态工具)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7special-utilities">三、特殊工具(Special utilities)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E6%B5%81stream">流(Stream)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E8%A7%84%E8%8C%83specification">一、规范(Specification)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E8%AF%AD%E4%B9%89semantics">二、语义(Semantics)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E5%87%BD%E6%95%B0functions">三、函数(Functions)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E5%B7%A5%E5%85%B7utils">四、工具(Utils)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#flow">Flow</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E8%A7%84%E8%8C%83specification-1">一、规范(Specification)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%87%BD%E6%95%B0functions">二、函数(Functions)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8Bcode-example">三、代码实例(code example)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E7%89%87%E6%AE%B5fragment">片段(Fragment)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E8%A7%84%E8%8C%83specification-2">一、规范(Specification)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%87%BD%E6%95%B0functions-1">二、函数(Functions)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E7%8A%B6%E6%80%81%E6%9C%BAstate-machine">状态机(State machine)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8Bintroduction-8">一、简介(Introduction)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E7%8A%B6%E6%80%81%E6%9C%BAstatemachine">二、状态机(StateMachine)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E7%8A%B6%E6%80%81states">三、状态(States)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#vexriscvrv32im-cpu">VexRiscv(RV32IM CPU)</a></p></li>
<li><p><a class="reference external" href="#%E4%BB%8E%E7%AB%AF%E6%80%BB%E7%BA%BF%E5%BA%93bus-slave-factory">从端总线库(Bus Slave Factory)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E4%BB%8B-15">一、简介</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%8A%9F%E8%83%BD%E6%80%A7functionality">二、功能性(Functionality)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E7%BA%A4%E7%A8%8B%E6%A1%86%E6%9E%B6fiber-framework">纤程框架(Fiber Framework)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%A0%B7%E4%BE%8Bsimple-dummy-example">一、简单的样例(Simple dummy example)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Chandlet">二、Handle[T]</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B3%BB%E7%BB%9Fbinary-system">二进制系统(Binary System)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E8%A7%84%E8%8C%83specification-3">一、规范(Specification)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%ACintlongbigintstring-to-intlongbigint">二、字符串转Int/Long/BigInt(String to Int/Long/BigInt)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89intlongbigint-%E8%BD%AC%E4%B8%BA-string">三、Int/Long/BigInt 转为 String</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9Bintlongbigint-%E8%BD%AC%E4%B8%BA-binary-list">四、Int/Long/BigInt 转为 Binary-List</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94binary-list-%E8%BD%AC%E4%B8%BA-intlongbigint">五、Binary-List 转为 Int/Long/BigInt</a></p></li>
<li><p><a class="reference external" href="#%E5%85%ADbigint%E6%94%BE%E5%A4%A7%E5%99%A8bigint-enricher">六、BigInt放大器(BigInt enricher)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%8E%A5%E5%8F%A3regif">寄存器接口(RegIf)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E8%87%AA%E5%8A%A8%E5%88%86%E9%85%8Dautomatic-allocation">一、自动分配(Automatic allocation)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C28%E7%A7%8D%E5%8F%AF%E6%94%AF%E6%8C%81%E7%B1%BB%E5%9E%8B28-access-types">二、28种可支持类型(28 Access Types)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E8%87%AA%E5%8A%A8%E6%96%87%E7%8C%AE%E7%94%9F%E6%88%90automatic-documentation-generation">三、自动文献生成(Automatic documentation generation)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E4%BE%8B%E5%AD%90">四、例子</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E4%B8%AD%E6%96%AD%E5%BA%93interrupt-factory">五、中断库(Interrupt Factory)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E4%B8%AD%E6%96%AD%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83interrupt-design-spec">中断设计规范(Interrupt Design Spec)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80ip%E7%BA%A7%E4%B8%AD%E6%96%AD%E5%BA%93ip-level-interrupt-factory">一、IP级中断库(IP level interrupt Factory)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E7%B3%BB%E7%BB%9F%E7%BA%A7%E4%B8%AD%E6%96%AD%E5%90%88%E5%B9%B6sys-level-interrupt-merge">二、系统级中断合并(SYS level interrupt merge)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89spinal%E5%BA%93spinal-factory">三、Spinal库(Spinal Factory)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E4%BE%8B%E5%AD%90example">四、例子(Example)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E5%BC%80%E5%8F%91%E5%8C%BA%E5%9F%9Fdevelopers-area">五、开发区域(Developers Area)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E6%80%BB%E7%BA%BFbus">总线(bus)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80ahb-lite3">一、AHB-Lite3</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Capb3">二、Apb3</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89axi4">三、Axi4</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9Bavalonmm">四、AvalonMM</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#com">Com</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80uart">一、UART</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Cusb%E8%AE%BE%E5%A4%87">二、USB设备</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#io%E5%8F%A3">IO口</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80readableopendrain">一、ReadableOpenDrain</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%B8%89%E6%80%81tristate">二、三态(Tristate)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%9B%BE%E5%BD%A2graphics">图形(Graphics)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E9%A2%9C%E8%89%B2">一、颜色</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Cvga">二、VGA</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E8%87%AA%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7eda">自动设计工具(EDA)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80qsysify">一、QSysify</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Cquartusflow">二、QuartusFlow</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E5%AF%B9%E4%BA%8E%E4%B8%80%E4%B8%AA%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E9%A1%B9%E7%9B%AEfor-an-existing-project">三、对于一个已存在的项目(For an existing project)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#misc">Misc</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80plic%E6%98%A0%E5%B0%84%E5%99%A8">一、Plic映射器</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#%E4%BB%BF%E7%9C%9Fsimulation">仿真(Simulation)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%BB%8B%E7%BB%8Dintroduction">介绍(Introduction)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80spinalhdl%E5%A6%82%E4%BD%95%E7%94%A8verilator%E4%BB%BF%E7%9C%9Fhow-spinalhdl-simulates-the-hardware-with-verilator-backend">一、SpinalHDL如何用Verilator仿真(How SpinalHDL simulates the hardware with Verilator backend)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Cspinalhdl%E5%A6%82%E4%BD%95%E7%94%A8ghdlicarus%E4%BB%BF%E7%9C%9Fhow-spinalhdl-simulates-the-hardware-with-ghdlicarus-backend">二、SpinalHDL如何用GHDL/Icarus仿真(How SpinalHDL simulates the hardware with GHDL/Icarus backend)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89spinalhdl%E5%A6%82%E4%BD%95%E7%94%A8synopsys-vcs%E4%BB%BF%E7%9C%9Fhow-spinalhdl-simulates-the-hardware-with-synopsys-vcs-backend">三、SpinalHDL如何用Synopsys VCS仿真(How SpinalHDL simulates the hardware with Synopsys VCS backend)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E6%80%A7%E8%83%BD">四、性能</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97installation-instructions">安装指南(Installation instructions)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80scala">一、Scala</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%90%8E%E7%AB%AF%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97backend-dependent-installation-instructions">二、后端相关的安装指南(Backend-dependent installation instructions)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%90%AF%E5%8A%A8%E4%BB%BF%E7%9C%9Fboot-a-simulation">启动仿真(Boot a Simulation)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E4%BB%8B%E7%BB%8Dintroduction">一、介绍(Introduction)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E9%85%8D%E7%BD%AEconfiguration">二、配置(Configuration)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E5%9C%A8%E5%90%8C%E4%B8%80%E7%A1%AC%E4%BB%B6%E4%B8%8A%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8Brunning-multiple-tests-on-the-same-hardware">三、在同一硬件上运行多个测试用例(Running multiple tests on the same hardware)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E4%BB%8E%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%8A%A5%E5%91%8A%E4%BB%BF%E7%9C%9F%E7%9A%84%E6%88%90%E5%8A%9F%E6%88%96%E5%A4%B1%E8%B4%A5throw-success-or-failure-of-the-simulation-from-a-thread">四、从线程中报告仿真的成功或失败(Throw Success or Failure of the simulation from a thread)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E8%AE%BF%E9%97%AE%E4%BB%BF%E7%9C%9F%E4%BF%A1%E5%8F%B7accessing-signals-of-the-simulation">访问仿真信号(Accessing signals of the simulation)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E8%AF%BB%E5%86%99%E4%BF%A1%E5%8F%B7read-and-write-signals">一、读写信号(Read and write signals)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%9C%A8%E6%A8%A1%E5%9D%97%E5%B1%82%E6%AC%A1%E8%AE%BF%E9%97%AE%E4%BF%A1%E5%8F%B7accessing-signals-inside-the-components-hierarchy">二、在模块层次访问信号(Accessing signals inside the component’s hierarchy)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E6%97%B6%E9%92%9F%E5%9F%9Fclock-domains-1">时钟域(Clock domains)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E6%BF%80%E5%8A%B1apistimulus-api">一、激励API(Stimulus API)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E7%AD%89%E5%BE%85apiwait-api">二、等待API(Wait API)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E4%BC%A0%E5%9B%9Eapicallback-api">三、传回API(Callback API)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E9%BB%98%E8%AE%A4%E6%97%B6%E9%92%9F%E5%9F%9Fdefault-clockdomain">四、默认时钟域(Default ClockDomain)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E6%96%B0%E6%97%B6%E9%92%9F%E5%9F%9Fnew-clockdomain">五、新时钟域(New ClockDomain)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E6%BB%A1%E7%BA%BF%E7%A8%8Bapithread-full-api">满线程API(Thread-full API)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E4%BB%BF%E7%9C%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E5%8F%89%E5%92%8C%E6%B1%87%E5%90%88fork-and-join-simulation-threads">一、仿真线程的分叉和汇合(Fork and Join simulation threads)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%BC%91%E7%9C%A0%E5%92%8C%E7%AD%89%E5%BE%85sleep-and-waituntil">二、休眠和等待(Sleep and WaitUntil)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%B0%91%E7%BA%BF%E7%A8%8Bapithread-less-api">少线程API(Thread-less API)</a></p></li>
<li><p><a class="reference external" href="#%E6%95%8F%E6%84%9Fapisensitive-api">敏感API(Sensitive API)</a></p></li>
<li><p><a class="reference external" href="#%E4%BB%BF%E7%9C%9F%E5%BC%95%E6%93%8Esimulation-engine">仿真引擎(Simulation engine)</a></p></li>
<li><p><a class="reference external" href="#%E4%BE%8B%E5%AD%90examples">例子(Examples)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E5%BC%82%E6%AD%A5%E5%8A%A0%E6%B3%95%E5%99%A8asychronous-adder">一、异步加法器(Asychronous adder)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%8F%8C%E6%97%B6%E9%92%9Ffifodual-clock-fifo">二、双时钟FIFO(Dual clock FIFO)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E5%8D%95%E6%97%B6%E9%92%9Ffifosingle-clock-fifo">三、单时钟FIFO(Single clock FIFO)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E5%90%8C%E6%AD%A5%E5%8A%A0%E6%B3%95%E5%99%A8synchronous-adder">四、同步加法器(Synchronous adder)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E4%B8%B2%E5%8F%A3%E8%AF%91%E7%A0%81%E5%99%A8uart-decoder">五、串口译码器(Uart decoder)</a></p></li>
<li><p><a class="reference external" href="#%E5%85%AD%E4%B8%B2%E5%8F%A3%E7%BC%96%E7%A0%81%E5%99%A8uart-encoder">六、串口编码器(Uart encoder)</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%BD%A2%E5%BC%8F%E9%AA%8C%E8%AF%81formal-verification">形式验证(Formal verification)</a></p>
<ul>
<li><p><a class="reference external" href="#%E9%80%9A%E5%B8%B8general">通常(General)</a></p></li>
<li><p><a class="reference external" href="#%E5%BD%A2%E5%BC%8F%E5%90%8E%E7%AB%AFformal-backend">形式后端(Formal backend)</a></p></li>
<li><p><a class="reference external" href="#%E5%AE%89%E8%A3%85%E9%9C%80%E6%B1%82installing-requirements">安装需求(Installing requirements)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%BE%E4%BE%8Bexample">举例(Example)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E5%A4%96%E9%83%A8%E6%96%AD%E8%A8%80external-assertions">一、外部断言(External assertions)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%86%85%E9%83%A8%E6%96%AD%E8%A8%80internal-assertions">二、内部断言(Internal assertions)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E5%A4%96%E9%83%A8%E6%BF%80%E5%8A%B1external-stimulus">三、外部激励(External stimulus)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%96%AD%E8%A8%80%E4%BC%A0%E9%80%92more-assertionspast">四、更多的断言/传递(More assertions/past)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E5%81%87%E8%AE%BE%E5%AD%98%E5%82%A8%E5%86%85%E5%AE%B9assuming-memory-content">五、假设存储内容(Assuming memory content)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%8E%9F%E8%AF%ADutilities-and-primitives">实用程序和原语(Utilities and primitives)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E6%96%AD%E8%A8%80%E6%97%B6%E9%92%9F%E5%A4%8D%E4%BD%8Dassertionsclockreset">一、断言/时钟/复位(Assertions/clock/reset)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E7%BB%99%E5%AE%9A%E4%BF%A1%E5%8F%B7%E5%88%9D%E5%A7%8B%E5%80%BCspecifying-the-initial-value-of-a-signal">二、给定信号初始值(Specifying the initial value of a signal)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E7%BB%99%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A3%B0%E6%98%8Especifying-a-initial-assumption">三、给定初始化声明(Specifying a initial assumption)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E5%AD%98%E5%82%A8%E5%86%85%E5%AE%B9memory-content">四、存储内容(Memory content)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E5%9C%A8%E5%A4%8D%E4%BD%8D%E5%8C%BA%E5%9F%9F%E5%86%85%E7%BB%99%E5%AE%9A%E6%96%AD%E8%A8%80specifying-assertion-in-the-reset-scope">五、在复位区域内给定断言(Specifying assertion in the reset scope)</a></p></li>
<li><p><a class="reference external" href="#%E5%85%AD%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%8E%9F%E8%AF%ADformal-primitives">六、形式化原语(Formal primitives)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E9%99%90%E5%88%B6limitations">限制(Limitations)</a></p>
<ul>
<li><p><a class="reference external" href="#%E5%9B%9B%E4%BE%8B%E5%AD%90example-1">四、例子(Example)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E5%BC%80%E5%8F%91%E5%8C%BA%E5%9F%9Fdevelopers-area-1">五、开发区域(Developers Area)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E6%80%BB%E7%BA%BFbus-1">总线(bus)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80ahb-lite3-1">一、AHB-Lite3</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Capb3-1">二、Apb3</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89axi4-1">三、Axi4</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9Bavalonmm-1">四、AvalonMM</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#com-1">Com</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80uart-1">一、UART</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Cusb%E8%AE%BE%E5%A4%87-1">二、USB设备</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#io%E5%8F%A3-1">IO口</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80readableopendrain-1">一、ReadableOpenDrain</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E4%B8%89%E6%80%81tristate-1">二、三态(Tristate)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E5%9B%BE%E5%BD%A2graphics-1">图形(Graphics)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E9%A2%9C%E8%89%B2-1">一、颜色</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Cvga-1">二、VGA</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E8%87%AA%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7eda-1">自动设计工具(EDA)</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80qsysify-1">一、QSysify</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Cquartusflow-1">二、QuartusFlow</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E5%AF%B9%E4%BA%8E%E4%B8%80%E4%B8%AA%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E9%A1%B9%E7%9B%AEfor-an-existing-project-1">三、对于一个已存在的项目(For an existing project)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#misc-1">Misc</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80plic%E6%98%A0%E5%B0%84%E5%99%A8-1">一、Plic映射器</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference external" href="#%E4%BE%8B%E5%AD%90examples-1">例子(Examples)</a></p>
<ul>
<li><p><a class="reference external" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%9E%E4%BE%8B">简单的实例</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80apb3">一、APB3</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8carry-adder">二、进位加法器(Carry Adder)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89%E9%A2%9C%E8%89%B2%E6%B1%82%E5%92%8Ccolor-summing">三、颜色求和(Color Summing)</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E5%B8%A6%E6%B8%85%E9%99%A4%E7%9A%84%E8%AE%A1%E6%95%B0%E5%99%A8counter-with-clear">四、带清除的计数器(Counter with clear)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%94%E9%94%81%E7%9B%B8%E7%8E%AF%E9%BB%91%E7%9B%92%E4%B8%8E%E5%A4%8D%E4%BD%8D%E6%8E%A7%E5%88%B6%E5%99%A8pll-blackbox-and-reset-controller">五、锁相环黑盒与复位控制器(PLL BlackBox and reset controller)</a></p></li>
<li><p><a class="reference external" href="#%E5%85%ADrgb%E8%BD%AC%E7%81%B0%E5%BA%A6%E5%9B%BE">六、RGB转灰度图</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%83%E6%AD%A3%E5%BC%A6romsinus-rom">七、正弦ROM(Sinus rom)</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E8%BF%9B%E9%98%B6%E5%AE%9E%E4%BE%8B">进阶实例</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80%E5%88%86%E5%BD%A2%E8%AE%A1%E7%AE%97%E5%99%A8fractal-calculator">一、分形计算器(Fractal calculator)</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8Cuart">二、UART</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89vga">三、VGA</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#%E9%AB%98%E7%BA%A7%E5%AE%9E%E4%BE%8B">高级实例</a></p>
<ul>
<li><p><a class="reference external" href="#%E4%B8%80jtag-tap">一、JTAG TAP</a></p></li>
<li><p><a class="reference external" href="#%E4%BA%8C%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84uartmemory-mapped-uart">二、内存映射UART(Memory mapped UART)</a></p></li>
<li><p><a class="reference external" href="#%E4%B8%89pinesec">三、Pinesec</a></p></li>
<li><p><a class="reference external" href="#%E5%9B%9B%E8%AE%A1%E6%97%B6%E5%99%A8timer">四、计时器(Timer)</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
<div STYLE="page-break-after: always;"></div></section>
<section id="spinalhdl-about-spinalhdl">
<h1>关于SpinalHDL(About SpinalHDL)<a class="headerlink" href="#spinalhdl-about-spinalhdl" title="Permalink to this heading"></a></h1>
<section id="faq">
<h2>FAQ<a class="headerlink" href="#faq" title="Permalink to this heading"></a></h2>
<section id="spinalhdlrtlvhdl-verilog">
<h3>一、SpinalHDL生成的RTL与手工书写VHDL/Verilog相比额外硬件开销有多少？<a class="headerlink" href="#spinalhdlrtlvhdl-verilog" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>开销为零, 因为SpinalHDL不是HLS方法。它的目标不是将任何任意代码翻译成RTL, 而是提供一种强大的语言来描述RTL并提高抽象级别。</p>
</div></blockquote>
</section>
<section id="spinalhdl">
<h3>二、SpinalHDL未来可能会不支持吗？<a class="headerlink" href="#spinalhdl" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>这个问题有两个方面：</p>
<p>1). SpinalHDL生成VHDL/Verilog文件, 这意味着SpinalHDL将在几十年内得到所有EDA工具的支持。</p>
<p>2). 如果SpinalHDL中存在一个错误, 并且不再支持修复它, 那么这不是一个致命的情况, 因为SpinalHDL编译器是完全开源的。对于简单的问题, 你可以在几个小时内自己解决问题。请记住EDA公司在其封闭工具中修复问题或添加新功能需要多长的时间。</p>
</div></blockquote>
</section>
<section id="spinalhdlvhdl-verilog">
<h3>三、SpinalHDL生成的VHDL/Verilog是否保持备注？<a class="headerlink" href="#spinalhdlvhdl-verilog" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>不, 没有。生成的文件应视为网表。例如, 在编译C代码时, 你是否关心生成的汇编代码中的注释？</p>
</div></blockquote>
</section>
<section id="id2">
<h3>四、SpinalHDL可以扩展到大工程吗？<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>是的, 已经做了一些实验, 它在生成带缓存的数百个3KLUT CPU只需要12秒左右, 与模拟或综合此类设计所需的时间相比, 这是一个非常短的时间。</p>
</div></blockquote>
</section>
<section id="id3">
<h3>五、SpinalHDL如何产生的？<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<blockquote>
<div><p>2014年12月至2016年4月, 这是一个个人爱好项目。但自2016年4月以来, 有一个人全职从事这项工作, 其他一些人也会定期为该项目做出贡献。</p>
</div></blockquote>
</section>
<section id="vhdl-verilog-systemverilog">
<h3>六、为什么有VHDL/Verilog/SystemVerilog还要开发新语言？<a class="headerlink" href="#vhdl-verilog-systemverilog" title="Permalink to this heading"></a></h3>
<ol>
<li><p>VHDL/Verilog/SystemVerilog不是硬件描述语言</p>
<p>这些语言最初是为仿真/文档目的创建的事件驱动语言。只是后来, 它们被用作综合工具的输入语言。这解释了本页下面许多要点的根源。</p>
</li>
<li><p>这些事件驱动范式对RTL没有任何意义</p>
<p>仔细想想, 用process/always块描述数字硬件（RTL）没有任何实际意义。为什么我们要担心敏感度列表？为什么我们必须在不同性质的process/always块（组合逻辑/无重置寄存器/异步重置寄存器）之间拆分设计？</p>
<p>等价的VHDL/SpinalHDL的例子：</p>
<p>VHDL:</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="k">signal</span><span class="w"> </span><span class="n">mySignal</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="k">signal</span><span class="w"> </span><span class="n">myRegister</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="k">signal</span><span class="w"> </span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="k">process</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"></span>
<span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">mySignal</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">        </span><span class="n">mySignal</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>

<span class="k">process</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"></span>
<span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">            </span><span class="n">myRegister</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">myRegister</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>

<span class="k">process</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span><span class="n">reset</span><span class="p">)</span><span class="w"></span>
<span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">        </span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">elsif</span><span class="w"> </span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">            </span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>SpinalHDL</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">mySignal</span><span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">myRegister</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">myRegisterWithReset</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>

<span class="n">mySignal</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">mySignal</span><span class="w">            </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="w">    </span><span class="n">myRegister</span><span class="w">          </span><span class="o">:=</span><span class="w"> </span><span class="n">myRegister</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>对于一切, 你都可以尝试这种事件驱动语言, 知道你尝试到更好的。</p>
</li>
<li><p>VHDL和Verilog的最新版本不可用。</p>
<p>EDA行业在其工具中实现VHDL 2008和SystemVerilog综合功能的速度非常慢。此外, 完成后, 似乎只实现了语言的一个约束子集（不涉及模拟特性）。这导致使用这些语言版本中任何有趣的功能都是不安全的, 因为：</p>
<ul class="simple">
<li><p>这可能会使你的代码与许多EDA工具不兼容。</p></li>
<li><p>其他公司可能不会接受你的IP, 因为他们的流程还没有准备好。</p></li>
</ul>
<p>让我告诉你, 我已经厌倦了等待昂贵的封闭源代码工具。</p>
</li>
<li><p>VHDL和Verilog的最新版本没有那么好。</p>
<p>请参阅VHDL 2008参数化包和无约束记录, 确保它可以编写更好的VHDL源代码, 但从面向对象的角度来看, 它们让我感到恶心（请参阅下一个主题, 了解SpinalHDL示例）。</p>
<p>尽管如此, 这些修订并没有改变HDL问题的核心：它们基于一种事件驱动的范式, 描述数字硬件是没有意义的。</p>
</li>
<li><p>VHDL记录(records), Verilog结构(struct)是破碎的(如果你可以使用, SystemVerilog在这方面做的很好)</p>
<p>你不能用它们来定义接口, 因为你不能定义它们的内部信号方向。 更糟糕的是, 你不能给他们构造参数！ 所以, 定义你的 RGB 记录/结构一次, 并希望你永远不必将它与更大/更小的颜色通道一起使用……</p>
<p>VHDL 的另一个奇特之处在于, 如果你想将一个数组添加到一个组件实体中, 你必须将这个数组的类型定义到一个包中……它不能被参数化……</p>
<p>以下是SpinalHDL下APB3总线的定义：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//Class which can be instantiated to represent a given APB3 configuration</span>
<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Apb3Config</span><span class="p">(</span><span class="w"></span>
<span class="n">addressWidth</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="n">dataWidth</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="n">selWidth</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="n">useSlaveError</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>

<span class="c1">//Class which can be instantiated to represent a given hardware APB3 bus</span>
<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Apb3</span><span class="p">(</span><span class="n">config</span><span class="p">:</span><span class="w"> </span><span class="nc">Apb3Config</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="nc">PADDR</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">addressWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="nc">PSEL</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">selWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="nc">PENABLE</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="nc">PREADY</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="nc">PWRITE</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="nc">PWDATA</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="nc">PRDATA</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="nc">PSLVERROR</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">useSlaveError</span><span class="p">)</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="kc">null</span><span class="w">  </span><span class="c1">//Optional signal</span>

<span class="c1">//Can be used to setup a given APB3 bus into a master interface of the host component</span>
<span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">out</span><span class="p">(</span><span class="nc">PADDR</span><span class="p">,</span><span class="nc">PSEL</span><span class="p">,</span><span class="nc">PENABLE</span><span class="p">,</span><span class="nc">PWRITE</span><span class="p">,</span><span class="nc">PWDATA</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">in</span><span class="p">(</span><span class="nc">PREADY</span><span class="p">,</span><span class="nc">PRDATA</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">useSlaveError</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nc">PSLVERROR</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>关于VHDL2008的部分解决方法和SystemVerilog接口/模组端口, 如果你的EDA工具/公司流程/公司规定允许你使用他们, 你很幸运。</p>
</li>
<li><p>VHDL和Verilog非常冗长。</p>
<p>实际上, 使用VHDL和Verilog, 当它开始涉及组件实例互连时, 需要考虑复制过去的产品。</p>
<p>为了更深入地理解它, 有一个SpinalHDL示例, 它执行一些外围设备实例化, 并添加访问它们所需的APB3解码器。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//Instanciate an AXI4 to APB3 bridge</span>
<span class="kd">val</span><span class="w"> </span><span class="n">apbBridge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Axi4ToApb3Bridge</span><span class="p">(</span><span class="w"></span>
<span class="n">addressWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"></span>
<span class="n">dataWidth</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>
<span class="n">idWidth</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>

<span class="c1">//Instanciate some APB3 peripherals</span>
<span class="kd">val</span><span class="w"> </span><span class="n">gpioACtrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3Gpio</span><span class="p">(</span><span class="n">gpioWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">gpioBCtrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3Gpio</span><span class="p">(</span><span class="n">gpioWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">timerCtrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">PinsecTimerCtrl</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">uartCtrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3UartCtrl</span><span class="p">(</span><span class="n">uartCtrlConfig</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">vgaCtrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Axi4VgaCtrl</span><span class="p">(</span><span class="n">vgaCtrlConfig</span><span class="p">)</span><span class="w"></span>

<span class="c1">//Instanciate an APB3 decoder</span>
<span class="c1">//- Drived by the apbBridge</span>
<span class="c1">//- Map each peripherals in a memory region</span>
<span class="kd">val</span><span class="w"> </span><span class="n">apbDecoder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3Decoder</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">master</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apbBridge</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">slaves</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">gpioACtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="mh">0x00000</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="nc">KiB</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">gpioBCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="mh">0x01000</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="nc">KiB</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="mh">0x10000</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="nc">KiB</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">timerCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="mh">0x20000</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="nc">KiB</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">vgaCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="w">   </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="mh">0x30000</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="nc">KiB</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>这样, 当你实例化一个模块/组件时, 你不必逐个绑定每个信号, 因为你可以以面向对象的方式访问它们的接口。</p>
<p>同样关于VHDL/Verilog 的struct/records, 我只想说它们真的是肮脏的把戏, 没有真正的参数化和可重用性功能, 一些拐杖试图掩盖这些语言设计拙劣的事实。</p>
</li>
<li><p>元硬件描述的功能和能力</p>
<p>好的, 这是一大块。基本上, VHDL/Verilog/SystemVerilog将为你提供一些精化工具, 这些工具不会直接映射到硬件中, 例如loops/generate语句/macro/function/process/task。但仅此而已。</p>
<p>甚至它们也非常有限。举例来说, 为什么不能将process/alwasys/compents/module块定义为task/process？这真的是许多新奇事物的瓶颈。如果你在总线调用一个用户定义的task/procedure, 比如myHandshakeBus.quequ(depth=64)？这不是很爽吗？</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//Define the concept of handshake bus</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Stream</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">dataType</span><span class="p">:</span><span class="w">  </span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">valid</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ready</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cloneOf</span><span class="p">(</span><span class="n">dataType</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//Define an operator to connect the left operand (this) to the right operand (that)</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">&gt;&gt;</span><span class="p">(</span><span class="n">that</span><span class="p">:</span><span class="w"> </span><span class="nc">Stream</span><span class="p">[</span><span class="nc">T</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">this</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="n">valid</span><span class="w"></span>
<span class="w">        </span><span class="n">that</span><span class="p">.</span><span class="n">ready</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">ready</span><span class="w"></span>
<span class="w">        </span><span class="bp">this</span><span class="p">.</span><span class="n">payload</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="n">payload</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//Return a Stream connected to this via a FIFO of depth elements</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">queue</span><span class="p">(</span><span class="n">depth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">):</span><span class="w"> </span><span class="nc">Stream</span><span class="p">[</span><span class="nc">T</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">fifo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StreamFifo</span><span class="p">(</span><span class="n">dataType</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="bp">this</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">fifo</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fifo</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>然后让我们进一步了解, 假设你想要定义一个状态机, 你必须编写原始VHDL/Verilog和一些开关语句来完成。你不能定义一种“状态机”抽象, 这种抽象会给你一种奇特的语法来定义它们, 相反, 你必须使用第三方工具来绘制你的状态机, 然后生成与VHDL/Verilog等效的代码。这真的很乱。</p>
<p>因此, 所谓元硬件描述能力, 我指的是通过使用原始SpinalHDL语法, 你可以定义工具, 然后允许你以抽象的方式定义事物, 比如状态机。</p>
<p>这里还有一个简单的定义在顶层SpinalHDL的状态机抽象使用的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//Define a new state machine</span>
<span class="kd">val</span><span class="w"> </span><span class="n">fsm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StateMachine</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//Define all states</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">stateA</span><span class="p">,</span><span class="w"> </span><span class="n">stateB</span><span class="p">,</span><span class="w"> </span><span class="n">stateC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"></span>

<span class="w">    </span><span class="c1">//Set the state machine entry point</span>
<span class="w">    </span><span class="n">setEntry</span><span class="p">(</span><span class="n">stateA</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//Define a register used into the state machine</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//Define the state machine behavioural</span>
<span class="w">    </span><span class="n">stateA</span><span class="p">.</span><span class="n">whenIsActive</span><span class="w"> </span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="n">stateB</span><span class="p">))</span><span class="w"></span>

<span class="w">    </span><span class="n">stateB</span><span class="p">.</span><span class="n">onEntry</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">stateB</span><span class="p">.</span><span class="n">onExit</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">stateB</span><span class="p">.</span><span class="n">whenIsActive</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">4</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">goto</span><span class="p">(</span><span class="n">stateC</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">stateC</span><span class="p">.</span><span class="n">whenIsActive</span><span class="w"> </span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="n">stateA</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>同样, 如果你想生成CPU的指令解码, 可能需要一些花哨的精化时间算法来生成尽可能少的逻辑。但是, 在VHDL/Verilog/SystemVerilog中, 执行此类操作的唯一选择是编写一个脚本, 生成所需的.vhd/.v。</p>
<p>关于元硬件描述确实有很多话要说, 但要理解它并获得它真正的味道, 唯一真正的方法是对它进行实验。它的目标是停止像猴子一样玩弄电线和门, 开始与那些低级的东西保持一定距离, 思考更大和可重用的东西。</p>
</li>
</ol>
</section>
<section id="git-spinalhdl">
<h3>七、如何使用未发布(但是已经提交到git)的SpinalHDL版本？<a class="headerlink" href="#git-spinalhdl" title="Permalink to this heading"></a></h3>
<p>例如, 如果你想尝试<code class="docutils literal notranslate"><span class="pre">dev</span></code>分支, 在dummy文件夹中做如下操作：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">git</span><span class="w"> </span><span class="n">clone</span><span class="w"> </span><span class="n">https</span><span class="p">:</span><span class="c1">//github.com/SpinalHDL/SpinalHDL.git -b dev</span>
<span class="n">cd</span><span class="w"> </span><span class="nc">SpinalHDL</span><span class="w"></span>
<span class="n">sbt</span><span class="w"> </span><span class="n">clean</span><span class="w"> </span><span class="n">publishLocal</span><span class="w"></span>
</pre></div>
</div>
<p>在你的工程中, 不要忘记更新build.sbt选定的SpinalHDL的版本, 应该是”dev”而不是”?.?.?”</p>
</section>
</section>
<section id="support">
<h2>支持(Support)<a class="headerlink" href="#support" title="Permalink to this heading"></a></h2>
<section id="communication-channels">
<h3>一、联系渠道(Communication channels)<a class="headerlink" href="#communication-channels" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>支持错误报告和功能请求的通信渠道, 毫不犹豫地创建github问题：   https://github.com/SpinalHDL/SpinalHDL/</p></li>
<li><p>有关SpinalHDL语法和现场对话的问题, 可以使用Gitter频道：   https://gitter.im/SpinalHDL/SpinalHDL</p></li>
<li><p>如果问题你还可以使用带有标签StackOverflow的论坛:    spinalhl:https://StackOverflow.com/</p></li>
<li><p>也可以通过谷歌查询。你可以随意发布与SpinalHDL相关的任何主题：  https://groups.google.com/forum/#!forum/spinalhdl-hardware-description-language</p></li>
</ul>
</section>
<section id="commercial-support">
<h3>二、商业支持(Commercial support)<a class="headerlink" href="#commercial-support" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>如果你对演示、研讨会或咨询感兴趣, 请随时通过电子邮件与我们联系：spinalhdl&#64;gmail.com</p></li>
</ul>
</section>
</section>
<section id="users">
<h2>用户(Users)<a class="headerlink" href="#users" title="Permalink to this heading"></a></h2>
<section id="companies">
<h3>一、公司(Companies)<a class="headerlink" href="#companies" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>QsPin, Belgium</p></li>
<li><p>DatenLord, China</p></li>
</ul>
</section>
<section id="repositories">
<h3>二、仓库(Repositories)<a class="headerlink" href="#repositories" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>J1Sc Stack CPU</p></li>
<li><p>VexRiscv CPU and SoC</p></li>
<li><p>NaxRiscv CPU</p></li>
<li><p>SaxonSoc</p></li>
<li><p>open-rdma</p></li>
<li><p>MicroRV32 SoC</p></li>
</ul>
<div STYLE="page-break-after: always;"></div></section>
</section>
</section>
<section id="getting-started">
<h1>开始入门(Getting Started)<a class="headerlink" href="#getting-started" title="Permalink to this heading"></a></h1>
<section id="id4">
<h2>开始入门(Getting Started)<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h2>
<p>SpinalHDL 是一种用 Scala 编写的硬件描述语言, Scala 是一种使用 Java 虚拟机 (JVM) 的静态类型功能语言。 为了开始使用 SpinalHDL 进行编程, 你必须拥有 JVM 以及 Scala 编译器。 在下一节中, 我们将说明如果你还没有这些工具, 如何下载它们。</p>
<section id="requirements-things-to-download-to-get-started">
<h3>一、开始所要下载的必要条件/事情(Requirements/Things to download to get started)<a class="headerlink" href="#requirements-things-to-download-to-get-started" title="Permalink to this heading"></a></h3>
<p>在你下载SpinalHDL工具之前, 你应该安装：</p>
<ul class="simple">
<li><p>Java JDK</p></li>
<li><p>Scala 2.11.X版本</p></li>
<li><p>SBT搭建工具</p></li>
</ul>
<p>可选择：</p>
<ul class="simple">
<li><p>推荐你用带有Scala接口的IntelliJ IDEA</p></li>
<li><p>Git, 用来版本控制</p></li>
</ul>
</section>
<section id="spinalhdl-how-to-start-programming-with-spinalhdl">
<h3>二、如何开始用SpinalHDL编程(How to start programming with SpinalHDL)<a class="headerlink" href="#spinalhdl-how-to-start-programming-with-spinalhdl" title="Permalink to this heading"></a></h3>
<p>下载所有要求后, 有两种方法可以开始 SpinalHDL 编程。</p>
<ul class="simple">
<li><p>SBT方式：如果你已经熟悉 SBT 构建系统和/或如果你不需要 IDE；</p></li>
<li><p>IDE方式：获取已经在 IDE 中为你设置的项目并立即开始编程。</p></li>
</ul>
<ol>
<li><p>SBT方式(SBT way)</p>
<p>我们在 Github 上为你准备了一个现成的项目。</p>
<ul class="simple">
<li><p>clone或下载”getting started”仓库；</p></li>
<li><p>在它的根目录中打开一个终端并运行<code class="docutils literal notranslate"><span class="pre">sbt</span> <span class="pre">run</span></code>。 当你第一次执行它时, 该过程可能需要一些时间, 因为它将下载运行SpinalHDL所需的所有依赖项。</p></li>
</ul>
<p>正常情况下, 这个命令必定生成一个输出文件<code class="docutils literal notranslate"><span class="pre">MyTopLevel.vhd</span></code>, 对应<code class="docutils literal notranslate"><span class="pre">src\main\scala\MyCode.scala</span></code>中定义的顶层SpinalHDL代码, 对应最简单的SpinalHDL例子。</p>
<p>在干净的Debian发行版中, 你可以在shell中键入以下命令。这些命令将安装 ava、Scala、SBT, 下载基础项目, 并生成相应的VHDL文件。如果你第一次运行它需要一些时间, 请不要担心。</p>
<div class="highlight-Linux notranslate"><div class="highlight"><pre><span></span>sudo apt-get install openjdk-8-jdk
sudo apt-get install scala
echo &quot;deb https://repo.scala-sbt.org/scalasbt/debian all main&quot; | sudo tee /etc/apt/sources.list.d/sbt.list
echo &quot;deb https://repo.scala-sbt.org/scalasbt/debian /&quot; | sudo tee /etc/apt/sources.list.d/sbt_old.list
curl -sL &quot;https://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x2EE0EA64E40A89B84B2DF73499E82A75642AC823&quot; | sudo apt-key add
sudo apt-get update
sudo apt-get install sbt
git clone https://github.com/SpinalHDL/SpinalTemplateSbt.git SpinalTemplateSbt
cd SpinalTemplateSbt
sbt run   # select &quot;mylib.MyTopLevelVhdl&quot; in the menu
ls MyTopLevel.vhd
</pre></div>
</div>
<p><strong>离线SBT环境</strong></p>
<p>通常, SBT使用在线存储库来下载和缓存你的项目依赖项, 此缓存位于你的<code class="docutils literal notranslate"><span class="pre">home/.ivy2</span></code>文件夹中。设置无互联网环境的方法是从缓存已被填充一次的互联网完整环境中复制此缓存, 然后将其复制到你的无互联网环境中。</p>
<p>可移植的SBT搭建途径：https://www.scala-sbt.org/download.html</p>
</li>
<li><p>用带有Scala接口的IntelliJ IDEA的IDE方式(The IDE way, with IntelliJ IDEA and its Scala plugin)</p>
<p>除了上述要求外, 还需要下载IntelliJ IDEA(免费社区版就够了)。 安装IntelliJ后, 还要检查是否启用了它的Scala插件(可以在此处找到安装信息)。</p>
<p>进行如下操作：</p>
<ul class="simple">
<li><p>clone或下载”getting started”仓库。</p></li>
<li><p>在IntelliJ IDEA, 使用此存储库的根目录“import project”, 选择从外部模型SBT导入项目并确保选中所有框。</p></li>
<li><p>此外, 你可能需要指定一些路径, 例如将JDK安装到IntelliJ的位置。</p></li>
<li><p>在项目(Intellij 项目 GUI)中, 右键单击<code class="docutils literal notranslate"><span class="pre">src/main/scala/mylib/MyTopLevel.scala</span></code>并选择“Run MyTopLevel”。</p></li>
</ul>
<p>这应该会在项目目录中生成输出文件<code class="docutils literal notranslate"><span class="pre">MyTopLevel.vhd</span></code>, 它实现了一个简单的 8 位计数器。</p>
</li>
</ol>
</section>
<section id="spinalhdl-a-very-simple-spinalhdl-example">
<h3>三、一个非常简单的SpinalHDL例子(A very simple SpinalHDL example)<a class="headerlink" href="#spinalhdl-a-very-simple-spinalhdl-example" title="Permalink to this heading"></a></h3>
<p>以下代码生成有两个1-bit输入<code class="docutils literal notranslate"><span class="pre">and</span></code>门：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AND_Gate</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="cm">/**</span>
<span class="cm">    * This is the component definition that corresponds to</span>
<span class="cm">    * the VHDL entity of the component</span>
<span class="cm">    */</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Here we define some asynchronous logic</span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">object</span><span class="w"> </span><span class="nc">AND_Gate</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Let&#39;s go</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nc">SpinalVhdl</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">AND_Gate</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如你所见, 你必须在SpinalHDL中编写的第一行是<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">spinal.core._</span></code>, 这表明我们正在使用文件中的Spinal组件。</p>
<ol>
<li><p>生成代码(Generated code)</p>
<p>一旦你成功编译代码, 编译器会生成如下VHDL代码：</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="k">package</span><span class="w"> </span><span class="n">pkg_enum</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="nc">pkg_enum</span><span class="p">;</span><span class="w"></span>

<span class="k">package</span><span class="w"> </span><span class="n">pkg_scala2hdl</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">end</span><span class="w">  </span><span class="nc">pkg_scala2hdl</span><span class="p">;</span><span class="w"></span>

<span class="k">library</span><span class="w"> </span><span class="nn">ieee</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="nn">ieee.std_logic_1164.</span><span class="k">all</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="nn">ieee.numeric_std.</span><span class="k">all</span><span class="p">;</span><span class="w"></span>

<span class="k">library</span><span class="w"> </span><span class="nn">work</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="nn">work.pkg_scala2hdl.</span><span class="k">all</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="nn">work.</span><span class="k">all</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="nn">work.pkg_enum.</span><span class="k">all</span><span class="p">;</span><span class="w"></span>


<span class="k">entity</span><span class="w"> </span><span class="nc">AND_Gate</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="k">port</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">io_a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">io_b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">io_c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="nc">AND_Gate</span><span class="p">;</span><span class="w"></span>

<span class="k">architecture</span><span class="w"> </span><span class="nc">arch</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nc">AND_Gate</span><span class="w"> </span><span class="k">is</span><span class="w"></span>

<span class="k">begin</span><span class="w"></span>
<span class="n">io_c</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">io_a</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">io_b</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="nc">arch</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="what-to-do-next">
<h3>四、接下来做什么?(What to do next?)<a class="headerlink" href="#what-to-do-next" title="Permalink to this heading"></a></h3>
<p>这取决于你, 但为什么不看看SpinalHDL中的类型或发现该语言提供哪些原语来描述硬件组件呢？ 你还可以查看我们的示例, 了解你接下来可以做什么的一些示例。</p>
</section>
</section>
<section id="motivation">
<h2>目的(Motivation)<a class="headerlink" href="#motivation" title="Permalink to this heading"></a></h2>
<p>见PPT</p>
</section>
<section id="presentation">
<h2>表现(Presentation)<a class="headerlink" href="#presentation" title="Permalink to this heading"></a></h2>
<p>见PPT</p>
</section>
<section id="scala-scala-guide">
<h2>Scala指导手册(Scala Guide)<a class="headerlink" href="#scala-scala-guide" title="Permalink to this heading"></a></h2>
<section id="basics">
<h3>简介(Basics)<a class="headerlink" href="#basics" title="Permalink to this heading"></a></h3>
<p>Scala是一款功能强大的编程语言, 它的产生受到了很多其他独特语言的影响, 但这些语言常常不为大多数程序员所使用。这也会阻碍scala新人们对scala概念和它背后的设计抉择。</p>
<p>下面会介绍Scala, 并常识为新人们提供学习SpinalHDL的基本Scala语法。</p>
</section>
<section id="id5">
<h3>一、基础<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h3>
<ol>
<li><p>数据类型(Types)</p>
<p>在Scala中, 有五种主要类型：</p>
</li>
</ol>
<pre><code>| 数据类型 |     举例      |         描述          |
| :------: | :-----------: | :-------------------: |
| Boolean  |  true, false  |
|   Int    |    3, 0*32    |    32bits integer     |
|  Float   |     3.14f     | 32bits floating point |
|  Doublt  |     3.14      | 64bits floating point |
|  String  | "Hello world" |     UTF-16 string     |
</code></pre><ol>
<li><p>变量(Variables)</p>
<p>在Scala中, 使用<code class="docutils literal notranslate"><span class="pre">var</span></code>关键字来定义变量, 即<code class="docutils literal notranslate"><span class="pre">val/var</span> <span class="pre">变量名:</span> <span class="pre">变量类型</span> <span class="pre">=</span> <span class="pre">初始值</span></code>。var在Scala中是变量的声明, 而val是常量的声明, 但是在SpinalHDL中可以用<code class="docutils literal notranslate"><span class="pre">:=</span></code>对val量赋值：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="w"></span>
<span class="n">number</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="n">println</span><span class="p">(</span><span class="n">number</span><span class="p">)</span><span class="w"> </span><span class="c1">//10</span>
</pre></div>
</div>
<p>Scala能够自动推断数据类型, 在给变量赋初值的时候你不必指明数据类型。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">//number的数据类型在编译过程中推断为Int</span>
</pre></div>
</div>
<p>然而, 在Scala中使用var并不常见。取而代之的, 由<code class="docutils literal notranslate"><span class="pre">val</span></code>定义的常量更加常用：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">three</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">six</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">three</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>函数(Functions)</p>
<p>例如, 如果想定义一个两个参数和大于0时返回<code class="docutils literal notranslate"><span class="pre">true</span></code>的函数, , 你可以这样做：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">sumBiggerThanZero</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在调用函数的时候, 用以下方式：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">sumBiggerThanZero</span><span class="p">(</span><span class="mf">2.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">5.4f</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>你也可以通过加入参数的名字来给特定参数赋值,  这在参数较多的函数中十分有效：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">sumBiggerThanZero</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.3f</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.4f</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<ol>
<li><p>返回(Return)</p>
<p><code class="docutils literal notranslate"><span class="pre">return</span></code>关键字并不是必要的, 当缺省时, Scala会把最后一行函数作为返回值的声明：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">sumBiggerThanZero</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>返回类型推断(Return type inferation)</p>
<p>Scala能够自动推断返回类型, 无须声明：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">sumBiggerThanZero</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>花括号(Cuely braces)</p>
<p>如果你的函数内只有一条声明, Scala函数不需要花括号：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">sumBiggerThanZero</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>无返回值的函数(Function that returns nothing)</p>
<p>如果想要让一个函数不返回任何值, 返回类型应该设置为<code class="docutils literal notranslate"><span class="pre">Uint</span></code>, 这等价于C/C++中的<code class="docutils literal notranslate"><span class="pre">void</span></code>类型</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">printer</span><span class="p">():</span><span class="w"> </span><span class="nc">Uint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;1234&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;5678&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>参数的默认值(Argument default values)</p>
<p>你可以给函数中的每个参数指定一个默认值：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">sumBiggerThanZero</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>应用(Apply)</p>
<p>名为<code class="docutils literal notranslate"><span class="pre">apply</span></code>的函数是一类特殊的函数, 你可以不输入名字就能调用他们：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Array</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">apply</span><span class="p">(</span><span class="n">index</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">):</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Array</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">//array(4)指一个数组, apply(4)的返回值所7</span>
</pre></div>
</div>
<p>这种概念也适用于Scala中的<code class="docutils literal notranslate"><span class="pre">object</span></code>(静态)</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">MajorityVote</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">apply</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">):</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">MajorityVote</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">//会调用MajorityVote.apply(4)</span>
</pre></div>
</div>
</li>
</ol>
</li>
<li><p>对象(Object)</p>
<p>在Scala中, 没有<code class="docutils literal notranslate"><span class="pre">static</span></code>关键字, 取而代之的是<code class="docutils literal notranslate"><span class="pre">object</span></code>。每一个定义在<code class="docutils literal notranslate"><span class="pre">object</span></code>中的定义都是静态的。</p>
<p>下面这个例子定义了一个叫做<code class="docutils literal notranslate"><span class="pre">pow2</span></code>的静态函数, 该函数以浮点数作为参数输入, 返回值类型也是浮点数。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">MathUtils</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">pow2</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">):</span><span class="w"> </span><span class="nc">Float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>然后可以通过以下书写方式调用：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="nc">MathUtils</span><span class="p">.</span><span class="n">pow2</span><span class="p">(</span><span class="mf">42.0f</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>入口点(Entry point(main))</p>
<p>Scala程序的入口点(主函数)应该作为一个名为<code class="docutils literal notranslate"><span class="pre">main</span></code>的函数定义在一个对象当中</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">MyTopLevelMain</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>类(Class)</p>
<p>类的语法与Java非常相似。假设你想要定义一个把三个浮点数(r, g, b)作为结构体参数的<code class="docutils literal notranslate"><span class="pre">Color</span></code>类：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Color</span><span class="p">(</span><span class="n">r</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">getGrayLevel</span><span class="p">():</span><span class="w"> </span><span class="nc">Float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.3f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.4f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.4f</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>之后, 从上一个例子中实例化类并使用<code class="docutils literal notranslate"><span class="pre">getGrayLevel</span></code>函数：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">blue</span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">grayLevelOfBlue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blue</span><span class="p">.</span><span class="n">getGrayLevel</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>需要注意的是, 如果你想从类的外部访问类中的结构体参数, 这个结构体参数应该被定义成<code class="docutils literal notranslate"><span class="pre">val</span></code>类型：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Color</span><span class="p">(</span><span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">,</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">g</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">,</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">blue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">redLevelOfBlue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blue</span><span class="p">.</span><span class="n">r</span><span class="w"></span>
</pre></div>
</div>
<ol>
<li><p>继承(Inheritance)</p>
<p>作为例子, 假设你想要定义两个类, <code class="docutils literal notranslate"><span class="pre">Rectangle</span></code>和<code class="docutils literal notranslate"><span class="pre">Square</span></code>, 并延伸出类<code class="docutils literal notranslate"><span class="pre">Shape</span></code>：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">getArea</span><span class="p">():</span><span class="w"> </span><span class="nc">Float</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Square</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">getArea</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sideLength</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sideLength</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Rectangle</span><span class="p">(</span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">getArea</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>用例类(Case class)</p>
<p>用例类(Case class)是声明类的另一种方式。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Rectangle</span><span class="p">(</span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">:;</span><span class="w"> </span><span class="nc">Float</span><span class="p">)</span><span class="w"> </span><span class="n">wxtends</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">getArea</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>但是<code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">class</span></code>和<code class="docutils literal notranslate"><span class="pre">class</span></code>之间有一些区别：</p>
<ul class="simple">
<li><p>用例类不需要<code class="docutils literal notranslate"><span class="pre">new</span></code>关键字来实例化</p></li>
<li><p>用例类中的结构参数外界是可访问的, 不用把他们定义成<code class="docutils literal notranslate"><span class="pre">val</span></code></p></li>
</ul>
<p>在SpinalHDL中, 这解释了代码约束背后的原因：一般来说更推荐用<code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">class</span></code>而不是<code class="docutils literal notranslate"><span class="pre">class</span></code>, 这样能够减少打字数并且一致性更好</p>
</li>
</ol>
</li>
<li><p>模板/类型参数化(Templates/Type parameterization)</p>
<p>假设你想要设计一组给定数据类型的类, 在这个背景下你需要给类提供一个参数类型：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Queue</span><span class="p">[</span><span class="nc">T</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="n">that</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">pop</span><span class="p">():</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果你想要把<code class="docutils literal notranslate"><span class="pre">T</span></code>类型约束成给定类型的子类(例如<code class="docutils literal notranslate"><span class="pre">Shape</span></code>), 你可以用<code class="docutils literal notranslate"><span class="pre">&lt;:</span> <span class="pre">Shape</span></code>语句实现。<code class="docutils literal notranslate"><span class="pre">&lt;:</span></code>在Scala中表示给类型添加上界, 表示泛型参数必须要从该类(或本身)继承：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Shape</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">getArea</span><span class="p">():</span><span class="w"> </span><span class="nc">Float</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Rectangle</span><span class="p">()</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Queue</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Shape</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="n">that</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">pop</span><span class="p">():</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>对于函数也是同理：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">doSomething</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Shape</span><span class="p">](</span><span class="n">shape</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">):</span><span class="w"> </span><span class="nc">Something</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">shape</span><span class="p">.</span><span class="n">getArea</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="coding-conventions">
<h3>二、代码约束(Coding conventions)<a class="headerlink" href="#coding-conventions" title="Permalink to this heading"></a></h3>
<ol>
<li><p>介绍(Introduction)</p>
<p>SpinalHDL中的代码约束与Scala Style Guide中描述的一样, 有一些额外的实用细节和案例会在下一章中讲解</p>
<p>https://docs.scala-lang.org/style/</p>
</li>
<li><p>类 vs 用例类(class vs case class)</p>
<p>当你定义了一个<code class="docutils literal notranslate"><span class="pre">Bundle</span></code>或是一个<code class="docutils literal notranslate"><span class="pre">Component</span></code>, 声明成用例类(case class)更好, 理由如下：</p>
<ul class="simple">
<li><p>避免使用<code class="docutils literal notranslate"><span class="pre">new</span></code>关键字, 在某些条件下, 永远不用再使用它总比有时会用到要强。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">class</span></code>提供了<code class="docutils literal notranslate"><span class="pre">clone</span></code>函数。后者在SpinalHDL中十分有用, 因为SpinalHDL中会需要克隆<code class="docutils literal notranslate"><span class="pre">Bundle</span></code>, 例如, 当你定义一个新的<code class="docutils literal notranslate"><span class="pre">Reg</span></code>或是一个新的<code class="docutils literal notranslate"><span class="pre">Stream</span></code>之类的东西时。</p></li>
<li><p>结构体参数在外部是直接可见的。</p></li>
</ul>
<ol>
<li><p>[用例]类</p>
<p>所有类的首字母都应该大写</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Fifo</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Counter</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Color</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>伴生对象</p>
<p>一个伴生对象(companion object)应该首字母大写</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">Fifo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">apply</span><span class="p">(</span><span class="n">that</span><span class="p">:</span><span class="w"> </span><span class="nc">Stream</span><span class="p">[</span><span class="nc">Bits</span><span class="p">]):</span><span class="w"> </span><span class="nc">Stream</span><span class="p">[</span><span class="nc">Bits</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">object</span><span class="w"> </span><span class="nc">MajorityVote</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">apply</span><span class="p">(</span><span class="n">that</span><span class="p">:</span><span class="w"> </span><span class="nc">Bits</span><span class="p">):</span><span class="w"> </span><span class="nc">UInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这种规则有个例外就是, 当伴生对象被用作函数(里面只有<code class="docutils literal notranslate"><span class="pre">apply</span></code>), 并且这些<code class="docutils literal notranslate"><span class="pre">apply</span></code>函数不产生硬件电路：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">log2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">apply</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">):</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</li>
<li><p>函数(Function)</p>
<p>一个函数总以小写字母开头：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">sinTable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">sampleCount</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">sampleIndex</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">sinValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Math</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nc">Math</span><span class="p">.</span><span class="nc">PI</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sampleIndex</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">sampleCount</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="nc">S</span><span class="p">((</span><span class="n">sinValue</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">resolutionWidth</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)).</span><span class="n">toInt</span><span class="p">,</span><span class="w"> </span><span class="n">resolutionWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">})</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">rom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Mem</span><span class="p">(</span><span class="nc">SInt</span><span class="p">(</span><span class="n">resolutionWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="n">initialContent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sinTable</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>实例(Instances)</p>
<p>类的实例应该总以小写字母开头</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">fifo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Fifo</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>if/when</p>
<p>Scala的<code class="docutils literal notranslate"><span class="pre">if</span></code>和SpinalHDL的<code class="docutils literal notranslate"><span class="pre">when</span></code>都一般以如下方式书写：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}.</span><span class="n">elseWhen</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}.</span><span class="n">otherwise</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>例外：</p>
<ul class="simple">
<li><p>可以省略<code class="docutils literal notranslate"><span class="pre">otherwise</span></code>前的点</p></li>
<li><p>如果可以增强代码的可读性, 可以把<code class="docutils literal notranslate"><span class="pre">if</span></code>/<code class="docutils literal notranslate"><span class="pre">when</span></code>的声明写在一行</p></li>
</ul>
</li>
<li><p>switch</p>
<p>SpinalHDL<code class="docutils literal notranslate"><span class="pre">switch</span></code>一般应该以如下方式书写：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">switch</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">default</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果可以增强代码的可读性, 可以把<code class="docutils literal notranslate"><span class="pre">is</span></code>/<code class="docutils literal notranslate"><span class="pre">default</span></code>声明写在一行</p>
</li>
<li><p>参数(Parameters)</p>
<p>推荐把<code class="docutils literal notranslate"><span class="pre">Component</span></code>/<code class="docutils literal notranslate"><span class="pre">Bundle</span></code>的参数打包到一个用例(case)中, 如下例中<code class="docutils literal notranslate"><span class="pre">RgbConfig</span></code>, 因为：</p>
<ul class="simple">
<li><p>更容易携带/操作以对设计进行配置</p></li>
<li><p>更好的维护性</p></li>
</ul>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">RgbConfig</span><span class="p">(</span><span class="n">rWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">gWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">bWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">getWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rWidth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">gWidth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bWidth</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Rgb</span><span class="p">(</span><span class="n">c</span><span class="p">:</span><span class="w"> </span><span class="nc">RgbConfig</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">rWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">gWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">bWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>但这并不适用于所有情况。例如, 在FIFO中, 把<code class="docutils literal notranslate"><span class="pre">dataType</span></code>参数和<code class="docutils literal notranslate"><span class="pre">depth</span></code>参数打包在一起所不合理的, 因为一般来说, <code class="docutils literal notranslate"><span class="pre">dataType</span></code>所于设计相关的参数, 而<code class="docutils literal notranslate"><span class="pre">depth</span></code>所于配置相关的参数</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Fifo</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">dataType</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="id6">
<h3>三、交互<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介(Introduction)</p>
<p>事实上, SpinalHDL不是一门语言, 更像是常规的Scala库。第一次看到它可能会觉得很奇怪, 但等你用久了就会发现SpinalHDL很好地结合了RTL和Scala。</p>
<p>你可以通过SpinalHDL库用整个Scala世界帮助你描述硬件电路, 但是为了恰到好处的做到这件事, 你需要理解SpinalHDL如何于Scala交互。</p>
</li>
<li><p>SpinalHDL是怎样在API背后工作的(How SpinalHDL works behind the API)</p>
<p>当你执行SpinalHDL硬件描述, 每当你使用SpinalHDL函数、操作符或类, 都会在内存中建立一个代表你设计的网表的图。</p>
<p>之后, 当硬件描述完成(顶层<code class="docutils literal notranslate"><span class="pre">Component</span></code>类的实例化), SpinalHDL会再遍历建立好的网表图, 如果一切就绪, SpinalHDL就会把图冲刷掉并把它构建成VHDL或Verilog文件。</p>
</li>
<li><p>所有都是引用(Everything is a reference)</p>
<p>例如, 如果你定义了一个接受<code class="docutils literal notranslate"><span class="pre">Bits</span></code>类型参数的Scala函数, 当你调用它, 它会作为引用传递。因此, 如果你在函数内给这个参数赋值, 它对底层<code class="docutils literal notranslate"><span class="pre">Bits</span></code>对象的影响就会像在函数外赋值一样。</p>
</li>
<li><p>硬件类型(Hardware types)</p>
<p>SpinalHDL中的硬件数据类型所两个事情的结合：</p>
<ul class="simple">
<li><p>一个给定Scala类型的实例化</p></li>
<li><p>那个实例的配置</p></li>
</ul>
<p>例如<code class="docutils literal notranslate"><span class="pre">Bits(8bits)</span></code>是Scala类型<code class="docutils literal notranslate"><span class="pre">Bits</span></code>和它的<code class="docutils literal notranslate"><span class="pre">8</span> <span class="pre">bits</span></code>配置(作为结构体参数)的结合</p>
<p><strong>RGB举例</strong></p>
<p>我们以一个RGB包举例说明：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Rgb</span><span class="p">(</span><span class="n">rWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">gWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">bWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">rWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">gWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">bWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这里的硬件数据类型是Scala<code class="docutils literal notranslate"><span class="pre">Rgb</span></code>类和它的<code class="docutils literal notranslate"><span class="pre">rWidth</span></code>, <code class="docutils literal notranslate"><span class="pre">gWidth</span></code>, <code class="docutils literal notranslate"><span class="pre">bWidth</span></code>参数的结合</p>
<p>以下是这个例子的使用：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// 定义一个Rgb信号</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myRgbSignal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Rgb</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"></span>

<span class="c1">//定义另一个与前一个相同数据类型的Rgb信号</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myRgbCloned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cloneOf</span><span class="p">(</span><span class="n">myRgbSignal</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码生成的Verilog如下所示(位宽有所调整)：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myRgbSignal_r</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myRgbSignal_g</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myRgbSignal_b</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myRgbCloned_r</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myRgbCloned_g</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myRgbCloned_b</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>你也可以用函数来定义各种各样的类别(typedef)：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//定义一个类别函数</span>
<span class="k">def</span><span class="w"> </span><span class="nf">myRgbTypeDef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Rgb</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"></span>

<span class="c1">//使用这个类别加工函数产生Rgb信号</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myRgbFromTypeDef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myRgbTypeDef</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>产生的RTL中信号的名称(Names of signals in the generated RTL)</p>
<p>在给产生的RTL中命名信号时, SpinalHDL会用Java映射遍历各个模块的层次, 收集所有存储在类属性中的引用, 并用他们的属性名命名他们。</p>
<p>每个在函数内定义的本地信号名字会丢失, 如下所示：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">myFunction</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">temp</span><span class="o">=</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">//你无法在产生的RTL中取回取回temp信号</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">temp</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myFunction</span><span class="p">(</span><span class="nc">U</span><span class="s">&quot;000001&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
</pre></div>
</div>
<p>如果你想要在产生的RTL中保留内部变量的名字, 可以用<code class="docutils literal notranslate"><span class="pre">Area</span></code>：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">myFunction</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">//你能在产生的RTL中取回取回temp信号</span>
<span class="p">}</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">myFunctionCall</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myFunction</span><span class="p">(</span><span class="nc">U</span><span class="s">&quot;000001&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">//会随着myFunctionCall.temp产生temp信号</span>
<span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myFunctionCall</span><span class="p">.</span><span class="n">temp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码会产生如下Verilog：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">5</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myFunctionCall_temp</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">5</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">value</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">myFunctionCall_temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">6&#39;h01</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">6&#39;h01</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">myFunctionCall_temp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">6&#39;h2a</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Scala用来加工, SpinalHDL用来描述硬件(Scala is for elaboration, SpinalHDL for hardware description)</p>
<p>例如, 如果你用Scala的for循环产生硬件电路, 它会产生展开后的VHDL/Verilog形式的结果</p>
<p>还有, 如果你想要一个常量, 你不应该用SpinalHDL硬件语句, 而应该用Scala的。例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//这是错的, 因为你不能用硬件Bool作为结构参数, 这会导致层次违例</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SubComponent</span><span class="p">(</span><span class="n">activeHigh</span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">//这是对的, 你可以用Scala的任何语句来参数化硬件电路</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SubComponent</span><span class="p">(</span><span class="n">activeHigh</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Scala的细化能力(if, for, 和函数化编程)(Scala elaboration capabilities)</p>
<p>所有的Scala语法都能用来描述硬件设计, 例如, Scala的<code class="docutils literal notranslate"><span class="pre">if</span></code>语句能用来使能电路的生成：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="k">if</span><span class="p">(</span><span class="n">generateAClearWhenHit42</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">//加工测试, 好比是是否生成vhdl</span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">      </span><span class="c1">//硬件测试</span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>对于Scala的<code class="docutils literal notranslate"><span class="pre">for</span></code>循环也是同理：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">something</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//通过使用Scala的for循环置位每一bit</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">value</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码生成的Verilog如下所示：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">assign</span><span class="w"> </span><span class="n">when_Main_l17</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">something</span><span class="p">;</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_Main_l17</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">value</span><span class="p">[</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">value</span><span class="p">[</span><span class="mh">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">value</span><span class="p">[</span><span class="mh">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">value</span><span class="p">[</span><span class="mh">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">value</span><span class="p">[</span><span class="mh">4</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">value</span><span class="p">[</span><span class="mh">5</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">value</span><span class="p">[</span><span class="mh">6</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">value</span><span class="p">[</span><span class="mh">7</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
<p>同样的, SpinalHDL类型也能使用函数化的编程技术(最好之后能补充通配符的用法)</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">valuesAre42</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">values</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">_===</span><span class="mi">42</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">valuesAreAll42</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">valuesAre42</span><span class="p">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">_&amp;&amp;_</span><span class="p">)</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">valuesAreEqualToTheirIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">values</span><span class="p">.</span><span class="n">zipWithIndex</span><span class="p">.</span><span class="n">map</span><span class="p">{</span><span class="w"> </span><span class="k">case</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码生成的Verilog如下所示：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">values_0</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">values_1</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">values_2</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">values_3</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">valuesAre42_0</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">valuesAre42_1</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">valuesAre42_2</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">valuesAre42_3</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">valuesAreAll42</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">valuesAreEqualToTheirIndex_0</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">valuesAreEqualToTheirIndex_1</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">valuesAreEqualToTheirIndex_2</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">valuesAreEqualToTheirIndex_3</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">valuesAre42_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">values_0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h2a</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">valuesAre42_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">values_1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h2a</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">valuesAre42_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">values_2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h2a</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">valuesAre42_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">values_3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h2a</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">valuesAreAll42</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">valuesAre42_0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">valuesAre42_1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">valuesAre42_2</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">valuesAre42_3</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">valuesAreEqualToTheirIndex_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">values_0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">valuesAreEqualToTheirIndex_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">values_1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h01</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">valuesAreEqualToTheirIndex_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">values_2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h02</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">valuesAreEqualToTheirIndex_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">values_3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h03</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="vhdl-help-for-vhdl-people">
<h2>对VHDL的支持(Help for VHDL people)<a class="headerlink" href="#vhdl-help-for-vhdl-people" title="Permalink to this heading"></a></h2>
<section id="vhdl-vhdl-comparison">
<h3>一、VHDL对比(VHDL comparison)<a class="headerlink" href="#vhdl-vhdl-comparison" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介(Introduction)</p>
<p>这部分展示了VHDL与SpinalHDL的主要区别, 并不会太深入地解释</p>
</li>
<li><p>处理(Process)</p>
<p>编写RTL的过程也是一个数据处理的过程, 然而VHDL的语法太过于笨重。由于语法在VHDL中的工作方式, 语句会迫使你分隔你的代码块并造成冗余。</p>
<p>例如, 为了产生下述RTL：</p>
<p><img alt="process" src="_images/process_rtl.svg" /></p>
<p>在VHDL中书写格式如下：</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="k">signal</span><span class="w"> </span><span class="n">mySignal</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="k">signal</span><span class="w"> </span><span class="n">myRegister</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="k">signal</span><span class="w"> </span><span class="n">myRegister</span><span class="w"> </span><span class="k">With</span><span class="w"> </span><span class="n">Reset</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">process</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">mySignal</span><span class="w"> </span><span class="n">N</span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">            </span><span class="n">mySignal</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">process</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">                </span><span class="n">myRegister</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">myRegister</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">process</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span><span class="n">reset</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">            </span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="k">others</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">elsif</span><span class="w"> </span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">                </span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>而在SpinalHDL中, 将是这样：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">mySignal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">myRegister</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>

<span class="n">mySignal</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">mySignal</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="w">    </span><span class="n">myRegister</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">myRegister</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码生成的Verilog如下所示：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">mySignal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_cond</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">mySignal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">io_reg2out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myRegisterWithReset</span><span class="p">;</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">io_cond</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">myRegisterWithReset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0001</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_cond</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">myRegister</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">myRegister</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0001</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>清晰定义 vs 不清晰的定义(Implicit vs explicit definitions)</p>
<p>在VHDL中, 当你声明一个信号, 你不会指定它是组合逻辑的信号还是寄存器。赋值的位置和方式决定它的数据类型。</p>
<p>在SpinalHDL中, 这些信号的类型是清晰的, 寄存器以他们的定义方式直接定义为寄存器。</p>
</li>
<li><p>时钟域(Clock domains)</p>
<p>在VHDL中, 每当你定义一组寄存器, 你需要一并定义时钟和他们的复位信号。此外你还需要定义这些时钟和复位信号的行为(clock edge, reset polarity, reset nature (async, sync))。</p>
<p>而在SpinalHDL中, 你可以定义<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>, 然后定义该时钟域的作用区域即可。例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">coreClockDomain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">coreClk</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">reset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">coreReset</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomainConfig</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">clockEdge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RISING</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">resetKind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ASYNC</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">resetActiveLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">High</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">coreArea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockingArea</span><span class="p">(</span><span class="n">coreClockDomain</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">myCoreClockedRegister</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="c1">// coreClockDomain会被应用到这个区域内所有的子模块中</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码生成的Verilog如下所示：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">io_coreClk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">io_coreReset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_coreReset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">coreArea_myCoreClockedRegister</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">coreArea_myCoreClockedRegister</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_grey</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>模块的内部组织(Component’s internal organization)</p>
<p>在VHDL中, <code class="docutils literal notranslate"><span class="pre">block</span></code>的特征允许编程者定义子区域的内部逻辑。然而, 因为大多数人不知道模块属性, 几乎没有人用这个特征, 还有一个原因就是定义在这些区域内部的信号外部所无法读取的。</p>
<p>在SpinalHDL中, 有<code class="docutils literal notranslate"><span class="pre">Area</span></code>特征来更友好地实现模块化：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">overflow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">=/=</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">overflow</span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">core</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">timeout</span><span class="p">.</span><span class="n">overflow</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">timeout</span><span class="p">.</span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码生成的Verilog如下：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_overflow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">when_Main_l11</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">io_overflow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">when_Main_l11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">timeout_counter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">8&#39;h64</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">io_counter_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timeout_counter</span><span class="p">;</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">timeout_counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">when_Main_l11</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">timeout_counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">timeout_counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">8&#39;h01</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">io_overflow</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">timeout_counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
<p>定义在<code class="docutils literal notranslate"><span class="pre">Area</span></code>中的信号和变量在这个组分内的任何位置都是可以访问的, 也包括其他的<code class="docutils literal notranslate"><span class="pre">Area</span></code>区域</p>
</li>
<li><p>安全性(Safety)</p>
<p>在VHDL和SpinalHDL中, 很容易在无意间写出组合逻辑环, 或者因为忘记驱动处理流路径上的信号而引入latch。</p>
<p>那么, 为了检测这些问题, 你可以用<code class="docutils literal notranslate"><span class="pre">lint</span></code>工具帮你分析VHDL, 但是这些工具都是付费的。在SpinalHDL中, <code class="docutils literal notranslate"><span class="pre">lint</span></code>处理过程集成到了编译器内部, 除非所有的问题都被排查才会生成RTL, 这个编译器还会检查时钟域交叉；</p>
</li>
<li><p>函数和程序(Functions and procedures)</p>
<p>因为函数和程序在VHDL中的局限性很大, 所以他们很少被使用到：</p>
<ul class="simple">
<li><p>你只能定义一块组合逻辑电路或一块寄存器电路(如果在有时钟的处理块中就会综合成寄存器电路)</p></li>
<li><p>你不能在他们内部定义嵌套处理块</p></li>
<li><p>你不能在他们内部实例化模块</p></li>
<li><p>你在他们内部的读写范围所十分有限的</p></li>
</ul>
<p>在SpinalHDL中, 这些限制就都没有了。</p>
<p>以下是一个在函数中混合组合逻辑和寄存器逻辑的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">simpleAluPipeline</span><span class="p">(</span><span class="n">op</span><span class="p">:</span><span class="w"> </span><span class="nc">Bits</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="p">):</span><span class="w"> </span><span class="nc">UInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">switch</span><span class="p">(</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">is</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">is</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">is</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码生成的Verilog如下：(与上述代码有所不同的是增加了位宽对其操作, 即(io.a+io.b).resize(8 bits)</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_result</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_result_1</span><span class="p">;</span><span class="w"></span>
<span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">result</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">_zz_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io_b</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">_zz_result_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">io_b</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">io_c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="p">(</span><span class="n">io_op</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">{</span><span class="mh">4</span><span class="mi">&#39;d0</span><span class="p">,</span><span class="w"> </span><span class="n">_zz_result</span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">        </span><span class="mh">4</span><span class="mb">&#39;b0001</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">{</span><span class="mh">4</span><span class="mi">&#39;d0</span><span class="p">,</span><span class="w"> </span><span class="n">_zz_result_1</span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">        </span><span class="mh">4</span><span class="mb">&#39;b0010</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">io_a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">io_b</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">        </span><span class="k">default</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">endcase</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
<p>下面是将Stream包(握手机制)中的队列函数实例化成FIFO模块的例子：(该代码有待实现)</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Stream</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">dataType</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">DataCarrier</span><span class="p">[</span><span class="nc">T</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cloneOf</span><span class="p">(</span><span class="n">dataType</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">queue</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">):</span><span class="w"> </span><span class="nc">Stream</span><span class="p">[</span><span class="nc">T</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">fifo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StreamFifo</span><span class="p">(</span><span class="n">dataType</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">fifo</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="bp">this</span><span class="w"></span>
<span class="w">        </span><span class="n">fifo</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>下面这个例子是函数给定义在函数体外的信号赋值：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Uint</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="k">def</span><span class="w"> </span><span class="nf">clear</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">when</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">clear</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码生成的Verilog如下：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">counter</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">when_Main_l15</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">when_Main_l15</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">8&#39;h2a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">counter</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">io_cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="p">;</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">8&#39;h01</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">when_Main_l15</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>总线和接口(Buses and Interfaces)</p>
<p>VHDL在编写总线与接口的时候非常不友好, 因为在这种时候你往往只有两个选择：</p>
<p>(1) 无论何时, 都是逐线地定义总线和接口：</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">PADDR</span><span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="n">addressWidth</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">PSEL</span><span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="w"></span>
<span class="n">PENABLE</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="n">PREADY</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="n">PWRITE</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="n">PWDATA</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="n">dataWidth</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">PRDATA</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="n">dataWidth</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);(</span><span class="w"></span>
</pre></div>
</div>
<p>(2) 可以使用记录(records)但不能参数化(在每个代码包中所静态固定的), 并且你需要定义双向：</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">P_m</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">APB_M</span><span class="p">;</span><span class="w"></span>
<span class="n">P_s</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">APB_S</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>但是SpinalHDL能很好地支持总线与接口的声明, 并且可以随意参数化：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="nc">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">Apb3</span><span class="p">(</span><span class="n">addressWidth</span><span class="p">,</span><span class="w"> </span><span class="n">dataWidth</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>你也可以用面向对象的编程思路来定义可配置的对象：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">coreConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">CoreConfig</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">pcWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">addrWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">startAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">,</span><span class="n">regFileReadKind</span><span class="w"> </span><span class="o">=</span><span class="n">sync</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">branchPrediction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dynamic</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">bypassExecute0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">bypassExecute1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">bypassWriteBack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">bypassWriteBackBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">collapseBuddle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">fastFetchCmdPcCalculation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">dynamicBranchPredictorCacheSizeLog2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>

<span class="c1">//CPU有一套能够在内核中增加新特征的接口</span>
<span class="c1">//这些拓展不是直接实现在内核中, 而是在一个分离的区域(block)中定义的额外逻辑</span>
<span class="n">coreConfig</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">MulExtension</span><span class="p">)</span><span class="w"></span>
<span class="n">coreConfig</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">DivExtension</span><span class="p">)</span><span class="w"></span>
<span class="n">coreConfig</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">BarrelShifterFullExtension</span><span class="p">)</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">iCacheConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">InstructionCacheConfig</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">cacheSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">bytePerLine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">wayCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="c1">//现在只能是4</span>
<span class="w">    </span><span class="n">wrappedMemAccess</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">addressWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">cpuDataWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">memDataWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>

<span class="k">new</span><span class="w"> </span><span class="nc">RiscvCoreAxi4</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">coreConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">coreConfig</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">iCacheConfig</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">iCacheConfig</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">dCacheConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">debug</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">debug</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">interruptCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">interruptCount</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>信号声明(Signal declaration)</p>
<p>令人烦恼的是, VHDL迫使你在架构描述的最顶端定义所有的信号。</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span>..
..(许多信号声明)
..
signal a : std_logic;
..
..(许多信号声明)
..
a &lt;= x &amp; y
..
..(许多信号声明)
..
</pre></div>
</div>
<p>在信号声明的方面, SpinalHDL则具有更好的灵活性</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>
<p>也可以一行完成定义</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>块例化(Component instantiation)</p>
<p>VHDL对于块的实例化的书写非常繁琐, 需要编程人员在底层模块实例中重新定义所有的信号, 并且把信号一个一个对接起来。</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">divider_cmd_valid</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="n">divider_cmd_ready</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="n">divider_cmd_numerator</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">31</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">divider_cmd_denominator</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">31</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">divider_rsp_valid</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="n">divider_rsp_ready</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="n">divider_rsp_quotient</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">31</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">divider_rsp_remainder</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">31</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="n">divider</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">entity</span><span class="w"> </span><span class="nc">work</span><span class="p">.</span><span class="n">UnsignedDivider</span><span class="w"></span>
<span class="w">  </span><span class="k">port</span><span class="w"> </span><span class="k">map</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">clk</span><span class="w">             </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">reset</span><span class="w">           </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">reset</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">cmd_valid</span><span class="w">       </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">divider_cmd_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">cmd_ready</span><span class="w">       </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">divider_cmd_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">cmd_numerator</span><span class="w">   </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">divider_cmd_numerator</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">cmd_denominator</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">divider_cmd_denominator</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">rsp_valid</span><span class="w">       </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">divider_rsp_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">rsp_ready</span><span class="w">       </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">divider_rsp_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">rsp_quotient</span><span class="w">    </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">divider_rsp_quotient</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">rsp_remainder</span><span class="w">   </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">divider_rsp_remainder</span><span class="w"></span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>SpinalHDL移除了这一点, 并且允许你以一种面向对象的方式访问底层模块的IO</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span>val divider = new UnsignedDivider()

// 如果你想要访问除法器的IO信号
divider.io.cmd.valid := True
divider.io.cmd.numerator := 42
</pre></div>
</div>
</li>
<li><p>转换关系(Casting)</p>
<p>在VHDL中有两种不方便的转换关系的思路：</p>
<ul class="simple">
<li><p>boolean&lt;&gt;std_logic(条件赋值是不允许的, 例如<code class="docutils literal notranslate"><span class="pre">mySignal</span> <span class="pre">&lt;=</span> <span class="pre">myValue</span> <span class="pre">&lt;</span> <span class="pre">10</span></code>)</p></li>
<li><p>unsigned&lt;&gt;integer(访问数组)</p></li>
</ul>
<p>SpinalHDL通过统一转换关系让其变得更加便利。</p>
<p>boolean/std_logic:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">valueBiggerThanTwo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="n">valueBiggerThanTwo</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="c1">//当value &gt; 2返回布尔值</span>
</pre></div>
</div>
<p>上述代码生成Verilog如下：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">assign</span><span class="w"> </span><span class="n">io_valBiggerThanTwo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">8&#39;h02</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">io_value</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>unsigned/integer：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">sel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">arraySel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span><span class="w"> </span><span class="c1">//数组直接用UInt标号</span>
</pre></div>
</div>
<p>上述代码生成Verilog如下：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_arraySel</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">array_0</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">array_1</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">array_2</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">array_3</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">array_4</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">array_5</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">array_6</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">array_7</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">sel</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">arraySel</span><span class="p">;</span><span class="w"></span>

<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="mh">3</span><span class="mb">&#39;b000</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">_zz_arraySel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="mh">3</span><span class="mb">&#39;b001</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">_zz_arraySel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="mh">3</span><span class="mb">&#39;b010</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">_zz_arraySel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="mh">3</span><span class="mb">&#39;b011</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">_zz_arraySel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_3</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="mh">3</span><span class="mb">&#39;b100</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">_zz_arraySel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_4</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="mh">3</span><span class="mb">&#39;b101</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">_zz_arraySel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_5</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="mh">3</span><span class="mb">&#39;b110</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">_zz_arraySel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_6</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">default</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">_zz_arraySel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_7</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">endcase</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">io_valBiggerThanTwo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">8&#39;h02</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">io_value</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">arraySel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_arraySel</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>改变大小(Resizing)</p>
<p>实际上, VHDL对bit宽度的严谨要求是很好的</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="n">my8BitsSignal</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">resize</span><span class="p">(</span><span class="n">my4BitsSignal</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>在SpinalHDL中, 有两种方法可以做到对bit宽度的精准定义</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//传统方法</span>
<span class="n">my8BitsSignal</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">my4BitsSignal</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"></span>

<span class="c1">//更好的方法</span>
<span class="n">my8BitsSignal</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">my4BitsSignal</span><span class="p">.</span><span class="n">resized</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码均会生成如下Verilog：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">assign</span><span class="w"> </span><span class="n">my8BitsSignal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">4</span><span class="mi">&#39;d0</span><span class="p">,</span><span class="w"> </span><span class="n">my4BitsSignal</span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>参数化(Parameterization)</p>
<p>VHDL在2008版本修订之前, 泛型(generics)上存在很多问题。例如, 你不能参数化记录, 你不能在实例中参数化数组, 并且不能有变量类型。</p>
<p>之后VHDL2008出现并且解决了这些问题。但是出于供应商的原因, RTL工具对VHDL2008的支持十分不友好。</p>
<p>SpinalHDL把泛型功能都集成在它的编译器中支持, 并且不依赖于任何VHDL泛型。</p>
<p>以下是数据结构参数化的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">colorStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Color</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">colorFifo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StreamFifo</span><span class="p">(</span><span class="nc">Color</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">),</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">)</span><span class="w"></span>
<span class="n">colorFifo</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">colorStream</span><span class="w"></span>
</pre></div>
</div>
<p>以下是参数化模块的例子：(该例子有待实现)</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Arbiter</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">payloadType</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">portCount</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">sources</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="n">slave</span><span class="p">(</span><span class="nc">Stream</span><span class="p">(</span><span class="n">payloadType</span><span class="p">)),</span><span class="w"> </span><span class="n">portCount</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">cal</span><span class="w"> </span><span class="n">sink</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">Stream</span><span class="p">(</span><span class="n">payloadType</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>大型硬件电路描述(Meta hardware description)</p>
<p>VHDL更像是一种封闭的语法, 你无法在它的顶层增加抽象层。</p>
<p>而因为SpinalHDL所建立在Scala的基础上的, 非常的灵活, 允许编程人员很容易地定义新的抽象层。</p>
<p>可以在FSM库, BusSlaveFactory库, JTAG库中体验这种灵活性。</p>
</li>
</ol>
</section>
<section id="vhdl-vhdl-equivalences">
<h3>二、VHDL等效(VHDL equivalences)<a class="headerlink" href="#vhdl-vhdl-equivalences" title="Permalink to this heading"></a></h3>
<ol>
<li><p>架构与实例(Entity and architecture)</p>
<p>在SpinalHDL中, VHDL实例和架构都定义在<code class="docutils literal notranslate"><span class="pre">Component</span></code>里。</p>
<p>以下是一个有着三输入(a, b, c)和一个输出(result)的模块的例子。这个模块也有<code class="docutils literal notranslate"><span class="pre">offset</span></code>结构体参数(如同VHDL中的类指)</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Mycomponent</span><span class="p">(</span><span class="n">offset</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>之后如要实例化这个模块, 你不需要再对端口逐一绑定：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">mySubCompoent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">MyComponent</span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="p">...</span><span class="w"></span>

<span class="w">    </span><span class="n">mySubComponent</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="n">mySubComponent</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">    </span><span class="n">mySubComponent</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="w">    </span><span class="o">???</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mySubComponent</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"></span>

<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码生成的Verilog如下所示：(方便起见增加了一些额外信号, 不影响上述代码逻辑)</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">(...);</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">mySubComponent_io_result</span><span class="p">;</span><span class="w"></span>

<span class="n">MyComponent</span><span class="w"> </span><span class="n">mySubComponent</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">io_a</span><span class="w">      </span><span class="p">(</span><span class="mh">8&#39;h01</span><span class="w">                        </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_b</span><span class="w">      </span><span class="p">(</span><span class="mh">8&#39;h02</span><span class="w">                        </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_c</span><span class="w">      </span><span class="p">(</span><span class="mh">8&#39;h03</span><span class="w">                        </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_result</span><span class="w"> </span><span class="p">(</span><span class="n">mySubComponent_io_result</span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">])</span><span class="w">  </span><span class="c1">//o</span>
<span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">io_grey</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_io_grey</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mySubComponent_io_result</span><span class="p">);</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>

<span class="k">module</span><span class="w"> </span><span class="n">MyComponent</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_a</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_b</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_c</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_result</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_io_result</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_io_result_1</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">_zz_io_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_io_result_1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io_c</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">_zz_io_result_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io_b</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">io_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_io_result</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">8&#39;h05</span><span class="p">);</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>数据类型(Data types)</p>
<p>Spinal的数据类型类似于VHDL的：
|       VHDL       | SpinalHDL |
| :————–: | :——-: |
|    std_logic     |   Bool    |
| std_logic_vector |   Bits    |
|     unsigned     |   UInt    |
|      signed      |   SInt    |</p>
<p>在VHDL中, 为了定义一个8bit<code class="docutils literal notranslate"><span class="pre">unsigned</span></code>你需要给定其范围, 即<code class="docutils literal notranslate"><span class="pre">unsigned(7</span> <span class="pre">downto</span> <span class="pre">0)</span></code>, 然而在SpinalHDL中你只需要声明其bit位数即可<code class="docutils literal notranslate"><span class="pre">UInt(8</span> <span class="pre">bits)</span></code></p>
</li>
</ol>
<pre><code>|  VHDL   | SpinalHDL  |
| :-----: | :--------: |
| records |   Bundle   |
|  array  |    Vec     |
|  enum   | SpinalEnum |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>以下是SpinalHDL中`Bundle`的定义, `channelWidth`是结构体参数, 如同VHDL的泛型：

```Scala
case class RGB(channelWidth: Int) extends Bundle {
    val r, g, b = UInt(ChannelWidth bits)
}
```

之后如果想实例化一个`Bundle`, 需要写``val myColor = RGB(channelWidth=8)`.
</pre></div>
</div>
<ol>
<li><p>信号(Signal)</p>
<p>这是一个信号实例化的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Mycomponent</span><span class="p">(</span><span class="n">offset</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">ab</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">abc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ab</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">c</span><span class="w">    </span><span class="c1">//能够直接用上一步的值定义信号</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">abc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码生成的Verilog如下：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">MyComponent</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_a</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_b</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_c</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_result</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">ab</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">abc</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">ab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io_b</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">abc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ab</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io_c</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">io_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">abc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">8&#39;h05</span><span class="p">);</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>赋值(Assignments)</p>
<p>在SpinalHDL中, <code class="docutils literal notranslate"><span class="pre">:=</span></code>赋值操作符等价于VHDL中的信号赋值<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">6</span><span class="w"></span>
</pre></div>
</div>
<p>条件赋值可以通过<code class="docutils literal notranslate"><span class="pre">if</span></code>/<code class="docutils literal notranslate"><span class="pre">case</span></code>声明实现, 如同VHDL一样：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">clear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>

<span class="n">when</span><span class="p">(</span><span class="n">clear</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="p">}.</span><span class="n">elsewhen</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">76</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">79</span><span class="w"></span>
<span class="p">}.</span><span class="n">otherwise</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">counter</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">switch</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">65</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">default</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码生成的Verilog如下所示：(上述逻辑直接编译汇报错, 因为counter赋值有冲突, 稍作更改生成如下同等逻辑代码)</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">counter</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">when_Main_l21</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">when_Main_l23</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">when_Main_l21</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h4c</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">when_Main_l23</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h2a</span><span class="p">);</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">io_clear</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">when_Main_l21</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">                </span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h4f</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">when_Main_l23</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">                    </span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h41</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">                    </span><span class="n">counter</span><span class="p">[</span><span class="mh">7</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">counter</span><span class="p">[</span><span class="mh">7</span><span class="p">]);</span><span class="w"></span>
<span class="w">                    </span><span class="n">counter</span><span class="p">[</span><span class="mh">6</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="p">[</span><span class="mh">6</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">7&#39;h01</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="k">end</span><span class="w"></span>
<span class="w">            </span><span class="k">end</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>程序的语言描述(Literals)</p>
<p>和VHDL相比程序的语言描述形式有一些不同：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">myBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="n">myBool</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="n">myBool</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="n">myBool</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&quot;0001_1100&quot;</span><span class="w"></span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&quot;xEE&quot;</span><span class="w"></span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">U</span><span class="p">(</span><span class="mi">54</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">((</span><span class="mi">3</span><span class="w"> </span><span class="n">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">myBool</span><span class="p">,</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="c1">//有所不同</span>
<span class="n">when</span><span class="p">(</span><span class="n">myUInt</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">U</span><span class="p">(</span><span class="n">myUInt</span><span class="p">.</span><span class="n">range</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">          </span><span class="c1">//也有所不同</span>
<span class="w">    </span><span class="n">myUInt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码生成的Verilog如下所示：(以下assign语句均相互独立生成, 只是集中呈现在这里)</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span><span class="w">                </span><span class="n">myBool</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myUInt</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">myBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h1c</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">myBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;hee</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">myBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h2a</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h36</span><span class="p">;</span><span class="w"></span>

<span class="c1">//有所不同</span>
<span class="kt">wire</span><span class="w">                </span><span class="n">myBool</span><span class="p">;</span><span class="w"></span>
<span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myUInt</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">myBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;hff</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">myUInt</span><span class="p">[</span><span class="mh">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myBool</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">myUInt</span><span class="p">[</span><span class="mh">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myBool</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">myUInt</span><span class="p">[</span><span class="mh">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myBool</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">myUInt</span><span class="p">[</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myBool</span><span class="p">;</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="c1">//也有所不同</span>
<span class="kt">wire</span><span class="w">                </span><span class="n">myBool</span><span class="p">;</span><span class="w"></span>
<span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myUInt</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_when_Main_l17</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">when_Main_l17</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">myBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">_zz_when_Main_l17</span><span class="p">[</span><span class="mh">7</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;hff</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">when_Main_l17</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">myUInt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">_zz_when_Main_l17</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">io_output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myBool</span><span class="p">;</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">myUInt</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">when_Main_l17</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">myUInt</span><span class="p">[</span><span class="mh">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p>备注：需要注意的是, SpinalHDL与Scala对大小写的区分尤为严格, True代表Bool(), true代表Boolean(), false同理。</p>
</div></blockquote>
</li>
<li><p>寄存器(Registers)</p>
<p>在SpinalHDL中, 寄存器是被清晰地指定的, 而VHDL中则是根据赋值方式推断出的。以下是SpinalHDL的寄存器例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">//每周期自增1</span>

<span class="c1">//init(0)意味着当复位信号有效, 寄存器初始化为0</span>
</pre></div>
</div>
<p>上述代码生成的Verilog如下：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">counter</span><span class="p">;</span><span class="w"></span>

<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h00</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">8&#39;h01</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>进程块(Process blocks)</p>
<p>进程块(process block)是一种仿真特征, 在RTL设计中并非必要。这就是为什么SpinalHDL没有包含任何对进程块的类, 所以你可以按照你所想的去给任何地方赋值。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">myCombinatorial</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">myRegister</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="n">myCombinatorial</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">myCombinatorial</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="w">    </span><span class="n">myRegister</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">myRegister</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码生成的Verilog如下所示：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span><span class="w">                </span><span class="n">cond</span><span class="p">;</span><span class="w"></span>
<span class="kt">reg</span><span class="w">                 </span><span class="n">myCombinatorial</span><span class="p">;</span><span class="w"></span>
<span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myRegister</span><span class="p">;</span><span class="w"></span>

<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">myCombinatorial</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">myCombinatorial</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_input</span><span class="p">;</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">myRegister</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">myRegister</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">myRegister</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">8&#39;h01</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
<div STYLE="page-break-after: always;"></div></section>
</section>
</section>
<section id="data-types">
<h1>数据类型(Data types)<a class="headerlink" href="#data-types" title="Permalink to this heading"></a></h1>
<section id="introduction">
<h2>简介(Introduction)<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<p>SpinalHDL语言提供了五种基本数据类型和两种复合类型。</p>
<p><img alt="image/2022-08-29-10-06-13.png" src="image/2022-08-29-10-06-13.png" /></p>
<ul class="simple">
<li><p>基础类型：Bool, Bits, UInt无符号整型, SInt有符号整型, Enum</p></li>
<li><p>复合类型：Bundle和Vec</p></li>
</ul>
<p><img alt="数据类型" src="_images/types.svg" /></p>
<p>除了这些基础类型, Spinal还提供了以下的拓展：</p>
<ul class="simple">
<li><p>Fixed-point数(部分支持)</p></li>
<li><p>Floating-point数(实验支持)</p></li>
</ul>
<p>最后, 还有一种特殊类型能够检查BitVector和bit常量是否相等, 且可以添加无效位。如下所示：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span>val myBits = Bits(8 bits)
val itMatch = myBits === M&quot;00--10--“    // - 为无效位
</pre></div>
</div>
<p>Verilog</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myBits</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">itMatch</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">itMatch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">myBits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">8&#39;hcc</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h08</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="bool">
<h2>Bool<a class="headerlink" href="#bool" title="Permalink to this heading"></a></h2>
<section id="description">
<h3>一、描述(Description)<a class="headerlink" href="#description" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Bool</span></code>数据类型对应于布尔值(True/False)</p>
</section>
<section id="declaration">
<h3>二、声明(Declaration)<a class="headerlink" href="#declaration" title="Permalink to this heading"></a></h3>
<p>声明布尔值的语法如下所示：([]中的内容可填项)</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">语法</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Bool[()]</td>
<td style="text-align: center;">创建Bool量</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">True</td>
<td style="text-align: center;">创建值为<code>true</code>的Bool量</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">False</td>
<td style="text-align: center;">创建值为<code>false</code>的Bool量</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">Bool(value:Boolean)</td>
<td style="text-align: center;">创建一个值为Scala Boolean(true, false)的Bool量</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table><div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">myBool_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w">   </span><span class="c1">//创建一个Bool</span>
<span class="n">myBool_1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w">       </span><span class="c1">//:=是赋值操作符</span>

<span class="kd">val</span><span class="w"> </span><span class="n">myBool_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">False</span><span class="w">    </span><span class="c1">//与上一行等价</span>

<span class="kd">val</span><span class="w"> </span><span class="n">myBool_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="c1">//用Scala Boolean类型创建Bool</span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span><span class="w">                </span><span class="n">myBool_1</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">myBool_2</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">myBool_3</span><span class="p">;</span><span class="w"></span>
<span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">counter</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">myBool_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">myBool_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">myBool_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="operators">
<h3>三、操作符(Operators)<a class="headerlink" href="#operators" title="Permalink to this heading"></a></h3>
<p>下列操作符可以用<code class="docutils literal notranslate"><span class="pre">Bool</span></code>类型：</p>
<ol class="simple">
<li><p>逻辑运算(Logic)</p></li>
</ol>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">!x</td>
<td style="text-align: center;">逻辑非</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">x &amp;&amp; y<br>x &amp; y</td>
<td style="text-align: center;">逻辑与</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">x &#124;&#124; y<br>x &#124; y</td>
<td style="text-align: center;">逻辑或</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">x ^ y</td>
<td style="text-align: center;">逻辑异或</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">x.set[()]</td>
<td style="text-align: center;">置位True</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">x.clear[()]</td>
<td style="text-align: center;">置位False</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">x.setWhen(cond)</td>
<td style="text-align: center;">条件True置位1</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">x.clearWhen(cond)</td>
<td style="text-align: center;">条件True置位0</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">x.riseWhen(cond)</td>
<td style="text-align: center;">x是False且条件True置位1</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">x.fallWhen(cond)</td>
<td style="text-align: center;">x是True且条件True置位0</td>
<td style="text-align: center;">Bool</td>
</tr>
</tbody>
</table><div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">a</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">^</span><span class="w"> </span><span class="n">c</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">d</span><span class="p">.</span><span class="n">set</span><span class="p">()</span><span class="w">     </span><span class="c1">//等价于d := True</span>
<span class="p">}</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="n">e</span><span class="p">.</span><span class="n">setWhen</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="c1">//等价于when(cond) { d := True }</span>

<span class="kd">val</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegInit</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"> </span><span class="n">fallWhen</span><span class="p">(</span><span class="n">ack</span><span class="p">)</span><span class="w"> </span><span class="n">setWhen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="w"></span>
<span class="cm">/*</span>
<span class="cm">*等价于</span>
<span class="cm">*when(f &amp;&amp; ack) { f := False}</span>
<span class="cm">*when(req) {f := True}</span>
<span class="cm">*or</span>
<span class="cm">*f := req || (f &amp;&amp; !ack)</span>
<span class="cm">*/</span><span class="w"></span>

<span class="c1">//注意赋值顺序!</span>
<span class="kd">val</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegInit</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"> </span><span class="n">setWhen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="w"> </span><span class="n">fallWhen</span><span class="p">(</span><span class="n">ack</span><span class="p">)</span><span class="w"></span>
<span class="c1">//等价于 g := ((!g) &amp;&amp; req) || (g &amp;&amp; !ack)</span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">c</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="o">!</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_cond0</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">e</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">f</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_MyTopLevel_l47</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ack</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">f</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">when_MyTopLevel_l47</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">f</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">f</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">g</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_MyTopLevel_l49</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ack</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">g</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">g</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">when_MyTopLevel_l49</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">g</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>
</pre></div>
</div>
<ol class="simple">
<li><p>边沿检测(Edge detection)</p></li>
</ol>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">x.edge[()]</td>
<td style="text-align: center;">当x发生跳变返回True</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">x.edge(initAt: Bool)</td>
<td style="text-align: center;">与x.edge相同但多了复位值, 对reg_next复位</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">x.rise[()]</td>
<td style="text-align: center;">当x在上一周期低电平下一周期高电平返回True</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">x.rise(initAt: Bool)</td>
<td style="text-align: center;">与x.rise相同但多了复位值, 对reg_next复位</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">x.fall[()]</td>
<td style="text-align: center;">当x在上一周期高电平下一周期低电平返回False</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">x.edges[()]</td>
<td style="text-align: center;">返回包(rise, fall ,toggle)</td>
<td style="text-align: center;">BoolEdges</td>
</tr>
<tr>
<td style="text-align: center;">x.edges(initAt:Bool)</td>
<td style="text-align: center;">与x.edges相同但多了复位值, 对reg_next复位</td>
<td style="text-align: center;">BoolEdges</td>
</tr>
</tbody>
</table><div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">when</span><span class="p">(</span><span class="n">myBool_1</span><span class="p">.</span><span class="n">rise</span><span class="p">(</span><span class="nc">False</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//当检测到上升沿时做点什么</span>
<span class="p">}</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">edgeBundle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myBool_2</span><span class="p">.</span><span class="n">edges</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">edgeBundle</span><span class="p">.</span><span class="n">rise</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//当检测到上升沿时做点什么</span>
<span class="p">}</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">edgeBundle</span><span class="p">.</span><span class="n">fall</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//当检测到下降沿时做点什么</span>
<span class="p">}</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">edgeBundle</span><span class="p">.</span><span class="n">toggle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//当检测到边沿时做点什么</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ol class="simple">
<li><p>比较操作(Comparison)</p></li>
</ol>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">x === y</td>
<td style="text-align: center;">相等</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">x =/= y</td>
<td style="text-align: center;">不相等</td>
<td style="text-align: center;">Bool</td>
</tr>
</tbody>
</table><div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">when</span><span class="p">(</span><span class="n">myBool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//等价于when(myBool === True)</span>
<span class="p">}</span><span class="w"></span>
<span class="w">    </span>
<span class="n">when</span><span class="p">(</span><span class="o">!</span><span class="n">myBool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//等价于when(myBool === False)</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ol class="simple">
<li><p>类型转换(Type cast)</p></li>
</ol>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">x.asBits</td>
<td style="text-align: center;">二进制转换为Bits</td>
<td style="text-align: center;">Bits(w(x) bits)</td>
</tr>
<tr>
<td style="text-align: center;">x.asUInt</td>
<td style="text-align: center;">二进制转换为UInt</td>
<td style="text-align: center;">UInt(w(x) bits)</td>
</tr>
<tr>
<td style="text-align: center;">x.asSInt</td>
<td style="text-align: center;">二进制转换为SInt</td>
<td style="text-align: center;">SInt(w(x) bits)</td>
</tr>
<tr>
<td style="text-align: center;">x.asUInt(bitCount)</td>
<td style="text-align: center;">二进制转换为UInt并改变大小</td>
<td style="text-align: center;">UInt(bitCount bits)</td>
</tr>
<tr>
<td style="text-align: center;">x.asBits(bitCount)</td>
<td style="text-align: center;">二进制转换为Bits并改变大小</td>
<td style="text-align: center;">Bits(bitCount bits)</td>
</tr>
</tbody>
</table><div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//给SInt值进位</span>
<span class="kd">val</span><span class="w"> </span><span class="n">carry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mySInt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">carry</span><span class="p">.</span><span class="n">asSInt</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">mySInt</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_res_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">carry</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mh">7</span><span class="p">{</span><span class="n">_zz_res_1</span><span class="p">[</span><span class="mh">0</span><span class="p">]}},</span><span class="w"> </span><span class="n">_zz_res_1</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">$signed</span><span class="p">(</span><span class="n">mySInt</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">$signed</span><span class="p">(</span><span class="n">_zz_res</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<ol class="simple">
<li><p>Misc</p></li>
</ol>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">x ## y</td>
<td style="text-align: center;">拼接, x-&gt;高位, y-&gt;低位</td>
<td style="text-align: center;">Bits(w(x)+w(y) bits)</td>
</tr>
</tbody>
</table><div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>

<span class="c1">//把三个Bool拼接成Bits</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myBits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">##</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">##</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myBits</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myBits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">},</span><span class="n">c</span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="bits">
<h2>Bits<a class="headerlink" href="#bits" title="Permalink to this heading"></a></h2>
<section id="id7">
<h3>一、描述(Description)<a class="headerlink" href="#id7" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Bits</span></code>类型对应于没有算数意义的bits向量</p>
</section>
<section id="id8">
<h3>二、声明(Declaration)<a class="headerlink" href="#id8" title="Permalink to this heading"></a></h3>
<p>声明bit向量的语法如下所示：([]中为可填项)</p>
<p>|                        语法                         |                    描述                     | 返回类型 |
| :————————————————-: | :—————————————–: | :——: |
|                      Bits[()]                       | 创建一个BitVector, bits个数由编译器推断得到 |   Bits   |
|                    Bits(x bits)                     |          创建一个x bits的BitVector          |   Bits   |
| B(value: Int[,x bits])<br>B(value: BigInt[,x bits]) |      创建一个赋初值的x bits的BitVector      |   Bits   |
|                B”[[size’]base]value”                |    创建一个基h/d/o/b的赋初值的BitVector     |   Bits   |
|              B([x bits,] element, …)              |      创建一个由给定元素赋值的BitVector      |   Bits   |</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//Declaration</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myBits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">myBits1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">myBits2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">B</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">myBits3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">B</span><span class="s">&quot;8&#39;xFF&quot;</span><span class="w">  </span><span class="c1">//基可以是x/h(16), d(10), o(8), b(2)</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myBits4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">B</span><span class="s">&quot;1001_0011&quot;</span><span class="w">  </span><span class="c1">//_增加可读性</span>

<span class="c1">//Element</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myBits5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">B</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">True</span><span class="p">)</span><span class="w"> </span><span class="c1">//&quot;11111111&quot;</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myBits6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">B</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="n">downto</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">B</span><span class="s">&quot;101&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">True</span><span class="p">,</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="c1">//&quot;10111000&quot;</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myBits7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="n">myBits7</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w">    </span><span class="c1">//&quot;10000000&quot;,在赋值的时候可以省去B</span>
</pre></div>
</div>
<p>Verilog</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myBits</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">myBits1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myBits2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myBits3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myBits4</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myBits5</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myBits6</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myBits7</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myBits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h19</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myBits2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h19</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myBits3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;hff</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myBits4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h93</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myBits5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;hff</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">function</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">zz_myBits6</span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="n">dummy</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">zz_myBits6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">zz_myBits6</span><span class="p">[</span><span class="mh">7</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b101</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">zz_myBits6</span><span class="p">[</span><span class="mh">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">zz_myBits6</span><span class="p">[</span><span class="mh">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">endfunction</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zz_myBits6</span><span class="p">(</span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">myBits6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_1</span><span class="p">;</span><span class="w"></span>


<span class="w">  </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">_zz_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">function</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">zz_myBits7</span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="n">dummy</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">zz_myBits7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">zz_myBits7</span><span class="p">[</span><span class="mh">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">endfunction</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">_zz_2</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zz_myBits7</span><span class="p">(</span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">myBits7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_2</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id9">
<h3>三、操作符(Operators)<a class="headerlink" href="#id9" title="Permalink to this heading"></a></h3>
<ol>
<li><p>逻辑运算(Logic)</p>
<p>以下是<code class="docutils literal notranslate"><span class="pre">Bits</span></code>类型的可用操作符</p>
</li>
</ol>
<pre><code>|           操作符           |           描述            |        返回类型        |
| :------------------------: | :-----------------------: | :--------------------: |
|             ~x             |         按位取非          |    Bits(w(x) bits)     |
|           x &amp; y            |          按位与           |    Bits(w(xy) bits)    |
|         x &amp;#124; y         |          按位或           |    Bits(w(xy) bits)    |
|           x ^ y            |         按位异或          |    Bits(w(xy) bits)    |
|           x.xorR           |     x的所有bits取异或     |          Bool          |
|           x.orR            |      x的所有bits取或      |          Bool          |
|           x.andR           |      x的所有bits取与      |          Bool          |
|           x &gt;&gt; y           |     逻辑右移, y: Int      |   Bits(w(x)-y bits)    |
|           x &gt;&gt; y           |     逻辑右移, y: UInt     |    Bits(w(x) bits)     |
|           x &lt;&lt; y           |     逻辑左移, y: Int      |   Bits(w(x)+y bits)    |
|           x &lt;&lt; y           |     逻辑左移, y: UInt     | Bits(w(x)+max(y) bits) |
|             x              |           &gt;&gt; y            | 逻辑右移, y: Int/UInt  | Bits(w(x) bits) |
|             x              |           &lt;&lt; y            | 逻辑左移, y: Int/UInt  | Bits(w(x) bits) |
|      x.rotateLeft(y)       | 逻辑循环左移, y: UInt/Int |    Bits(w(x) bits)     |
|      x.rotateRight(y)      | 逻辑循环右移, y: UInt/Int |    Bits(w(x) bits)     |
|       x.clearAll[()]       |       清除所有bits        |                        |
|        x.setAll[()]        |       置位所有bits        |                        |
| x.setAllTo(value: Boolean) |   根据给定Boolean值置位   |                        |
|  x.setAllTo(value: Bool)   |    根据给定Bool值置位     |                        |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&gt; 以上移位虽说是逻辑移位, 但生成的Verilog中是算术移位, 用`&gt;&gt;&gt;`或`&lt;&lt;&lt;`

```Scala
//Bit级操作符
val a, b, c = Bits(32 bits)
c := ~(a &amp; b)

val all_1 = a.andR  //检查a是不是全1

//逻辑移位
val bits_10bits = bits_8bits &lt;&lt; 2   //结果是10bits
val shift_8bits = bits_8bits |&lt;&lt; 2  //结果所8bits

//循环移位
val myBits = bits_8bits.rotateLeft(3)

//置位/清零
val a = B&quot;8&#39;x42&quot;
when(cond) {
    a.setAll()
}
```

```Verilog
wire                cond;
wire       [7:0]    bits_8bits;
wire       [31:0]   a;
wire       [31:0]   b;
wire       [31:0]   c;
wire                all_1;
wire       [9:0]    bits_10bits;
wire       [7:0]    shift_8bits;
wire       [7:0]    myBits;
reg        [7:0]    aa;

assign bits_8bits = 8&#39;h0a;
assign c = (~ (a &amp; b));
assign all_1 = (&amp;a);
assign bits_10bits = ({2&#39;d0,bits_8bits} &lt;&lt;&lt; 2);
assign shift_8bits = (bits_8bits &lt;&lt;&lt; 2);
assign myBits = {bits_8bits[4 : 0],bits_8bits[7 : 5]};
always @(*) begin
  aa = 8&#39;h42;
  if(cond) begin
    aa = 8&#39;hff;
  end
end
```
</pre></div>
</div>
<ol class="simple">
<li><p>比较运算(Comparison)</p></li>
</ol>
<pre><code>| 操作符  |  描述  | 返回类型 |
| :-----: | :----: | :------: |
| x === y |  相等  |   Bool   |
| x =/= y | 不相等 |   Bool   |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
when(myBits === 3) {
    ...
}

when(myBits_32 =/= B&quot;32&#39;x44332211&quot;) {
    ...
}
```
</pre></div>
</div>
<ol class="simple">
<li><p>类型转换(Type cast)</p></li>
</ol>
<pre><code>|  操作符   |       描述       |    返回类型     |
| :-------: | :--------------: | :-------------: |
| x.asBits  | 二进制转换为Bits | Bits(w(x) bits) |
| x.asUInt  | 二进制转换为UInt | UInt(w(x) bits) |
| x.asSInt  | 二进制转换为SInt | SInt(w(x) bits) |
| x.asBools | 转换成Bools数组  | Vec(Bool, w(x)) |
|  B(x: T)  |  数据转换为Bits  | Bits(w(x) bits) |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>为了把`Bool`, `UInt`或`SInt`转换成`Bits`, 也可以用`B(something)`：

```Scala
//把Bits转换成SInt
val mySInt = myBits.asSInt

//创建Bool向量
val myVec = myBits.asBools

//把SInt转换成Bits
val myBits = B(mySInt)
```

Verilog:

```Verilog
reg        [7:0]    myBits;
wire       [7:0]    mySInt;
wire                myVec_0;
wire                myVec_1;
wire                myVec_2;
wire                myVec_3;
wire                myVec_4;
wire                myVec_5;
wire                myVec_6;
wire                myVec_7;

assign mySInt = myBits;

assign myVec_0 = myBits[0];
assign myVec_1 = myBits[1];
assign myVec_2 = myBits[2];
assign myVec_3 = myBits[3];
assign myVec_4 = myBits[4];
assign myVec_5 = myBits[5];
assign myVec_6 = myBits[6];
assign myVec_7 = myBits[7];
```
</pre></div>
</div>
<ol class="simple">
<li><p>Bit位提取(Bit extraction)</p></li>
</ol>
<pre><code>|           操作符           |                        描述                        |     返回类型     |
| :------------------------: | :------------------------------------------------: | :--------------: |
|            x(y)            |              读对应bit位, y: Int/UInt              |       Bool       |
|   x(offset, width bits)    |        读一块bits, offset: UInt, width: Int        | Bit(width bits)  |
|          x(range)          |       读范围内的bit, 例如myBits(4 down to 2)       | Bits(range bits) |
|         x(y) := z          |             赋值对应bits, y: Int/UInt              | Bits(width bits) |
| x(offset, width bits) := z |       赋值一块bits, offset: UInt, width: Int       | Bits(width bits) |
|       x(range) := z        | 赋值范围内的bit, 例如myBits(4 down to 2) := B"010" | Bits(range bits) |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
//取第4bit元素
val myBool = myBits(4)

//赋值
myBits(1) := True

//范围内操作
val myBits_8bits = myBits_16bits(7 downto 0)
val myBits_7bits = myBits_16bits(0 to 6)
val myBits_6bits = myBits_16bits(0 until 6)

myBits_8bits(3 downto 0) := myBits_4bits
```

Verilog:

```Verilog
reg        [7:0]    myBits;
wire                myBool;
reg        [15:0]   myBits_16bits;
wire       [3:0]    myBits_4bits;
wire       [7:0]    myBits_8bits;
wire       [6:0]    myBits_7bits;
wire       [5:0]    myBits_6bits;

assign myBool = myBits[4];
always @(*) begin
    myBits_16bits = {8&#39;d0, myBits};
    myBits_16bits[3 : 0] = myBits_4bits;
end

assign myBits_4bits = myBits[3:0];
assign myBits_8bits = myBits_16bits[7 : 0];
assign myBits_7bits = myBits_16bits[6 : 0];
assign myBits_6bits = myBits_16bits[5 : 0];

always @(posedge clk or posedge reset) begin
    if(reset) begin
    myBits &lt;= 8&#39;h0;
    end else begin
    myBits[1] &lt;= 1&#39;b1;
    end
end

```
</pre></div>
</div>
<ol class="simple">
<li><p>Misc</p></li>
</ol>
<pre><code>|         操作符          |                      描述                       |       返回类型       |
| :---------------------: | :---------------------------------------------: | :------------------: |
|       x.getWidth        |                   返回bit位数                   |         Int          |
|         x.range         |       返回一个范围, 从大到小(x.high : 0)        |        Range         |
|         x.high          |                 返回x的最高边界                 |         Int          |
|          x.msb          |               返回最高有效位的值                |         Bool         |
|          x.lsb          |               返回最低有效位的值                |         Bool         |
|         x ## y          |           拼接操作, x-&gt;高位, y-&gt;低位            | Bits(w(x)+w(y) bits) |
| x.subdivideIn(y slices) |             把x分成y个切片, y: Int              |     Vec(Bits, y)     |
|  x.subdivideIn(y bits)  |             把x按y bits切片, y: Int             |  Vec(Bits, w(x)/y)   |
|       x,resize(y)       | 返回x的变换大小后的复制, 如果变长则补零, y: Int |     Bits(y bits)     |
|        x.resized        |         返回一个根据需要自动变换长度的x         |   Bits(w(x) bits)    |
|     x.resizeLeft(x)     |        保持MSB在同一位置进行放缩, x: Int        |     Bits(x bits)     |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
println(myBits_32bits.getWidth) //32

myBool := myBits.lsb    //相当于myBits(0)

//拼接
myBits_24bits := bits_8bits_1 ## bits_8bits_2 ## bits_8bits_3

//拆分
val sel = UInt(2 bits)
val myBitsWord = myBits_128bits.subdivideIn(32 bits)(sel)
//sel = 0 =&gt; myBitsWord = myBits_128bits(127 downto 96)
//sel = 1 =&gt; myBitsWord = myBits_128bits(95 downto 64)
//sel = 2 =&gt; myBitsWord = myBits_128bits(63 downto 32)
//sel = 3 =&gt; myBitsWord = myBits_128bits(31 downto 0)

//如果你想反向访问数据
val myVector = myBits_128bits.subdivideIn(32 bits).reverse
val myBitsWord = myVector(sel) 

//长度变换
myBits_32bits := B&quot;32&#39;x11223344&quot;
myBits_8bits := myBits_32bits.resized  //自动确定长度(myBits_8bits=0x44)
myBits_8bits := myBits_32bits.resize(8) //长度变换为(myBits_8bits=0x44)
myBits_8bits := myBits_32bits.resizeLeft(8) //从高位变换(myBits_8bits=0x11)
```

Verilog:

```Verilog
reg        [31:0]   _zz_myBitsWord;
reg        [31:0]   myBits_32bits;
wire                myBool;
reg        [7:0]    bits_8bits_1;
reg        [7:0]    bits_8bits_2;
reg        [7:0]    bits_8bits_3;
wire       [7:0]    myBits_8bits;
wire       [7:0]    myBits;
wire       [23:0]   myBits_24bits;
wire       [127:0]  myBits_128bits;
wire       [31:0]   myBitsWord;
wire       [1:0]    sel;

always @(*) begin
    case(sel)
        2&#39;b00 : _zz_myBitsWord = myBits_128bits[31 : 0];
        2&#39;b01 : _zz_myBitsWord = myBits_128bits[63 : 32];
        2&#39;b10 : _zz_myBitsWord = myBits_128bits[95 : 64];
    default : _zz_myBitsWord = myBits_128bits[127 : 96];
    endcase
end

//反向访问结果, myVector变量被优化掉了, 综合结果并不体现

always @(*) begin
    case(sel)
        2&#39;b00 : _zz_myBitsWord = myBits_128bits[127 : 96];
        2&#39;b01 : _zz_myBitsWord = myBits_128bits[95 : 64];
        2&#39;b10 : _zz_myBitsWord = myBits_128bits[63 : 32];
        default : _zz_myBitsWord = myBits_128bits[31 : 0];
    endcase
end

assign myBool = myBits[0];
assign myBits_24bits = {{bits_8bits_1,bits_8bits_2},bits_8bits_3};
assign myBitsWord = _zz_myBitsWord;

always @(posedge clk or posedge reset) begin
    if(reset) begin
        myBits_32bits &lt;= 32&#39;h0;
    end else begin
        myBits_32bits &lt;= 32&#39;h11223344;
    end
end

assign myBits_8bits = myBits_32bits[7:0];
//高位变换
assign myBits_8bits = myBits_32bits[31 : 24];

```
</pre></div>
</div>
<ol>
<li><p>bit位遮罩(MaskedLiteral)</p>
<p>不关心的值用-遮罩</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">myBits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">B</span><span class="s">&quot;1101&quot;</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">test1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myBits</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">M</span><span class="s">&quot;1-01&quot;</span><span class="w">  </span><span class="c1">//True</span>
<span class="kd">val</span><span class="w"> </span><span class="n">test2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myBits</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">M</span><span class="s">&quot;0---&quot;</span><span class="w">  </span><span class="c1">//False</span>
<span class="kd">val</span><span class="w"> </span><span class="n">test3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myBits</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">M</span><span class="s">&quot;1--1&quot;</span><span class="w">  </span><span class="c1">//True</span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myBits</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">test1</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">test2</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">                </span><span class="n">test3</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">myBits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b1101</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">test1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">myBits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b1011</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b1001</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">test2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">myBits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b1000</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">test3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">myBits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b1001</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b1001</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="uint-sint">
<h2>UInt/SInt<a class="headerlink" href="#uint-sint" title="Permalink to this heading"></a></h2>
<section id="id10">
<h3>一、描述(Description)<a class="headerlink" href="#id10" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">UInt</span></code>/<code class="docutils literal notranslate"><span class="pre">SInt</span></code>数据类型是一个能用在有/无符号计算中的bits向量</p>
</section>
<section id="id11">
<h3>二、声明(Declaration)<a class="headerlink" href="#id11" title="Permalink to this heading"></a></h3>
<p>声明整型的语法如下所示：([]中的是可填项)</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">语法</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">UInt[()]<br>SInt[()]</td>
<td style="text-align: center;">创建有/无符号整型, bits个数编译器推断得到</td>
<td style="text-align: center;">UInt<br>SInt</td>
</tr>
<tr>
<td style="text-align: center;">UInt(x bits)<br>SInt(x bits)</td>
<td style="text-align: center;">创建x bits的有/无符号整型</td>
<td style="text-align: center;">UInt<br>SInt</td>
</tr>
<tr>
<td style="text-align: center;">U(value: Int[, xbits])<br>U(value: BigInt[, x bits])<br>S(value: Int[, x bits])<br>S(value: BigInt[, x bits])</td>
<td style="text-align: center;">创建有/无符号整型, 并赋值'value'</td>
<td style="text-align: center;">UInt<br>SInt</td>
</tr>
<tr>
<td style="text-align: center;">U"[[size']base]value"<br>S"[[size']base]value"</td>
<td style="text-align: center;">创建有/无符号整型, 并赋值'value'(基：h, d, o, b)</td>
<td style="text-align: center;">UInt<br>SInt</td>
</tr>
<tr>
<td style="text-align: center;">U([x bits, ] element, ...)<br>S([x bits, ] element, ...)</td>
<td style="text-align: center;">创建有/无符号整型, 赋值由element决定</td>
<td style="text-align: center;">UInt<br>SInt</td>
</tr>
</tbody>
</table><div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">U</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">U</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">U</span><span class="s">&quot;0000_0101&quot;</span><span class="w">  </span><span class="c1">//基默认二进制</span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">U</span><span class="s">&quot;h1A&quot;</span><span class="w">        </span><span class="c1">//x/h-&gt;基16, d-&gt;基10, o-&gt;基8, b-&gt;基2</span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">U</span><span class="s">&quot;8&#39;h1A&quot;</span><span class="w"></span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span><span class="w">             </span><span class="c1">//可以使用Scala Int作为字面值</span>

<span class="kd">val</span><span class="w"> </span><span class="n">myBool</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">U</span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">myBool</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">U</span><span class="p">(</span><span class="n">myUInt</span><span class="p">.</span><span class="n">range</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"></span>

<span class="c1">//在赋值的时候, 可以去掉U/S, 也支持[default -&gt; ???]</span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">default</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w">                 </span><span class="c1">//赋值“11111111”</span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">myUInt</span><span class="p">.</span><span class="n">range</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w">            </span><span class="c1">//赋值“11111111</span>

<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w">     </span><span class="c1">//赋值“10000000”</span>
<span class="n">myUInt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">((</span><span class="mi">4</span><span class="w"> </span><span class="n">downto</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w">  </span><span class="c1">//赋值“00011110”</span>
</pre></div>
</div>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myUInt</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_myBool</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">myBool</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">function</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">zz__zz_myBool</span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="n">dummy</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">zz__zz_myBool</span><span class="p">[</span><span class="mh">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">zz__zz_myBool</span><span class="p">[</span><span class="mh">6</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">7&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">endfunction</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">_zz_1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h02</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h02</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h05</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h1A</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h1A</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h02</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zz__zz_myBool</span><span class="p">(</span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">_zz_myBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">myUInt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">_zz_myBool</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_myBool</span><span class="p">[</span><span class="mh">7</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;hff</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">myUInt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">_zz_myBool</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;hff</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;hff</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h80</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h1E</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id12">
<h3>三、操作符(Operators)<a class="headerlink" href="#id12" title="Permalink to this heading"></a></h3>
<p>下面是<code class="docutils literal notranslate"><span class="pre">UInt</span></code>和<code class="docutils literal notranslate"><span class="pre">SInt</span></code>支持的操作符：</p>
<ol class="simple">
<li><p>逻辑运算(Logic)##这里有问题##</p></li>
</ol>
<pre><code>|           操作符           |           描述            |        返回类型         |
| :------------------------: | :-----------------------: | :---------------------: |
|           x ^ y            |         逻辑异或          |          Bool           |
|             ~x             |         按位取非          |      T(w(x) bits)       |
|           x &amp; y            |          按位与           | T(max(w(x), w(y)) bits) |
|         x &amp;#124; y         |          按位或           | T(max(w(x), w(y)) bits) |
|           x ^ y            |         按位异或          | T(max(w(x), w(y)) bits) |
|           x.xorR           |     x的所有bits取异或     |          Bool           |
|           x.orR            |      x的所有bits取或      |          Bool           |
|           x.andR           |      x的所有bits取与      |          Bool           |
|           x &gt;&gt; y           |     算术右移, y: Int      |     T(w(x)-y bits)      |
|           x &gt;&gt; y           |     算术右移, y: UInt     |      T(w(x) bits)       |
|           x &lt;&lt; y           |     算术左移, y: Int      |     T(w(x)+y bits)      |
|           x &lt;&lt; y           |     算术左移, y: UInt     |   T(w(x)+max(y) bits)   |
|             x              |           &gt;&gt; y            |  逻辑右移, y: Int/UInt  | T(w(x) bits) |
|             x              |           &lt;&lt; y            |  逻辑左移, y: Int/UInt  | T(w(x) bits) |
|      x.rotateLeft(y)       | 逻辑循环左移, y: UInt/Int |      T(w(x) bits)       |
|      x.rotateRight(y)      | 逻辑循环右移, y: UInt/Int |      T(w(x) bits)       |
|       x.clearAll[()]       |       清除所有bits        |                         |
|        x.setAll[()]        |       置位所有bits        |                         |
| x.setAllTo(value: Boolean) |   根据给定Boolean值置位   |                         |
|  x.setAllTo(value: Bool)   |    根据给定Bool值置位     |                         |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&gt; 备注：`x rotateLeft y`和`x rotateRight y`也是有效语句

&gt; 备注：注意`x &gt;&gt; 2`和`x &gt;&gt; U(2)`的区别, 前者返回类型是`T(w(x)-2)`, 后者返回类型是`T(w(x))`, 其次更重要的是, 前者的2视为Int后者的U(2)视为硬件信号。

```Scala
val a, b, c = SInt(32 bits)
a := S(5)
b := S(10)

//比特级操作
c := ~(a &amp; b)
assert(c.getWidth == 32)

//移位
val arithShift = UInt(8 bits) &lt;&lt; 2  //结果10 bits
val logicShift = UInt(8 bits) |&lt;&lt; 2 //结果8 bits
assert(arithShift.getWidth == 10)
assert(logicShift.getWidth == 8)

//循环移位
val rotated = UInt(8 bits) rotateLeft 3
assert(rotated.getWidth == 8)

//当a全1, b也全1
when(a.andR) { b.setAll() }
```

Verilog:

```Verilog
wire       [31:0]   _zz_c;
wire       [31:0]   a;
reg        [31:0]   b;
wire       [31:0]   c;
wire       [7:0]    _zz_arithShift;
wire       [9:0]    arithShift;
wire       [7:0]    _zz_logicShift;
wire       [7:0]    logicShift;
wire       [7:0]    _zz_rotated;
wire       [7:0]    rotated;
wire                when_MyTopLevel_l51;

assign _zz_c = (a &amp; b);
assign a = 32&#39;h00000005;
always @(*) begin
    b = 32&#39;h0000000a;
    if(when_MyTopLevel_l51) begin
        b = 32&#39;hffffffff;
    end
end

assign c = (~ _zz_c);
assign arithShift = ({2&#39;d0,_zz_arithShift} &lt;&lt;&lt; 2);
assign logicShift = (_zz_logicShift &lt;&lt;&lt; 2);
assign rotated = {_zz_rotated[4 : 0],_zz_rotated[7 : 5]};
assign when_MyTopLevel_l51 = (&amp;a);

```
</pre></div>
</div>
<ol class="simple">
<li><p>运算(Arithmetic)</p></li>
</ol>
<pre><code>|  操作符   |    描述    |         返回类型          |
| :-------: | :--------: | :-----------------------: |
|    x+y    |    加法    |  T(max(w(x), w(y)) bits)  |
|   x+^y    | 产生进位加 | T(max(w(x), w(y))+1 bits) |
| x+&amp;#124;y | 溢出判断加 |  T(max(w(x), w(y)) bits)  |
|    x-y    |    减法    |  T(max(w(x), w(y)) bits)  |
|   x-^y    | 产生借位减 | T(max(w(x), w(y))+1 bits) |
|    x-     |     y      |           减法            | T(max(w(x), w(y)) bits) |
|    x*y    |    乘法    |  T(max(w(x), w(y)) bits)  |
|    x/y    |    除法    |        T(w(x)bits)        |
|    x%y    |    取模    |        T(w(x)bits)        |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
val a, b, c = UInt(8 bits)
a := U&quot;xf0&quot;
b := U&quot;x0f&quot;

c := a + b
assert(c === U&quot;8&#39;xff&quot;)

val d = a +^ b
assert(d === U&quot;9&#39;x0ff&quot;)

val e = a +| U&quot;8&#39;x20&quot;
assert(e === U&quot;8&#39;xff&quot;)
```

Verilog:

```Verilog
wire       [7:0]    a;
wire       [7:0]    b;
wire       [7:0]    c;
wire       [8:0]    d;
wire       [8:0]    _zz_e;
reg        [7:0]    e;
wire                when_UInt_l119;
reg        [7:0]    counter;

assign a = 8&#39;hf0;
assign b = 8&#39;h0f;
assign c = (a + b);
assign d = ({1&#39;b0,a} + {1&#39;b0,b});
assign _zz_e = ({1&#39;b0,a} + {1&#39;b0,8&#39;h20});
assign when_UInt_l119 = (|_zz_e[8 : 8]);
always @(*) begin
    if(when_UInt_l119) begin
        e = 8&#39;hff;
    end else begin
        e = _zz_e[7 : 0];
    end
end

```

&gt; 备注：需要注意的是, 该例程的仿真assert用的是`===`, 而相对的上一例程中细化assert用的是`==`
</pre></div>
</div>
<ol class="simple">
<li><p>对比操作(Comparison)</p></li>
</ol>
<pre><code>| 操作符 |   描述   | 返回类型 |
| :----: | :------: | :------: |
| x===y  |   相等   |   Bool   |
|  x=/=  |  不相等  |   Bool   |
|  x&gt;y   |   大于   |   Bool   |
|  x&gt;=y  | 大于等于 |   Bool   |
|  x&lt;y   |   小于   |   Bool   |
|  x&lt;=y  | 小于等于 |   Bool   |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
val a = U(5, 8 bits)
val b = U(10, 8 bits)
val c = UInt(2 bits)

when (a &gt; b) {
    c := U&quot;10&quot;
} elsewhen (a =/= b) {
    c := U&quot;01&quot;
} elsewhen (a === U(0)) {
    c.setAll()
} otherwise {
    c.clearAll()
}
```

Verilog:

```Verilog
wire       [7:0]    a;
wire       [7:0]    b;
reg        [1:0]    c;
wire                when_MyTopLevel_l39;
wire                when_MyTopLevel_l41;
wire                when_MyTopLevel_l43;
reg        [7:0]    counter;

assign a = 8&#39;h05;
assign b = 8&#39;h0a;
assign when_MyTopLevel_l39 = (b &lt; a);
always @(*) begin
    if(when_MyTopLevel_l39) begin
        c = 2&#39;b10;
    end else begin
        if(when_MyTopLevel_l41) begin
            c = 2&#39;b01;
        end else begin
            if(when_MyTopLevel_l43) begin
                c = 2&#39;b11;
            end else begin
                c = 2&#39;b00;
            end
        end
    end
end

ssign when_MyTopLevel_l41 = (a != b);
assign when_MyTopLevel_l43 = (a == 8&#39;h0);
```
</pre></div>
</div>
<ol class="simple">
<li><p>类型转换(Type cast)</p></li>
</ol>
<pre><code>|   操作符   |         描述         |     返回类型      |
| :--------: | :------------------: | :---------------: |
|  x.asBits  |   二进制转换成Bits   |  Bits(w(x) bits)  |
|  x.asUInt  |   二进制转换成UInt   |  UInt(w(x) bits)  |
|  x.asSInt  |   二进制转换成SInt   |  SInt(w(x) bits)  |
| x.asBools  |    转换成Bool数组    |  Vec(Bool, w(x))  |
|   S(x:T)   |   把数据转换成SInt   |  SInt(w(x) bits)  |
|   U(x:T)   |   把数据转换成UInt   |  UInt(w(x) bits)  |
| x.intoSInt | 扩展符号位转换成SInt | SInt(w(x)+1 bits) |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>将`Bool`, `Bits`, `SInt`转化成`UInt`可以用`U(something)`, 将类型转化为SInt的时候可以用`S(something)`。

```Scala
//把SInt转换成Bits
val myBits = mySInt.asBits

//创建一个Bool量
val myVec = myUint.asBools

//把Bits转换成SInt
val mySInt = S(myBits)
```

Verilog:

```Verilog
wire       [7:0]    mySInt;
wire       [7:0]    myUInt;
wire       [7:0]    myBits;
wire                myVec_0;
wire                myVec_1;
wire                myVec_2;
wire                myVec_3;
wire                myVec_4;
wire                myVec_5;
wire                myVec_6;
wire                myVec_7;

assign myBits = mySInt;
assign myVec_0 = myUInt[0];
assign myVec_1 = myUInt[1];
assign myVec_2 = myUInt[2];
assign myVec_3 = myUInt[3];
assign myVec_4 = myUInt[4];
assign myVec_5 = myUInt[5];
assign myVec_6 = myUInt[6];
assign myVec_7 = myUInt[7];

assign mySInt = myBits;
```
</pre></div>
</div>
<ol class="simple">
<li><p>提取比特位(Bit extraction)</p></li>
</ol>
<pre><code>|       操作符        |                       描述                       |   返回类型    |
| :-----------------: | :----------------------------------------------: | :-----------: |
|        x(y)         |                  读第y bits的值                  |     Bool      |
|  x(offset, width)   |       读bit区域, offset: UInt, width: Int        | T(width bits) |
|      x(range)       |      读某范围内bits, 例如myBits(4 downto 2)      | T(range bits) |
|       x(y):=z       |              赋值某bit, y:Int/UInt               |     Bool      |
| x(offset, width):=z |       赋值bit区域, offset:UInt, width:Int        | T(width bits) |
|     x(range):=z     | 赋值某范围内bits, 例如myBits(4 downto 2):=U"010" | T(range bits) |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
//取第4bit数据
val myBool = myUInt(4)

//把第1bit赋值为True
mySInt(1) := True

//范围内赋值
val myUInt_8bits = myUInt_16bits(7 downto 0)
val myUInt_7bits = myUInt_16bits(0 to 6)
val myUInt_6bits = myUInt_16bits(0 until 6)

mySInt_8bits(3 downto 0) := mySInt_4bits
```

Verilog:

```Verilog
wire       [7:0]    myUInt;
reg        [7:0]    mySInt;
wire       [15:0]   myUInt_16bits;
reg        [7:0]    mySInt_8bits;
wire       [3:0]    mySInt_4bits;
wire                myBool;
wire       [7:0]    myUInt_8bits;
wire       [6:0]    myUInt_7bits;
wire       [5:0]    myUInt_6bits;

assign myUInt_16bits = {8&#39;d0, myUInt};
assign myBool = myUInt[4];
assign myUInt_8bits = myUInt_16bits[7 : 0];
assign myUInt_7bits = myUInt_16bits[6 : 0];
assign myUInt_6bits = myUInt_16bits[5 : 0];
always @(*) begin
    mySInt_8bits[3 : 0] = mySInt_4bits;
    mySInt_8bits[7 : 4] = 4&#39;b0000;
end

always @(posedge clk or posedge reset) begin
    if(reset) begin
        mySInt &lt;= 8&#39;h0;
    end else begin
        mySInt[1] &lt;= 1&#39;b1;
    end
end
```
</pre></div>
</div>
<ol class="simple">
<li><p>Misc</p></li>
</ol>
<pre><code>|            操作符             |                                  描述                                  |        返回类型        |
| :---------------------------: | :--------------------------------------------------------------------: | :--------------------: |
|          x.getWidth           |                              返回bit位数                               |          Int           |
|             x.msb             |                             返回最高有效位                             |          Bool          |
|             x.lsb             |                             返回最低有效位                             |          Bool          |
|            x.range            |                        返回区间范围(x.high到0)                         |         Range          |
|            x.high             |                              返回x的上限                               |          Int           |
|             x##y              |                       数据拼接, x-&gt;高位, y-&gt;低位                       |  Bits(w(x)+w(y) bits)  |
|             x@@y              |                    数据拼接, x:T, y:Bool/SInt/UInt                     |   T(w(x)+w(y) bits)    |
|    x.subdivideln(y slices)    |                          把x切片成y份, y:Int                           |        Vec(T,y)        |
|     x.subdivideln(y bits)     |                         把x按y bits切片, y:Int                         |     Vec(T,w(x)/y)      |
|          x.resize(y)          | 返回x的长度变换后的复制, UInt长度增大补零, SInt长度增大补符号位, y:Int |       T(y bits)        |
|           x.resized           |                        返回按需自动确定长度的x                         |      T(w(x) bits)      |
| myUInt.twoComplement(en:Bool) |                         用补码把UInt转换成SInt                         |   SInt(w(myUInt)+1)    |
|          mySInt.abs           |                          返回UInt类型的绝对值                          |  UInt(w(mySInt),bits)  |
|      mySInt.abs(en:Bool)      |                    如果en是True返回UInt类型的绝对值                    |  UInt(w(mySInt),bits)  |
|          mySInt.sign          |                             返回最高有效位                             |          Bool          |
|           x.expand            |                           返回1bit拓展后的x                            |     T(w(x)+1 bits)     |
|       mySInt.absWithSym       |                    返回对称收缩1 bit的UInt的绝对值                     | UInt(w(mySInt)-1 bits) |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
myBool := mySInt.lsb    //等价于mySInt(0)

//拼接
val mySInt = mySInt_1 @@ mySInt_1 @@ myBool
val myBits = mySInt_1 ## mySInt_1 ## myBool

//分块
val sel = UInt(2 bits)
val mySIntWord = mySInt_128bits.subdivideIn(32 bits)(sel)
//sel = 0 =&gt; mySIntWord = mySInt_128bits(128 downto 96)
//sel = 1 =&gt; mySIntWord = mySInt_128bits(95 downto 64)
//sel = 2 =&gt; mySIntWord = mySInt_128bits(63 downto 32)
//sel = 3 =&gt; mySIntWord = mySInt_128bits(31 downto 0)

//如果想要反向访问数据：
val myVector = mySInt_128bits.subdivideIn(32 bits).reverse
val mySIntWord = myVector(sel)

//变换大小
myUInt_32bits := U&quot;32&#39;x11223344&quot;
myUInt_8bits := myUInt_32bits.resized   //长度自动推断(myUInt_8bits=0x44)
myUInt_8bits := myUInt_32bits.resize(8) //变换为8 bits(myUInt_8bits=0x44)

//取补码
mySInt := myUInt.twoComplement(myBool)

//取绝对值
mySInt_abs := mySInt.abs
```

Verilog:

```Verilog
wire       [15:0]   _zz_mySInt;
reg        [31:0]   _zz_mySIntWord;
wire       [31:0]   _zz_mySIntWord_1;
wire       [31:0]   _zz_mySIntWord_2;
wire       [31:0]   _zz_mySIntWord_3;
wire       [31:0]   _zz_mySIntWord_4;
wire                myBool;
wire       [7:0]    mySInt_1;
wire       [127:0]  mySInt_128bits;
wire       [16:0]   mySInt;
wire       [16:0]   myBits;
wire       [1:0]    sel;
wire       [31:0]   mySIntWord;
wire       [31:0]   myUInt_32bits;
wire       [7:0]    myUInt_8bits;
wire       [7:0]    myUInt;
wire       [16:0]   mySInt_abs;

assign _zz_mySInt = {mySInt_1,mySInt_1};
assign _zz_mySIntWord_1 = mySInt_128bits[31 : 0];
assign _zz_mySIntWord_2 = mySInt_128bits[63 : 32];
assign _zz_mySIntWord_3 = mySInt_128bits[95 : 64];
assign _zz_mySIntWord_4 = mySInt_128bits[127 : 96];
always @(*) begin
    case(sel)
        2&#39;b00 : _zz_mySIntWord = _zz_mySIntWord_1;
        2&#39;b01 : _zz_mySIntWord = _zz_mySIntWord_2;
        2&#39;b10 : _zz_mySIntWord = _zz_mySIntWord_3;
        default : _zz_mySIntWord = _zz_mySIntWord_4;
    endcase
end

assign myBool = mySInt[0];
assign mySInt = {_zz_mySInt,myBool};
assign myBits = {{mySInt_1,mySInt_1},myBool};
assign mySIntWord = _zz_mySIntWord;
assign myUInt_32bits = 32&#39;h11223344;
assign myUInt_8bits = myUInt_32bits[7:0];
assign myUInt = 8&#39;h28;
assign mySInt_abs = 17&#39;h0;

assign _zz_mySInt = ({myBool,(myBool ? (~ myUInt) : myUInt)} + _zz_mySInt_1);
assign _zz_mySInt_2 = myBool;
assign _zz_mySInt_1 = {8&#39;d0, _zz_mySInt_2};

assign _zz_mySInt_abs = (mySInt[8] ? _zz_mySInt_abs_1 : mySInt);
assign _zz_mySInt_abs_1 = (~ mySInt);
assign _zz_mySInt_abs_3 = mySInt[8];
assign _zz_mySInt_abs_2 = {8&#39;d0, _zz_mySInt_abs_3};

assign mySInt_abs = (_zz_mySInt_abs + _zz_mySInt_abs_2);
```
</pre></div>
</div>
</section>
<section id="fixpoint-operations">
<h3>四、定点数操作(FixPoint operations)<a class="headerlink" href="#fixpoint-operations" title="Permalink to this heading"></a></h3>
<p>对于定点数, 我们可以把它分成两个部分：</p>
<ul class="simple">
<li><p>低位操作(四舍五入)</p></li>
<li><p>高位操作(饱和运算)</p></li>
</ul>
<ol>
<li><p>低位操作(Lower bit operations)</p>
<p><img alt="lowerBitOperation" src="_images/lowerBitOperation.png" /></p>
</li>
</ol>
<pre><code>| SpinalHDL舍入类型 | Wikipedia舍入类型 |     API     |        数学算法        | 返回(align=false) | 支持程度 |
| :---------------: | :---------------: | :---------: | :--------------------: | :---------------: | :------: |
|       FLOOR       |     RoundDown     |    floor    |        floor(x)        |    w(x)-n bits    |   Yes    |
|    FLOORTOZERO    |    RoundToZero    | floorToZero |   sign*floor(abs(x))   |    w(x)-n bits    |   Yes    |
|       CEIL        |      RoundUp      |    ceil     |        ceil(x)         |   w(x)-n+1 bits   |   Yes    |
|     CEILTOINF     |    RoundToInf     |  ceilToInf  |   sign*ceil(abs(x))    |   w(x)-n+1 bits   |   Yes    |
|      ROUNDUP      |    RoundHalfUp    |   roundUp   |      floor(x+0.5)      |   w(x)-n+1 bits   |   Yes    |
|     ROUNDDOWN     |   RoundHalfDown   |  roundDown  |      ceil(x-0.5)       |   w(x)-n+1 bits   |   Yes    |
|    ROUNDTOZERO    |  RoundHalfToZero  | roundToZero | sign*ceil(abs(x)-0.5)  |   w(x)-n+1 bits   |   Yes    |
|    ROUNDTOINF     |  RoundHalfToInf   | roundToInf  | sign*floor(abs(x)+0.5) |   w(x)-n+1 bits   |   Yes    |
|    ROUNDTOEVEN    |  RoundHalfToEven  | roundToEven |                        |                   |          |
|    ROUNDTOODD     |  RoundHalfToOdd   | roundToOdd  |                        |                   |          |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&gt; 备注：RoundToEven和RoundToOdd模式都非常特殊, 常用在高精度大数据统计领域, SpinalHDL还没有支持它们。

你会发现ROUNDUP, ROUNDDOWN, ROUNDTOZERO, ROUNDTOINF, ROUNDTOEVEN, ROUNDTOODD在行为上非常相似, ROUNDTOINF所最常见的, 不同编程语言中的四舍五入方法可能不同。

|  编程语言  | 默认四舍五入类型 |                             举例                             |        评估         |
| :--------: | :--------------: | :----------------------------------------------------------: | :-----------------: |  |
|   Matlab   |    ROUNDTOINF    | round(1.5)=2, round(2.5)=3&lt;br&gt;round(-1.5)=-2, round(-2.5)=-3 | round to +-Infinity |
|  python2   |    ROUNDTOINF    | round(1.5)=2, round(2.5)=3&lt;br&gt;round(-1.5)=-2, round(-2.5)=-3 | round to +-Infinity |
|  python3   |   ROUNDTOEVEN    |    round(1.5)=round(2.5)=2&lt;br&gt;round(-1.5)=round(-2.5)=-2     |    close to Even    |
| Scala.math |    ROUNDTOUP     | round(1.5)=2, round(2.5)=3&lt;br&gt;round(-1.5)=-1, round(-2.5)=-2 | always to +Infinity |
| SpinalHDL  |    ROUNDTOINF    | round(1.5)=2, round(2.5)=3&lt;br&gt;round(-1.5)=-2, round(-2.5)=-3 | round to +-Infinity |

&gt; 备注：在SpinalHDL中ROUNDTOINF默认是RoundType(`round = roundToInf`)

```Scala
val A = SInt(16 bits)
val B = A.roundToInf(6)    //默认&#39;align=false&#39;, 会得到11 bits
val B = A.roundToInf(6, align = true)  //舍去进位, 得到10 bits
val B = A.floor(6 bits)         //返回10 bits
val B = A.floorToZero(6 bits)   //返回10 bits
val B = A.ceil(6 bits)          //带进位故返回11 bits
val B = A.ceil(6 bits, align = true)    //舍去进位, 得到10 bits
val B = A.ceilToInf(6 bits)
val B = A.roundUp(6 bits)
val B = A.roundDown(6 bits)
val B = A.roundToInf(6 bits)
val B = A.roundToZero(6 bits)
val B = A.round(6 bits)         //SpinalHDL用roundToInf作为默认rounding模式

val B0 = A.roundToInf(6 bits, align = true) //---+
                                            //--&gt; equal
val B1 = A.roundToInf(6 bits, align = false).sat(1) //---+
```

Verilog:

```Verilog
//这里只举一个例子，其他的可自行生成
//val B = A.roundToInf(6, align = true)     当前版本默认align = true，与文档有所不同    有符号数两边近似
wire       [16:0]   _zz__zz_when_SInt_l337_2;
wire       [16:0]   _zz__zz_when_SInt_l337_2_1;
wire       [5:0]    _zz_when_SInt_l191;
wire       [10:0]   _zz__zz_B_3;
wire       [10:0]   _zz__zz_B_3_1;
wire       [16:0]   _zz__zz_B;
wire       [16:0]   _zz__zz_B_1;
wire       [16:0]   _zz__zz_B_2;
wire       [1:0]    _zz_when_SInt_l131;
wire       [0:0]    _zz_when_SInt_l137;
wire       [15:0]   A;
reg        [10:0]   _zz_B;
wire       [15:0]   _zz_B_1;
wire       [15:0]   _zz_when_SInt_l337;
wire       [15:0]   _zz_when_SInt_l337_1;
wire       [16:0]   _zz_when_SInt_l337_2;
wire       [15:0]   _zz_B_2;
wire                when_SInt_l337;
reg        [10:0]   _zz_B_3;
wire                when_SInt_l191;
reg        [9:0]    B;
wire                when_SInt_l130;
wire                when_SInt_l131;
wire                when_SInt_l137;
reg        [7:0]    counter;

assign _zz__zz_when_SInt_l337_2 = {_zz_when_SInt_l337_1[15],_zz_when_SInt_l337_1};  //A符号位拓展1bit
assign _zz__zz_when_SInt_l337_2_1 = {_zz_when_SInt_l337[15],_zz_when_SInt_l337};    //前6bit为0，其余为1的符号位拓展, 即-2^5
assign _zz_when_SInt_l191 = _zz_when_SInt_l337_2[5 : 0];                            //A-0.5的小数部分
assign _zz__zz_B_3 = _zz_when_SInt_l337_2[16 : 6];                                  //A-0.5的整数部分
assign _zz__zz_B_3_1 = 11&#39;h001;                                                     //1
assign _zz__zz_B = ($signed(_zz__zz_B_1) + $signed(_zz__zz_B_2));                   //符号位拓展后的A+2^5, 相当于A+0.5
assign _zz__zz_B_1 = {_zz_B_2[15],_zz_B_2};                                         //A符号位拓展1bit
assign _zz__zz_B_2 = {_zz_B_1[15],_zz_B_1};                                         //2^5符号位拓展1bit
assign _zz_when_SInt_l131 = _zz_B[10 : 9];                                          //溢出判断位
assign _zz_when_SInt_l137 = _zz_B[9 : 9];                                           //符号位
assign _zz_B_1 = {{10&#39;h0,1&#39;b1},5&#39;h0};                                               //16‘b0000_0000_0010_0000, 即2^5
assign _zz_when_SInt_l337 = {11&#39;h7ff,5&#39;h0};                                         //前5bit为0，其余为1. 即-2^5
assign _zz_when_SInt_l337_1 = A[15 : 0];
assign _zz_when_SInt_l337_2 = ($signed(_zz__zz_when_SInt_l337_2) + $signed(_zz__zz_when_SInt_l337_2_1));    //符号位拓展后的A-2^5, 相当于A-0.5
assign _zz_B_2 = A[15 : 0];                                                         //A
assign when_SInt_l337 = _zz_when_SInt_l337_2[16];                                   //A-0.5符号位
assign when_SInt_l191 = (|_zz_when_SInt_l191);                                      //A-0.5小数部分是否为0
always @(*) begin
    if(when_SInt_l191) begin
        _zz_B_3 = ($signed(_zz__zz_B_3) + $signed(_zz__zz_B_3_1));                  //非0的话A-0.5的整数部分+1
    end else begin
        _zz_B_3 = _zz_when_SInt_l337_2[16 : 6];                                     //0的话结果为 A-0.5 整数部分
    end
end

always @(*) begin
    if(when_SInt_l337) begin                                                        //负数时取
        _zz_B = _zz_B_3;
    end else begin
        _zz_B = (_zz__zz_B &gt;&gt;&gt; 6);                                                  //非负时A+0.5整数部分
    end
end

assign when_SInt_l130 = _zz_B[10];
assign when_SInt_l131 = (! (&amp;_zz_when_SInt_l131));
always @(*) begin
    if(when_SInt_l130) begin
        if(when_SInt_l131) begin
            B = 10&#39;h200;
        end else begin
            B = _zz_B[9 : 0];
        end
    end else begin
        if(when_SInt_l137) begin
            B = 10&#39;h1ff;
        end else begin
            B = _zz_B[9 : 0];
        end
    end
end

assign when_SInt_l137 = (|_zz_when_SInt_l137);
```

&gt; 备注：只有`floor`和`floorToZero`没有`align`选项, 它们不需要进位bit(align=true)。其他近似算法都默认带进位信息。
</pre></div>
</div>
<pre><code>|     API     | UInt/SInt |            描述             | Return(align=false) | Return(align=true) |
| :---------: | :-------: | :-------------------------: | :-----------------: | :----------------: |
|    floor    |   Both    |                             |     w(x)-n bits     |    w(x)-n bits     |
| floorToZero |   SInt    |      与无符号floor相等      |     w(x)-n bits     |    w(x)-n bits     |
|    ceil     |   Both    |                             |    w(x)-n+1 bits    |    w(x)-n bits     |
|  ceilToInf  |   SInt    |      与无符号ceil相等       |    w(x)-n+1 bits    |    w(x)-n bits     |
|   roundUp   |   Both    |          仅为了HW           |    w(x)-n+1 bits    |    w(x)-n bits     |
|  roundDown  |   Both    |                             |    w(x)-n+1 bits    |    w(x)-n bits     |
| roundToInf  |   SInt    |           最常用            |    w(x)-n+1 bits    |    w(x)-n bits     |
| roundToZero |   SInt    |    无符号时等于roundDown    |    w(x)-n+1 bits    |    w(x)-n bits     |
|    round    |   Both    | 在SpinalHDL中默认roundToInf |    w(x)-n+1 bits    |    w(x)-n bits     |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&gt; 备注：尽管`roundToInf`很常用, `roundUp`有着最小的开销和最好的时序, 并且几乎没有性能损失。因此强烈推荐使用`roundUp`
</pre></div>
</div>
<ol>
<li><p>高位操作(High bit operations)</p>
<p><img alt="highBitOperation" src="_images/highBitOperation.png" /></p>
</li>
</ol>
<pre><code>|   函数   | 操作  |              正数操作               |               负数操作               |
| :------: | :---: | :---------------------------------: | :----------------------------------: |
|   sat    | 饱和  | when(Top[w-1, w-n].orR)set maxValue | when(Top[w-1, w-n].andR)set minValue |
|   trim   | 舍弃  |                 N/A                 |                 N/A                  |
| symmetry | 对称  |                 N/A                 |          minValue=-maxValue          |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>对称仅对`SInt`有效

```Scala
val A = SInt(8 bits)
val B = A.sat(3 bits)       //高3 bits饱和的5 bits返回值
val B = A.sat(3)            //与上式同理
val B = A.trim(3 bits)      //高3 bits舍弃的5bits返回值
val C = A.symmetry          //像(-128~127 to -127~127)一样返回8 bits
val C = A.sat(3).symmetry          //像(-16~15 to -15~15)一样返回5 bits
```

Verilog:

```Verilog
//饱和
wire       [3:0]    _zz_when_SInt_l131;
wire       [2:0]    _zz_when_SInt_l137;
wire       [7:0]    A;
reg        [4:0]    B;
wire                when_SInt_l130;
wire                when_SInt_l131;
wire                when_SInt_l137;

assign _zz_when_SInt_l131 = A[7 : 4];
assign _zz_when_SInt_l137 = A[6 : 4];
assign when_SInt_l130 = A[7];
assign when_SInt_l131 = (! (&amp;_zz_when_SInt_l131));
always @(*) begin
    if(when_SInt_l130) begin
        if(when_SInt_l131) begin
            B = 5&#39;h10;
        end else begin
            B = A[4 : 0];
        end
    end else begin
        if(when_SInt_l137) begin
            B = 5&#39;h0f;
        end else begin
            B = A[4 : 0];
        end
    end
end

assign when_SInt_l137 = (|_zz_when_SInt_l137);

//trim舍弃
wire       [7:0]    A;
wire       [4:0]    B;

assign B = A[4 : 0];

//对称
wire       [7:0]    _zz_B;
wire       [7:0]    _zz_B_1;
wire       [7:0]    A;
wire       [7:0]    B;

assign _zz_B = 8&#39;h80;
assign _zz_B_1 = 8&#39;h81;
assign B = (($signed(A) == $signed(_zz_B)) ? _zz_B_1 : A);

```
</pre></div>
</div>
<ol>
<li><p>fixTo函数(fixTo function)</p>
<p>针对<code class="docutils literal notranslate"><span class="pre">UInt</span></code>/<code class="docutils literal notranslate"><span class="pre">SInt</span></code>提供了两种定点方法：</p>
<p><img alt="fixPoint" src="_images/fixPoint.png" /></p>
<p>强烈推荐在RTL工程中使用<code class="docutils literal notranslate"><span class="pre">fixTo</span></code>, 有了这个函数你就不需要处理进位alignment和bit宽度的计算问题, 如同上图Way1那样。</p>
<p>Fix函数关于自动处理饱和：</p>
</li>
</ol>
<pre><code>|                 函数                 |        描述         |     返回类型      |
| :----------------------------------: | :-----------------: | :---------------: |
| fixTo(section, roundType, symmetric) | Factory FixFunction | section.size bits |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
val A = SInt(16 bits)
val B = A.fixTo(10 downto 3) //默认的RoundType是ROUNDTOINF, sym=false
val B = A.fixTo(8 downto 0, RoundType.ROUNDUP)
val B = A.fixTo(9 downto 3, RoundType.CEIL, sym = false)
val B = A.fixTo(16 downto 1, RoundType.ROUNDTOINF, sym = true)
val B = A.fixTo(10 downto 3, RoundType.FLOOR)   //向下取整3 bits, 舍弃进位5 bits @ highest
val B = A.fixTo(20 downto 3, RoundType.FLOOR)   //向下取整3 bits,拓展进位2 bits @ highest
```

Verilog:

```Verilog
wire       [7:0]    fixTo_dout;
wire       [15:0]   A;

SInt16fixTo10_3_ROUNDTOINF fixTo (
    .din  (A[15:0]        ), //i
    .dout (fixTo_dout[7:0])  //o
);

module SInt16fixTo10_3_ROUNDTOINF (
  input      [15:0]   din,
  output     [7:0]    dout
);

  wire       [16:0]   _zz__zz_dout_4;
  wire       [16:0]   _zz__zz_dout_4_1;
  wire       [2:0]    _zz_when_SInt_l191;
  wire       [13:0]   _zz__zz_dout_6;
  wire       [13:0]   _zz__zz_dout_6_1;
  wire       [16:0]   _zz__zz_dout;
  wire       [16:0]   _zz__zz_dout_1;
  wire       [16:0]   _zz__zz_dout_2;
  wire       [6:0]    _zz_when_SInt_l131;
  wire       [5:0]    _zz_when_SInt_l137;
  reg        [13:0]   _zz_dout;
  wire       [15:0]   _zz_dout_1;
  wire       [15:0]   _zz_dout_2;
  wire       [15:0]   _zz_dout_3;
  wire       [16:0]   _zz_dout_4;
  wire       [15:0]   _zz_dout_5;
  wire                when_SInt_l337;
  reg        [13:0]   _zz_dout_6;
  wire                when_SInt_l191;
  reg        [7:0]    _zz_dout_7;
  wire                when_SInt_l130;
  wire                when_SInt_l131;
  wire                when_SInt_l137;

assign _zz__zz_dout_4 = {_zz_dout_3[15],_zz_dout_3};
assign _zz__zz_dout_4_1 = {_zz_dout_2[15],_zz_dout_2};
assign _zz_when_SInt_l191 = _zz_dout_4[2 : 0];
assign _zz__zz_dout_6 = _zz_dout_4[16 : 3];
assign _zz__zz_dout_6_1 = 14&#39;h0001;
assign _zz__zz_dout = ($signed(_zz__zz_dout_1) + $signed(_zz__zz_dout_2));
assign _zz__zz_dout_1 = {_zz_dout_5[15],_zz_dout_5};
assign _zz__zz_dout_2 = {_zz_dout_1[15],_zz_dout_1};
assign _zz_when_SInt_l131 = _zz_dout[13 : 7];
assign _zz_when_SInt_l137 = _zz_dout[12 : 7];
assign _zz_dout_1 = {{13&#39;h0,1&#39;b1},2&#39;b00};
assign _zz_dout_2 = {14&#39;h3fff,2&#39;b00};
assign _zz_dout_3 = din[15 : 0];
assign _zz_dout_4 = ($signed(_zz__zz_dout_4) + $signed(_zz__zz_dout_4_1));
assign _zz_dout_5 = din[15 : 0];
assign when_SInt_l337 = _zz_dout_4[16];
assign when_SInt_l191 = (|_zz_when_SInt_l191);
always @(*) begin
    if(when_SInt_l191) begin
        _zz_dout_6 = ($signed(_zz__zz_dout_6) + $signed(_zz__zz_dout_6_1));
    end else begin
        _zz_dout_6 = _zz_dout_4[16 : 3];
    end
end

always @(*) begin
    if(when_SInt_l337) begin
        _zz_dout = _zz_dout_6;
    end else begin
        _zz_dout = (_zz__zz_dout &gt;&gt;&gt; 3);
    end
end

assign when_SInt_l130 = _zz_dout[13];
assign when_SInt_l131 = (! (&amp;_zz_when_SInt_l131));
always @(*) begin
    if(when_SInt_l130) begin
        if(when_SInt_l131) begin
            _zz_dout_7 = 8&#39;h80;
        end else begin
            _zz_dout_7 = _zz_dout[7 : 0];
        end
    end else begin
        if(when_SInt_l137) begin
            _zz_dout_7 = 8&#39;h7f;
        end else begin
            _zz_dout_7 = _zz_dout[7 : 0];
        end
    end
end

assign when_SInt_l137 = (|_zz_when_SInt_l137);
assign dout = _zz_dout_7;

```
</pre></div>
</div>
</section>
</section>
<section id="spinalenum">
<h2>SpinalEnum<a class="headerlink" href="#spinalenum" title="Permalink to this heading"></a></h2>
<section id="id13">
<h3>一、描述(Description)<a class="headerlink" href="#id13" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Enumeration</span></code>类型代表一组值组成的列表</p>
</section>
<section id="id14">
<h3>二、声明(Declaration)<a class="headerlink" href="#id14" title="Permalink to this heading"></a></h3>
<p>枚举数据类型的声明方式如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">Enumeration</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">SpinalEnum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">element0</span><span class="p">,</span><span class="w"> </span><span class="n">element1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">elementN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newElement</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>对于上述例子, 使用默认的编码方式。原生的枚举类型用于VHDL, 二进制编码用于Verilog。</p>
<p>能够通过下述方式强制使用枚举编码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">Enumeration</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">SpinalEnum</span><span class="p">(</span><span class="n">defaultEncoding</span><span class="o">=</span><span class="n">encodingOfYourChoice</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">element0</span><span class="p">,</span><span class="w"> </span><span class="n">element1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">elementN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newElement</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p>备注：如果想为给定的模块定义枚举类型的输入/输出, 应该用如下方式定义：<code class="docutils literal notranslate"><span class="pre">in(MyEnum())</span></code>或者<code class="docutils literal notranslate"><span class="pre">out(MyEnum)</span></code></p>
</div></blockquote>
<ol>
<li><p>编码(Encoding)</p>
<p>SpinalHDL支持下述的枚举编码方式：</p>
</li>
</ol>
<pre><code>|     编码方式     |      Bit位宽       |                   描述                   |
| :--------------: | :----------------: | :--------------------------------------: |
|      native      |                    |    这是默认编码方式, 使用VHDL枚举系统    |
| binarySequential | log2Up(stateCount) | 以声明的顺序使用Bits存储状态(值从0到n-1) |
|   binaryOneHot   |     stateCount     | 使用Bits来存储状态, 每个bit对应一个状态  |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>定制化的编码方式能用静态和动态的方式实现：

```Scala
/*
 *静态编码方式
 */
object MyEnumStatic extends SpinalEnum {
    val e0, e1, e2, e3 = newElement()
    defaultEncoding = SpinalEnumEncoding(&quot;staticEncoding&quot;)(
        e0 -&gt; 0,
        e1 -&gt; 2,
        e2 -&gt; 3,
        e3 -&gt; 7
    )

/*
 *用函数动态编码： _ * 2 + 1
 *e.g. :  e0 =&gt; 0 * 2 + 1 = 1
 *        e1 =&gt; 1 * 2 + 1 = 3
 *        e2 =&gt; 2 * 2 + 1 = 5
 *        e3 =&gt; 3 * 2 + 1 = 7
 */
    val encoding = SpinalEnumEncoding(&quot;dynamicEncoding&quot;, _ * 2 + 1)

    object MyEnumDynamic extends SpinalEnum(encoding) {
        val e0, e1, e2, e3 = newElement()
    }
}
```
</pre></div>
</div>
<ol>
<li><p>举例(Example)</p>
<p>初始化枚举信号并给它赋值：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">UartCtrlTxState</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">SpinalEnum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">sIdle</span><span class="p">,</span><span class="w"> </span><span class="n">sStart</span><span class="p">,</span><span class="w"> </span><span class="n">sData</span><span class="p">,</span><span class="w"> </span><span class="n">sParity</span><span class="p">,</span><span class="w"> </span><span class="n">sStop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newElement</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">stateNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UartCtrlTxState</span><span class="p">()</span><span class="w"></span>
<span class="n">stateNext</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">UartCtrlTxState</span><span class="p">.</span><span class="n">sIdle</span><span class="w"></span>

<span class="c1">//你也可以import枚举类型使其元素可视化, 需要放在package里</span>
<span class="k">import</span><span class="w"> </span><span class="nc">UartCtrlTxState</span><span class="p">.</span><span class="n">_</span>
<span class="n">stateNext</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">sIdle</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">localparam</span><span class="w"> </span><span class="nc">UartCtrlTxState_sIdle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="ss">&#39;d0</span><span class="p">;</span><span class="w"></span>
<span class="n">localparam</span><span class="w"> </span><span class="nc">UartCtrlTxState_sStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="ss">&#39;d1</span><span class="p">;</span><span class="w"></span>
<span class="n">localparam</span><span class="w"> </span><span class="nc">UartCtrlTxState_sData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="ss">&#39;d2</span><span class="p">;</span><span class="w"></span>
<span class="n">localparam</span><span class="w"> </span><span class="nc">UartCtrlTxState_sParity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="ss">&#39;d3</span><span class="p">;</span><span class="w"></span>
<span class="n">localparam</span><span class="w"> </span><span class="nc">UartCtrlTxState_sStop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="ss">&#39;d4</span><span class="p">;</span><span class="w"></span>

<span class="n">wire</span><span class="w">       </span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span><span class="w">    </span><span class="n">stateNext</span><span class="p">;</span><span class="w"></span>

<span class="n">`ifndef SYNTHESIS</span>
<span class="n">    reg [55:0] stateNext_string;</span>
<span class="n">`endif</span><span class="w"></span>


<span class="n">`ifndef SYNTHESIS</span>
<span class="n">    always @(*) begin</span>
<span class="n">        case(stateNext)</span>
<span class="n">        UartCtrlTxState_sIdle : stateNext_string = &quot;sIdle  &quot;;</span>
<span class="n">        UartCtrlTxState_sStart : stateNext_string = &quot;sStart &quot;;</span>
<span class="n">        UartCtrlTxState_sData : stateNext_string = &quot;sData  &quot;;</span>
<span class="n">        UartCtrlTxState_sParity : stateNext_string = &quot;sParity&quot;;</span>
<span class="n">        UartCtrlTxState_sStop : stateNext_string = &quot;sStop  &quot;;</span>
<span class="n">        default : stateNext_string = &quot;???????&quot;;</span>
<span class="n">        endcase</span>
<span class="n">    end</span>
<span class="n">`endif</span><span class="w"></span>

<span class="n">assign</span><span class="w"> </span><span class="n">stateNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UartCtrlTxState_sIdle</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="id15">
<h3>三、操作符(Operators)<a class="headerlink" href="#id15" title="Permalink to this heading"></a></h3>
<p>以下是可供<code class="docutils literal notranslate"><span class="pre">Enumeration</span></code>类型使用的操作符：</p>
<ol>
<li><p>比较运算(Comparison)</p>
<p>|操作符|描述|返回类型|
|x===y|相等|Bool|
|x=/=y|不相等|Bool|</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nc">UartCtrlTxState</span><span class="p">.</span><span class="n">_</span>

<span class="kd">val</span><span class="w"> </span><span class="n">stateNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UartCtrlTxState</span><span class="p">()</span><span class="w"></span>
<span class="n">stateNext</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">sIdle</span><span class="w"></span>

<span class="n">when</span><span class="p">(</span><span class="n">stateNext</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">sStart</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">switch</span><span class="p">(</span><span class="n">stateNext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="n">sIdle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="n">sStart</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>类型(Types)</p>
<p>为了使用你的enum, 例如在函数里, 你需要它的类型。</p>
<p>enum中值的类型(例如sIdle的类型)：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">spinal</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="nc">SpinalEnumElement</span><span class="p">[</span><span class="nc">UartCtrlTxState</span><span class="p">.</span><span class="k">type</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>或者等价地, 也可以如下方式</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="nc">UartCtrlTxState</span><span class="p">.</span><span class="nc">E</span><span class="w"></span>
</pre></div>
</div>
<p>bundle的类型(例如stateNext的类型)：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">spinal</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="nc">SpinalEnumCraft</span><span class="p">[</span><span class="nc">UartCtrlTxState</span><span class="p">.</span><span class="k">type</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>或者等价地, 也可以用如下方式</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="nc">UartCtrlTxState</span><span class="p">.</span><span class="nc">C</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>类型转换(Type cast)</p></li>
</ol>
<pre><code>|         操作符         |       描述       |    返回类型     |
| :--------------------: | :--------------: | :-------------: |
|        x.asBits        | 二进制转换为Bits | Bits(w(x) bits) |
|        x.asUInt        | 二进制转换为UInt | UInt(w(x) bits) |
|        x.asSInt        | 二进制转换为SInt | SInt(w(x) bits) |
| e.assignFromBits(bits) |  Bits转换为enum  |    MyEnum()     |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
import UartCtrlTxState._

val stateNext = UartCtrlTxState()
myBits := sIdle.asBits

stateNext.assignFromBits(myBits)
```

Verilog:

```Verilog
localparam UartCtrlTxState_sIdle = 3&#39;d0;
localparam UartCtrlTxState_sStart = 3&#39;d1;
localparam UartCtrlTxState_sData = 3&#39;d2;
localparam UartCtrlTxState_sParity = 3&#39;d3;
localparam UartCtrlTxState_sStop = 3&#39;d4;

wire       [2:0]    myBits;
wire       [2:0]    stateNext;
wire       [2:0]    _zz_stateNext;
reg        [7:0]    counter;
`ifndef SYNTHESIS
    reg [55:0] stateNext_string;
    reg [55:0] _zz_stateNext_string;
`endif


`ifndef SYNTHESIS
    always @(*) begin
        case(stateNext)
            UartCtrlTxState_sIdle : stateNext_string = &quot;sIdle  &quot;;
            UartCtrlTxState_sStart : stateNext_string = &quot;sStart &quot;;
            UartCtrlTxState_sData : stateNext_string = &quot;sData  &quot;;
            UartCtrlTxState_sParity : stateNext_string = &quot;sParity&quot;;
            UartCtrlTxState_sStop : stateNext_string = &quot;sStop  &quot;;
            default : stateNext_string = &quot;???????&quot;;
        endcase
    end
    always @(*) begin
        case(_zz_stateNext)
            UartCtrlTxState_sIdle : _zz_stateNext_string = &quot;sIdle  &quot;;
            UartCtrlTxState_sStart : _zz_stateNext_string = &quot;sStart &quot;;
            UartCtrlTxState_sData : _zz_stateNext_string = &quot;sData  &quot;;
            UartCtrlTxState_sParity : _zz_stateNext_string = &quot;sParity&quot;;
            UartCtrlTxState_sStop : _zz_stateNext_string = &quot;sStop  &quot;;
            default : _zz_stateNext_string = &quot;???????&quot;;
        endcase
    end
`endif

assign myBits = UartCtrlTxState_sIdle;
assign _zz_stateNext = myBits;
assign stateNext = _zz_stateNext;

```
</pre></div>
</div>
</section>
</section>
<section id="bundle">
<h2>Bundle<a class="headerlink" href="#bundle" title="Permalink to this heading"></a></h2>
<section id="id16">
<h3>一、描述(Description)<a class="headerlink" href="#id16" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Bundle</span></code>是一种符合类型, 它定义了一组命名了的信号(这些信号是SpinalHDL的基础类型)</p>
<p><code class="docutils literal notranslate"><span class="pre">Bundle</span></code>类型能用来搭建数据结构, 总线和接口的模型。</p>
</section>
<section id="id17">
<h3>二、声明(Declaration)<a class="headerlink" href="#id17" title="Permalink to this heading"></a></h3>
<p>声明bundle的语句如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">myBundle</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">bundleItem0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">AnyType</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">bundleItem1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">AnyType</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">bundleItemN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">AnyType</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>例如, 一个包含颜色信号的bundle可以如下定义：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Color</span><span class="p">(</span><span class="n">channelWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">channelWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>你可以在“SpinalHDL用例”当中找到APB3的定义</p>
<ol>
<li><p>条件信号(Conditional signals)</p>
<p><code class="docutils literal notranslate"><span class="pre">Bundle</span></code>中的信号可以根据条件选择定义。如下举例, 除非<code class="docutils literal notranslate"><span class="pre">datawidth</span></code>大于0, <code class="docutils literal notranslate"><span class="pre">mybundle</span></code>中不会有<code class="docutils literal notranslate"><span class="pre">data</span></code>信号：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">myBundle</span><span class="p">(</span><span class="n">dataWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">dataWidth</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">generate</span><span class="w"> </span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="id18">
<h3>三、操作符(Operators)<a class="headerlink" href="#id18" title="Permalink to this heading"></a></h3>
<p>下述是<code class="docutils literal notranslate"><span class="pre">Bundle</span></code>可用的操作符：</p>
<ol class="simple">
<li><p>对比操作(Comparison)</p></li>
</ol>
<pre><code>| 操作符 |  描述  | 返回类型 |
| :----: | :----: | :------: |
| x===y  |  相等  |   Bool   |
| x=/=y  | 不相等 |   Bool   |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
val color1 = Color(8)
color1.r := 0
color1.g := 0
color1.b := 0

val color2 = Color(8)
color2.r := 0
color2.g := 0
color2.b := 0

myBool := color1 === color2
```
</pre></div>
</div>
<ol class="simple">
<li><p>类型转换(Type cast)</p></li>
</ol>
<pre><code>|  操作符  |       描述       |    返回类型     |
| :------: | :--------------: | :-------------: |
| x.asBits | 二进制转换成Bits | Bits(w(x) bits) |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
val color1 = Color(8)
val myBits := color1.asBits
```

Verilog:

```Verilog
wire       [7:0]    color1_data;
wire       [7:0]    myBits;

assign myBits = color1_data;
```

bundle的元素在二进制串中按照定义的顺序排列, 因此`r`在`color1`中`myBits`(LSB)中的0-8, 之后按顺序依次所`g`和`b`
</pre></div>
</div>
<ol>
<li><p>把Bits转换成Bundle(Convert Bits back to Bundle)</p>
<p><code class="docutils literal notranslate"><span class="pre">.assignFromBits</span></code>操作符相当于<code class="docutils literal notranslate"><span class="pre">.asBits</span></code>的相反操作。</p>
</li>
</ol>
<pre><code>|           操作符            |                      描述                      | 返回类型 |
| :-------------------------: | :--------------------------------------------: | :------: |
|     x.assignFromBits(y)     |            把Bits(y)转换成Bundle(x)            |   UInt   |
| x.assignFromBits(y, hi, lo) | 把Bits(y)转换成Bundle(x), 并带有high/low的边界 |   UInt   |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>下例把一个叫做CommonDataBus的Bundle存进环形buffer(3rd party memory)中, 之后读出Bits并把他们转换回CommonDataBus。

![CommonDataBus](image/CommonDataBus.png)

```Scala
case class TestBundle () extends Component {
    val io = new Bundle {
        val we      = in    Bool()
        val addrWr  = in    UInt(7 bits)
        val dataIn  = slave (CommonDataBus())

        val addrRd  = in    UInt(7 bits)
        val dataOut = master(CommonDataBus())
    }

    val mm = Ram3rdParty_1w_1rs (
        G_DATA_WIDTH = io.dataIn.getBitsWidth,
        G_ADDR_WIDTH = io.addrWr.getBitsWidth,
        G_VENDOR     = &quot;Intel_Arria10_M20K&quot;)

    mm.io.clk_in    := clockDomain.readClockWire
    mm.io.clk_out   := clockDomain.readClockWire
    
    mm.io.we        := io.we
    mm.io.addr_wr   := io.addrWr.asBits
    mm.io.d         := io.dataIn.asBits

    mm.io.addr_rd   := io.addrRd.asBits
    io.dataOut.assignFromBits(mm.io.q)
}
```
</pre></div>
</div>
</section>
<section id="io-io-element-direction">
<h3>四、IO类型指导(IO Element direction)<a class="headerlink" href="#io-io-element-direction" title="Permalink to this heading"></a></h3>
<p>当你在模块的IO定义中定义一个<code class="docutils literal notranslate"><span class="pre">Bundle</span></code>, 你需要指定它的方向。</p>
<ol>
<li><p>in/out</p>
<p>如果bundle的所有元素方向相同, 可以使用<code class="docutils literal notranslate"><span class="pre">in(MyBundle())</span></code>或者<code class="docutils literal notranslate"><span class="pre">out(MyBundle())</span></code>。</p>
<p>例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">input</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="p">(</span><span class="nc">Color</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">Color</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>master/slave</p>
<p>如果你的接口遵从于master/slave拓扑, 你可以使用<code class="docutils literal notranslate"><span class="pre">IMasterSlave</span></code>特性, 之后你需要对函数<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">asMaster():</span> <span class="pre">Unit</span></code>配置来补全每个来自master方面的元素的方向, 这之后你就可以在IO定义中用<code class="docutils literal notranslate"><span class="pre">master(MyBundle())</span></code>和<code class="docutils literal notranslate"><span class="pre">slave(MyBundle())</span></code>语句。</p>
<p>有些函数, 如同<code class="docutils literal notranslate"><span class="pre">Flow</span></code>类中的<code class="docutils literal notranslate"><span class="pre">toStream</span></code>方法, 会以toXXX的方式定义。这些函数常常由master侧调用。此外, fromXXX函数是为slave侧设计的。通常来说, master侧可用的函数比slave侧更多。</p>
<p>例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">HandShake</span><span class="p">(</span><span class="n">payloadWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">valid</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ready</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">payloadWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//你需要补全这个asMaster函数</span>
<span class="w">    </span><span class="c1">//这个函数应该设置master侧的每个信号的方向</span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="p">(</span><span class="n">valid</span><span class="p">,</span><span class="w"> </span><span class="n">payload</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">in</span><span class="p">(</span><span class="n">ready</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">input</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">HandShake</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">output</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">HandShake</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">MyTopLevel</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">io_input_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w">          </span><span class="n">io_input_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_input_payload</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w">          </span><span class="n">io_output_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">io_output_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_output_payload</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="kt">wire</span><span class="w">                </span><span class="n">when_MyTopLevel_l56</span><span class="p">;</span><span class="w"></span>

<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_input_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_MyTopLevel_l56</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">io_input_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_output_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_MyTopLevel_l56</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">io_output_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_output_payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_MyTopLevel_l56</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">io_output_payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h23</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">when_MyTopLevel_l56</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_output_ready</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">io_input_valid</span><span class="p">);</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="vec">
<h2>Vec<a class="headerlink" href="#vec" title="Permalink to this heading"></a></h2>
<section id="id19">
<h3>一、描述(Description)<a class="headerlink" href="#id19" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Vec</span></code>是定义了一组带有标号的信号的复合信号(基于SpinalHDL基础类别)</p>
</section>
<section id="id20">
<h3>二、声明(Declaration)<a class="headerlink" href="#id20" title="Permalink to this heading"></a></h3>
<p>声明向量的语法如下：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">声明</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Vec(type: Data, size: Int)</td>
<td style="text-align: center;">创建一个能容纳<code>size</code>个<code>data</code>类元素的向量</td>
</tr>
<tr>
<td style="text-align: center;">Vec(x, y, ...)</td>
<td style="text-align: center;">创建一个标号对应给定元素的向量, 这种方式支持混合元素宽度</td>
</tr>
</tbody>
</table><section id="examples">
<h4>Examples<a class="headerlink" href="#examples" title="Permalink to this heading"></a></h4>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//创建一个有两个有符号整型的向量</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myVecOfSInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="nc">SInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="n">myVecOfSInt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="n">myVecOfSInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">myVecOfSInt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>

<span class="c1">//创建一个有三个不同类型元素的向量</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myVecOfMixedInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">myVecOf_xyz_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"></span>

<span class="c1">//向量的迭代</span>
<span class="k">for</span><span class="p">(</span><span class="n">element</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">myVecOf_xyz_ref</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">element</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="c1">//给所有元素赋值0</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">//向量Map映射</span>
<span class="n">myVecOfMixedInt</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">//给所有元素赋值0</span>

<span class="c1">//给向量的第一个元素赋值3</span>
<span class="n">myVecOf_xyz_ref</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_myVecOfSInt_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myVecOfSInt_0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myVecOfSInt_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myVecOfMixedInt_0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myVecOfMixedInt_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myVecOfMixedInt_2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">z</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">counter</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_myVecOfSInt_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h03</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myVecOfSInt_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h02</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myVecOfSInt_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">$signed</span><span class="p">(</span><span class="n">myVecOfSInt_0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">$signed</span><span class="p">(</span><span class="n">_zz_myVecOfSInt_1</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myVecOfMixedInt_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b000</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myVecOfMixedInt_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">5&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">myVecOfMixedInt_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="id21">
<h3>三、操作符(Operators)<a class="headerlink" href="#id21" title="Permalink to this heading"></a></h3>
<p>以下操作符是<code class="docutils literal notranslate"><span class="pre">Vec</span></code>类型所支持的：</p>
<ol class="simple">
<li><p>比较操作(Comparison)</p></li>
</ol>
<pre><code>| 操作符 |  描述  | 返回类型 |
| :----: | :----: | :------: |
| x===y  |  相等  |   Bool   |
| x=/=y  | 不相等 |   Bool   |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
//创建一个有两个有符号整型的向量
val vec2 = Vec(SInt(8 bits), 2)
val vec1 = Vec(SInt(8 bits), 2)

myBool := vec2 === vec1 //比较两个向量
```

Verilog:

```Verilog
wire       [7:0]    vec2_0;
wire       [7:0]    vec2_1;
wire       [7:0]    vec1_0;
wire       [7:0]    vec1_1;
wire                myBool;

assign myBool = (($signed(vec2_0) == $signed(vec1_0)) &amp;&amp; ($signed(vec2_1) == $signed(vec1_1)));

```
</pre></div>
</div>
<ol class="simple">
<li><p>类型转换(Type cast)</p></li>
</ol>
<pre><code>|  操作符  |       描述       |    返回类型     |
| :------: | :--------------: | :-------------: |
| x.asBits | 二进制转换为Bits | Bits(w(x) bits) |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
//创建一个有两个有符号整型的向量
val vec1 = Vec(SInt(8 bits), 2)

myBits_16bits := vec1.asBits
```
</pre></div>
</div>
<ol class="simple">
<li><p>Misc</p></li>
</ol>
<pre><code>|     操作符     |     描述      | 返回类型 |
| :------------: | :-----------: | :------: |
| x.getBitsWidth | 返回Vec的长度 |   Int    |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
//创建一个有两个有符号整型的向量
val vec1 = Vec(SInt(8 bits), 2)

println(vec1.getBitsWidth)  //16
</pre></div>
</div>
<ol>
<li><p>库辅助函数(Lib Helper functions)</p>
<blockquote>
<div><p>使用这些函数, 需要<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">spinal.lib._</span></code></p>
</div></blockquote>
</li>
</ol>
<pre><code>|               操作符               |                                   描述                                   | 返回类型 |
| :--------------------------------: | :----------------------------------------------------------------------: | :------: |
|    x.sCount(condition: T=&gt;Bool)    |                     计算Vec中与给定条件相匹配的个数                      |   UInt   |
|         x.sCount(value: T)         |                          计算与给定值相等的个数                          |   UInt   |
|   x.sExists(condition: T=&gt;Bool)    |                        检查Vec中是否有匹配的条件                         |   Bool   |
|       x.sContains(value: T)        |                       检查Vec中是否有给定的值存在                        |   Bool   |
|  x.sFindFirst(condition: T=&gt;Bool)  |        找到Vec中第一个与给定条件相匹配的元素, 返回那个元素的标号         |   UInt   |
| x.reduceBalancedTree(op:(T, T)=&gt;T) | 平衡化的归约函数, 能尽量减小生成电路的深度。`op`应该是可交换的且可结合的 |    T     |
| x.shuffle(indexMapping: Int=&gt;Int)  |              用一个Map函数把旧索引映射到新索引上, 对Vec重组              |  Vec[T]  |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```Scala
import spinal.lib._

//创建有4个无符号整型的向量
val vec1 = Vec(UInt(8bits), 4)

//...向量在某些地方被赋值后

val c1: UInt = vec1.sCount(_ &lt; 128)     //向量中有多少值小于128
val c2: UInt = vec1.sCount(0)           //向量中有多少0值

val b1: Bool = vec1.sExist(_ &gt; 250)    //向量中有没有比250大的
val b2: Bool = vec1.sContains(0)        //向量中有没有0

val u1: UInt = vec1.sFindFirst(_ &lt; 10)  //得到第一个比10小的元素的标号, 该函数在转化时有问题, 有待商榷
val u2: UInt = vec1.reduceBalancedTree(_ + _)   //向量求和
```

Verilog:

```Verilog
wire       [1:0]    _zz_c1;
wire       [1:0]    _zz_c1_1;
wire       [0:0]    _zz_c1_2;
wire       [2:0]    _zz_c1_3;
wire       [1:0]    _zz_c1_4;
wire       [1:0]    _zz_c1_5;
wire       [0:0]    _zz_c1_6;
wire       [1:0]    _zz_c2;
wire       [1:0]    _zz_c2_1;
wire       [0:0]    _zz_c2_2;
wire       [2:0]    _zz_c2_3;
wire       [1:0]    _zz_c2_4;
wire       [1:0]    _zz_c2_5;
wire       [0:0]    _zz_c2_6;
wire       [7:0]    _zz_u2;
wire       [7:0]    _zz_u2_1;
wire       [7:0]    vec1_0;
wire       [7:0]    vec1_1;
wire       [7:0]    vec1_2;
wire       [7:0]    vec1_3;
wire       [2:0]    c1;
wire       [2:0]    c2;
wire                b1;
wire                b2;
wire       [7:0]    u2;
reg        [7:0]    counter;

assign _zz_c1 = ({1&#39;b0,(vec1_0 &lt; 8&#39;h80)} + _zz_c1_1);
assign _zz_c1_2 = (vec1_1 &lt; 8&#39;h80);
assign _zz_c1_1 = {1&#39;d0, _zz_c1_2};
assign _zz_c1_4 = ({1&#39;b0,(vec1_2 &lt; 8&#39;h80)} + _zz_c1_5);
assign _zz_c1_3 = {1&#39;d0, _zz_c1_4};
assign _zz_c1_6 = (vec1_3 &lt; 8&#39;h80);
assign _zz_c1_5 = {1&#39;d0, _zz_c1_6};
assign _zz_c2 = ({1&#39;b0,(vec1_0 == 8&#39;h0)} + _zz_c2_1);
assign _zz_c2_2 = (vec1_1 == 8&#39;h0);
assign _zz_c2_1 = {1&#39;d0, _zz_c2_2};
assign _zz_c2_4 = ({1&#39;b0,(vec1_2 == 8&#39;h0)} + _zz_c2_5);
assign _zz_c2_3 = {1&#39;d0, _zz_c2_4};
assign _zz_c2_6 = (vec1_3 == 8&#39;h0);
assign _zz_c2_5 = {1&#39;d0, _zz_c2_6};
assign _zz_u2 = (vec1_0 + vec1_1);
assign _zz_u2_1 = (vec1_2 + vec1_3);
assign c1 = ({1&#39;b0,_zz_c1} + _zz_c1_3);
assign c2 = ({1&#39;b0,_zz_c2} + _zz_c2_3);
assign b1 = ((((1&#39;b0 || (8&#39;hfa &lt; vec1_0)) || (8&#39;hfa &lt; vec1_1)) || (8&#39;hfa &lt; vec1_2)) || (8&#39;hfa &lt; vec1_3));
assign b2 = ((((1&#39;b0 || (vec1_0 == 8&#39;h0)) || (vec1_1 == 8&#39;h0)) || (vec1_2 == 8&#39;h0)) || (vec1_3 == 8&#39;h0));
assign u2 = (_zz_u2 + _zz_u2_1);

```

&gt; 备注：sXXX前缀用来与接受lambda函数作为参数的同名Scala函数的歧义
</pre></div>
</div>
</section>
</section>
<section id="ufix-sfix">
<h2>UFix/SFix<a class="headerlink" href="#ufix-sfix" title="Permalink to this heading"></a></h2>
<blockquote>
<div><p>注意：SpinalHDL定点数只是部分支持并部分经过测试的, 如果你发现它有任何bug, 或者你认为有些函数丢失了, 请创建一个Github issue。并且, 请不要在代码中用未在doc中指出的特征。</p>
</div></blockquote>
<section id="id22">
<h3>一、描述(Description)<a class="headerlink" href="#id22" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">UFix</span></code>和<code class="docutils literal notranslate"><span class="pre">SFix</span></code>类型对应于适用于定点数算法的bit向量。</p>
</section>
<section id="id23">
<h3>二、声明(Declaration)<a class="headerlink" href="#id23" title="Permalink to this heading"></a></h3>
<p>声明定点数的语法如下所示：</p>
<ol class="simple">
<li><p>无符号定点数(Unsigned Fixed-Point)</p></li>
</ol>
<pre><code>|                     语法                     |    整数宽度     |     分辨率     |          max          |  min  |
| :------------------------------------------: | :-------------: | :------------: | :-------------------: | :---: |
| UFix(peak: ExpNumber, resolution: ExpNumber) | peak-resolution |  2^resolution  |  2^peak-2^resolution  |   0   |
|    UFix(peak: ExpNumber, width: BitCount)    |      width      | 2^(peak-width) | 2^peak-2^(peak-width) |   0   |
</code></pre><ol class="simple">
<li><p>有符号定点数(Signed Fixed-Point)</p></li>
</ol>
<pre><code>|                     语法                     |     整数宽度      |      分辨率      |           max           |    min    |
| :------------------------------------------: | :---------------: | :--------------: | :---------------------: | :-------: |
| SFix(peak: ExpNumber, resolution: ExpNumber) | peak-resolution+1 |   2^resolution   |   2^peak-2^resolution   | -(2^peak) |
|   SFix(peak: ExpNumber, width: ExpNumber)    |       width       | 2^(peak-width-1) | 2^peak-2^(peak-width-1) | -(2^peak) |
</code></pre><ol>
<li><p>格式(Format)</p>
<p>SpinalHDL中定点数的格式按照Q notation的格式定义, 详情可见Wikipedia关于Q notation的讲解。</p>
<p>举例来说, Q8.2表示8+2 bits的定点数, 其中8 bits是整数部分而2 bits是小数部分。如果定点数是有符号数, 需要整数中的1 bit用作符号位。</p>
<p>分辨率定义为能表征的最小非零数是2的几次幂。</p>
<blockquote>
<div><p>备注：为了减少定点数在表示中2的几次幂时的错误, 在<code class="docutils literal notranslate"><span class="pre">spinal.core</span></code>中有一个数量类型叫做<code class="docutils literal notranslate"><span class="pre">ExpNumber</span></code>, 用来生成定点数类型, 另一种比较方便的实现可以用<code class="docutils literal notranslate"><span class="pre">exp</span></code>函数(如下页代码所示)</p>
</div></blockquote>
</li>
<li><p>例子(Examples)</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//无符号定点数</span>
<span class="kd">val</span><span class="w"> </span><span class="nc">UQ_8_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UFix</span><span class="p">(</span><span class="n">peak</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="n">resolution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w">    </span><span class="c1">//bit宽度是8-(-2)=10 bits</span>
<span class="kd">val</span><span class="w"> </span><span class="nc">UQ_8_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UFix</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="nc">UQ_8_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UFix</span><span class="p">(</span><span class="n">peak</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="nc">UQ_8_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UFix</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="c1">//有符号定点数</span>
<span class="kd">val</span><span class="w"> </span><span class="nc">Q_8_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SFix</span><span class="p">(</span><span class="n">peak</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">         </span><span class="c1">//bit宽度是8-(-2)+1=11 bits</span>
<span class="kd">val</span><span class="w"> </span><span class="nc">Q_8_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SFix</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="n">exp</span><span class="p">)</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="nc">Q_8_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SFix</span><span class="p">(</span><span class="n">peak</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="nc">Q_8_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SFix</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="assignments">
<h3>三、赋值(Assignments)<a class="headerlink" href="#assignments" title="Permalink to this heading"></a></h3>
<ol>
<li><p>有效赋值(Valid Assignments)</p>
<p>没有bit丢失时, 对定点数的赋值是有效的, 任何一位的bit丢失都会产生错误。</p>
<p>如果定点数的来源数太大, <code class="docutils literal notranslate"><span class="pre">.truncated</span></code>函数可以帮你改变元数据的尺寸来匹配目标尺寸。</p>
<p><strong>举例</strong></p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">i16_m2</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">SFix</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">i16_0</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">SFix</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">i8_m2</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">SFix</span><span class="p">(</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">o16_m2</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">SFix</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">o16_m0</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">SFix</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">o14_m2</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">SFix</span><span class="p">(</span><span class="mi">14</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w"></span>

<span class="n">o16_m2</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">i16_m2</span><span class="w">           </span><span class="c1">//OK</span>
<span class="n">o16_m0</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">i16_m2</span><span class="w">           </span><span class="c1">//Not OK, bit丢失</span>
<span class="n">o14_m2</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">i16_m2</span><span class="w">           </span><span class="c1">//Not OK, bit丢失</span>
<span class="n">o16_m0</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">i16_m2</span><span class="p">.</span><span class="n">truncated</span><span class="w"> </span><span class="c1">//OK, 尺寸自动改变</span>
<span class="n">o14_m2</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">i16_m2</span><span class="p">.</span><span class="n">truncated</span><span class="w"> </span><span class="c1">//OK, 尺寸自动改变</span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">18</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">i16_m2</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">16</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">i16_0</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">10</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">i8_m2</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">18</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">o16_m2</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">16</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">o16_m0</span><span class="p">;</span><span class="w"></span>
<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">16</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">o14_m2</span><span class="p">;</span><span class="w"></span>
<span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">counter</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">o16_m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i16_m2</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">o16_m0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i16_m2</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="mh">2</span><span class="p">);</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">o14_m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i16_m2</span><span class="p">[</span><span class="mh">16</span><span class="o">:</span><span class="mh">0</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>赋值来自于Scala常量(From a Scala constant)</p>
<p>Scala<code class="docutils literal notranslate"><span class="pre">BigInt</span></code>或者<code class="docutils literal notranslate"><span class="pre">Double</span></code>类型能在给<code class="docutils literal notranslate"><span class="pre">UFix</span></code>或者<code class="docutils literal notranslate"><span class="pre">SFix</span></code>信号赋值的时候视为常量。</p>
<p><strong>举例</strong></p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">i4_m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SFix</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w"></span>
<span class="n">i4_m2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mf">1.25</span><span class="w">   </span><span class="c1">//会在i4_m2.raw中载入5</span>
<span class="n">i4_m2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">4</span><span class="w">      </span><span class="c1">//会在i4_m2.raw中载入16</span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">6</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">i4_m2</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">i4_m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">7&#39;h05</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">i4_m2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">7&#39;h10</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="raw-raw-value">
<h3>四、Raw值(Raw value)<a class="headerlink" href="#raw-raw-value" title="Permalink to this heading"></a></h3>
<p>定点数的整体表达可以通过<code class="docutils literal notranslate"><span class="pre">raw</span></code>属性读写数据。</p>
<p><strong>举例</strong></p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="nc">UQ_8_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UFix</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="nc">UQ_8_2</span><span class="p">.</span><span class="n">raw</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">4</span><span class="w">     </span><span class="c1">//00000001 00赋值为1</span>
<span class="nc">UQ_8_2</span><span class="p">.</span><span class="n">raw</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">U</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="w"> </span><span class="c1">//00000100 01赋值为4.25</span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">9</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">UQ_8_2</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">UQ_8_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">10&#39;h004</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">UQ_8_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">10&#39;h011</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id24">
<h3>五、操作符(Operators)<a class="headerlink" href="#id24" title="Permalink to this heading"></a></h3>
<p>以下所<code class="docutils literal notranslate"><span class="pre">UFix</span></code>类型所支持的操作符：</p>
<ol class="simple">
<li><p>算数运算(Arithmetic)</p></li>
</ol>
<pre><code>|   操作符   |      描述       |      返回的小数部分分辨率       |      返回的整数部分范围       |
| :--------: | :-------------: | :-----------------------------: | :---------------------------: |
|    x+y     |      加法       | Min(x.resolution, y.resolution) | Max(x.amplitude, y.amplitude) |
|    x-y     |      减法       | Min(x.resolution, y.resolution) | Max(x.amplitude, y.amplitude) |
|    x*y     |      乘法       |    x.resolution*y.resolution    |    x.amplitude*y.amplitude    |
|    x&gt;&gt;y    | 算数右移, y:Int |         x.amplitude&gt;&gt;y          |        x.resolution&gt;&gt;y        |
|    x&lt;&lt;y    | 算数左移, y:Int |         x.amplitude&lt;&lt;y          |        x.resolution&lt;&lt;y        |
| x&gt;&gt;&amp;#124;y | 算数右移, y:Int |         x.amplitude&gt;&gt;y          |         x.resolution          |
| x&lt;&lt;&amp;#124;y | 算数右移, y:Int |         x.amplitude&lt;&lt;y          |         x.resolution          |
</code></pre><ol class="simple">
<li><p>比较运算(Comparison)</p></li>
</ol>
<pre><code>| 操作符 |   描述   | 返回类型 |
| :----: | :------: | :------: |
| x===y  |   相等   |   Bool   |
| x=/=y  |  不相等  |   Bool   |
|  x&gt;y   |   大于   |   Bool   |
|  x&gt;=y  | 大于等于 |   Bool   |
|  x&lt;y   |   小于   |   Bool   |
|  x&lt;=y  | 小于等于 |   Bool   |
</code></pre><ol class="simple">
<li><p>类型转换(Type cast)</p></li>
</ol>
<pre><code>|  操作符   |              描述              |      返回类型       |
| :-------: | :----------------------------: | :-----------------: |
| x.asBits  |        二进制转换为Bits        |   Bits(w(x) bits)   |
| x.asUInt  |        二进制转换为UInt        |   UInt(w(x) bits)   |
| x.asSInt  |        二进制转换为SInt        |   SInt(w(x) bits)   |
| x.asBools |         转换为Bool数组         | Vec(Bool, width(x)) |
| x.toUInt  | 返回对应的UInt(自带truncation) |        UInt         |
| x.toSInt  | 返回对应的SInt(自带truncation) |        SInt         |
| x.toUFix  |         返回对应的UFix         |        UFix         |
| x.toSFix  |         返回对应的SFix         |        SFix         |
</code></pre><ol class="simple">
<li><p>Misc##有问题, x.resolution那里##</p></li>
</ol>
<pre><code>|    操作符    |          描述           | 返回类型 |
| :----------: | :---------------------: | :------: |
|  x.maxValue  |   返回可存储的最大值    |  Double  |
|  x.minValue  |   返回可存储的最小值    |  Double  |
| x.resolution | x.amplitude*y.amplitude |  Double  |
</code></pre></section>
</section>
<section id="floating">
<h2>Floating<a class="headerlink" href="#floating" title="Permalink to this heading"></a></h2>
<blockquote>
<div><p>注意：SpinalHDL定点数只是部分支持并部分经过测试的, 如果你发现它有任何bug, 或者你认为有些函数丢失了, 请创建一个Github issue。并且, 请不要在代码中用未在doc中指出的特征。</p>
</div></blockquote>
<section id="id25">
<h3>一、描述(Description)<a class="headerlink" href="#id25" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Floating</span></code>类型对应于IEEE-754编码规则。第二种叫做<code class="docutils literal notranslate"><span class="pre">RecFloating</span></code>的类型能通过对浮点数的重编码简化一些IEEE-754浮点数的边缘案例。</p>
<p>它由1 bit符号位, 指数区域和底数区域组成。不同区域的宽度定义在IEEE-754或者de-facto标准中。</p>
<p>使用浮点数时需要先进行如下操作：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">experimental</span><span class="p">.</span><span class="nn">math</span><span class="p">.</span><span class="n">_</span>
</pre></div>
</div>
<p><strong>IEEE-754浮点格式(IEEE-754 floating format)</strong></p>
<p>数字会根据IEEE-754编码：https://en.wikipedia.org/wiki/IEEE_754</p>
<p><strong>浮点形式重编码(Recoded floating format)</strong></p>
<p>因为IEEE-754在非正规(denormalized)数字和特殊值的时候有一些不方便的地方, Berkeley提出了另一种浮点数值的编码方式。</p>
<p>为了能将非正规的数值规范(normalized)地处理, 底数经过了一些修改。</p>
<p>指数部分比IEEE-754多1 bit。</p>
<p>符号位没有改变。</p>
<p>例子可以在这里看到：https://github.com/ucb-bar/berkeley-hardfloat/blob/master/README.md</p>
<p><strong>零(Zero)</strong></p>
<p>指数字段的三个前导零被设置为0来代表0的编码。</p>
<p><strong>非正规数值(Denormalized values)</strong></p>
<p>非正规的数值也会编码成一般的浮点数, 底数被移位使第一位隐藏, 指数编码为107(十进制)加bit值是1的最高位的序号。</p>
<p><strong>规范数值(Normalized values)</strong></p>
<p>重编码的底数和IEEE-754标准的底数完全一致, 指数编码为130(十进制)加最初的指数值。</p>
<p><strong>无穷大(Infinity)</strong></p>
<p>重编码的底数值不用关心, 重编码的指数值的最高3 bits值是6(十进制), 剩余部分不用关心。</p>
<p><strong>NaN</strong></p>
<p>重编码的规范化底数部分与IEEE-754一致, 重编码的指数部分最高3 bits是7(十进制), 剩余部分不用关心。</p>
</section>
<section id="id26">
<h3>二、声明(Declaration)<a class="headerlink" href="#id26" title="Permalink to this heading"></a></h3>
<p>声明浮点数的语句如下所示：</p>
<p><strong>IEEE-754数字(IEEE-754 Number)</strong></p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">语法</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Floating(exponentSize: Int, mantissaSize: Int)</td>
<td style="text-align: center;">带有标准指数和底数长度的IEEE-754浮点数</td>
</tr>
<tr>
<td style="text-align: center;">Floating16()</td>
<td style="text-align: center;">半精度IEEE-754浮点数</td>
</tr>
<tr>
<td style="text-align: center;">Floating32()</td>
<td style="text-align: center;">单精度IEEE-754浮点数</td>
</tr>
<tr>
<td style="text-align: center;">Floating64()</td>
<td style="text-align: center;">双精度IEEE-754浮点数</td>
</tr>
<tr>
<td style="text-align: center;">Floating128()</td>
<td style="text-align: center;">四精度IEEE-754浮点数</td>
</tr>
</tbody>
</table><table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">语法</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">RecFloating(exponentSize: Int, mantissaSize: Int)</td>
<td style="text-align: center;">带有标准指数和底数长度的IEEE-754浮点数</td>
</tr>
<tr>
<td style="text-align: center;">RecFloating16()</td>
<td style="text-align: center;">重编码半精度浮点数</td>
</tr>
<tr>
<td style="text-align: center;">RecFloating32()</td>
<td style="text-align: center;">重编码单精度浮点数</td>
</tr>
<tr>
<td style="text-align: center;">RecFloating64()</td>
<td style="text-align: center;">重编码双精度浮点数</td>
</tr>
<tr>
<td style="text-align: center;">RecFloating128()</td>
<td style="text-align: center;">重编码四精度浮点数</td>
</tr>
</tbody>
</table></section>
<section id="id27">
<h3>三、操作符(Operators)<a class="headerlink" href="#id27" title="Permalink to this heading"></a></h3>
<p>以下所<code class="docutils literal notranslate"><span class="pre">Floating</span></code>和<code class="docutils literal notranslate"><span class="pre">RecFloating</span></code>类型所支持的操作符：</p>
<p><strong>类型转换(Type cast)</strong>    ##有问题, 前后不一##</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">x.asBits</td>
<td style="text-align: center;">二进制转换为Bits</td>
<td style="text-align: center;">Bits(w(x) bits)</td>
</tr>
<tr>
<td style="text-align: center;">x.asBools</td>
<td style="text-align: center;">转换为Bool数组</td>
<td style="text-align: center;">Vec(Bool, width(x))</td>
</tr>
<tr>
<td style="text-align: center;">x.toUInt(size: Int)</td>
<td style="text-align: center;">返回对应的UInt(自带truncation)</td>
<td style="text-align: center;">UInt</td>
</tr>
<tr>
<td style="text-align: center;">x.toSInt(size: Int)</td>
<td style="text-align: center;">返回对应的SInt(自带truncation)</td>
<td style="text-align: center;">SInt</td>
</tr>
<tr>
<td style="text-align: center;">x.fromUInt</td>
<td style="text-align: center;">返回对应的UFix(自带truncation)</td>
<td style="text-align: center;">UFix</td>
</tr>
<tr>
<td style="text-align: center;">x.fromUInt</td>
<td style="text-align: center;">返回对应的SFix(自带truncation)</td>
<td style="text-align: center;">SFix</td>
</tr>
</tbody>
</table></section>
</section>
<section id="afix-afixspinal">
<h2>AFix(AFix是最新版Spinal新增的数据结构，不知为何该板块有些代码无法通过编译)<a class="headerlink" href="#afix-afixspinal" title="Permalink to this heading"></a></h2>
<section id="id28">
<h3>一、描述(Description)<a class="headerlink" href="#id28" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AFix</span></code>(Auto-ranging Fixed-Point), 是一类定点数能在进行定点数操作的过程中跟踪其表示范围的变化。</p>
<blockquote>
<div><p>注意：这部分代码的绝大多数都仍在开发中, API和函数都可能随着版本变化, 欢迎大家提出反馈意见</p>
</div></blockquote>
</section>
<section id="id29">
<h3>二、声明(Declaration)<a class="headerlink" href="#id29" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AFix</span></code>能用bit大小或指数来创建：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="nc">AFix</span><span class="p">.</span><span class="nc">U</span><span class="p">(</span><span class="mi">12</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">         </span><span class="c1">//U12.0</span>
<span class="nc">AFix</span><span class="p">.</span><span class="nc">UQ</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="c1">//U8.4</span>
<span class="nc">AFix</span><span class="p">.</span><span class="nc">U</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">  </span><span class="c1">//U8.4</span>
<span class="nc">AFix</span><span class="p">.</span><span class="nc">U</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w">   </span><span class="c1">//U8.4</span>
<span class="nc">AFix</span><span class="p">.</span><span class="nc">U</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w">    </span><span class="c1">//U8.-4</span>

<span class="nc">AFix</span><span class="p">.</span><span class="nc">S</span><span class="p">(</span><span class="mi">12</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">         </span><span class="c1">//S11 + sign</span>
<span class="nc">AFix</span><span class="p">.</span><span class="nc">SQ</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="c1">//S8.4 + sign</span>
<span class="nc">AFix</span><span class="p">.</span><span class="nc">S</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">  </span><span class="c1">//S8.3 + sign</span>
<span class="nc">AFix</span><span class="p">.</span><span class="nc">S</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w">   </span><span class="c1">//S8.4 + sign</span>
</pre></div>
</div>
<p>例如：</p>
<p>AFix.U(12 bits)的范围是0到4095.</p>
<p>AFix.SQ(8 bits, 4 bits)的范围是-4096(-256)到4095(255.9375)</p>
<p>AFix.U(8 exp, 4 exp)的范围所0到256.</p>
<p>定制化的<code class="docutils literal notranslate"><span class="pre">AFix</span></code>范围能通过直接初始化类来创建。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">AFix</span><span class="p">(</span><span class="kd">val</span><span class="w"> </span><span class="n">maxValue</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">,</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">minValue</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">,</span><span class="w"> </span><span class="kd">val</span><span class="w"> </span><span class="n">exp</span><span class="p">:</span><span class="w"> </span><span class="nc">ExpNumber</span><span class="p">)</span><span class="w"></span>

<span class="k">new</span><span class="w"> </span><span class="nc">AFix</span><span class="p">(</span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w">        </span><span class="c1">//[0 to 4096, 2^0]</span>
<span class="k">new</span><span class="w"> </span><span class="nc">AFix</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w">     </span><span class="c1">//[-256 to 256, 2^-2]</span>
<span class="k">new</span><span class="w"> </span><span class="nc">AFix</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w">          </span><span class="c1">//[8 to 16, 2^2]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">maxValue</span></code>和<code class="docutils literal notranslate"><span class="pre">minValue</span></code>存储着可表示的支持的整数值, 这些值代表乘以<code class="docutils literal notranslate"><span class="pre">2^exp</span></code>之后的真实定点值。</p>
<p><code class="docutils literal notranslate"><span class="pre">AFix.U(2</span> <span class="pre">exp,</span> <span class="pre">-1</span> <span class="pre">exp)</span></code>能表示：<code class="docutils literal notranslate"><span class="pre">0.0,</span> <span class="pre">0.5,</span> <span class="pre">1.0,</span> <span class="pre">1.5,</span> <span class="pre">2.0,</span> <span class="pre">2.5,</span> <span class="pre">3.0,</span> <span class="pre">3.5</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">AFix.U(2</span> <span class="pre">exp,</span> <span class="pre">-2</span> <span class="pre">exp)</span></code>能表示：<code class="docutils literal notranslate"><span class="pre">-2.0,</span> <span class="pre">-1.75,</span> <span class="pre">-1.5,</span> <span class="pre">-1.25,</span> <span class="pre">-1.0,</span> <span class="pre">-0.75,</span> <span class="pre">-0.5,</span> <span class="pre">-0.25,</span> <span class="pre">0.0,</span> <span class="pre">0.25,</span> <span class="pre">0.5,</span> <span class="pre">0.75,</span> <span class="pre">1.0,</span> <span class="pre">1.25,</span> <span class="pre">1.5,</span> <span class="pre">1.75</span></code></p>
<p>指数可以大于0并且能代表大于1的值。</p>
<p><code class="docutils literal notranslate"><span class="pre">AFix.S(2</span> <span class="pre">exp,</span> <span class="pre">1</span> <span class="pre">exp)</span></code>能代表：<code class="docutils literal notranslate"><span class="pre">-4,</span> <span class="pre">2,</span> <span class="pre">0,</span> <span class="pre">2</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">AFix(8,</span> <span class="pre">16,</span> <span class="pre">2</span> <span class="pre">exp)</span></code>能代表：<code class="docutils literal notranslate"><span class="pre">32,</span> <span class="pre">36,</span> <span class="pre">40,</span> <span class="pre">44,</span> <span class="pre">48,</span> <span class="pre">52,</span> <span class="pre">56,</span> <span class="pre">60,</span> <span class="pre">65</span></code></p>
<blockquote>
<div><p>备注：<code class="docutils literal notranslate"><span class="pre">AFix</span></code>会用5 bits来存储这个类型, 正如它的<code class="docutils literal notranslate"><span class="pre">maxValue</span></code>存储<code class="docutils literal notranslate"><span class="pre">16</span></code>。</p>
</div></blockquote>
</section>
<section id="mathematical-operations">
<h3>三、数学操作(Mathematical Operations)<a class="headerlink" href="#mathematical-operations" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AFix</span></code>在硬件层面支持加法(<code class="docutils literal notranslate"><span class="pre">+</span></code>), 减法(<code class="docutils literal notranslate"><span class="pre">-</span></code>), 和乘法(<code class="docutils literal notranslate"><span class="pre">*</span></code>)。除法(<code class="docutils literal notranslate"><span class="pre">/</span></code>), 和取模(<code class="docutils literal notranslate"><span class="pre">%</span></code>), 也都提供了但在硬件描述中不建议使用。</p>
<p><code class="docutils literal notranslate"><span class="pre">AFix</span></code>值的运算就好像一般的<code class="docutils literal notranslate"><span class="pre">Int</span></code>一样, 有符号和无符号数都是可执行的, 且有符号与无符号数之间没有数据类型的区别。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//整数和分数的扩充</span>
<span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">AFix</span><span class="p">.</span><span class="nc">U</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">          </span><span class="c1">// [   0 (  0.)     to  15 (15.  )]  4 bits, 2^0</span>
<span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">AFix</span><span class="p">.</span><span class="nc">UQ</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="c1">// [   0 (  0.)     to  15 ( 3.75)]  4 bits, 2^-2</span>
<span class="kd">val</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">                   </span><span class="c1">// [   0 (  0.)     to  77 (19.25)]  7 bits, 2^-2</span>
<span class="kd">val</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">AFix</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w"> </span><span class="c1">// [-  4 (- 1.25)   to   8 ( 2.00)]  5 bits, 2^-2</span>
<span class="kd">val</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="w">                   </span><span class="c1">// [-308 (-19.3125) to 616 (38.50)] 11 bits, 2^-4</span>

<span class="c1">//整数不扩充</span>
<span class="kd">val</span><span class="w"> </span><span class="n">aa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">AFix</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">// [8 to 16] 5 bits, 2^-4</span>
<span class="kd">val</span><span class="w"> </span><span class="n">bb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">AFix</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="c1">// [1 to 15] 4 bits, 2^-4</span>
<span class="kd">val</span><span class="w"> </span><span class="n">cc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aa</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bb</span><span class="w">                 </span><span class="c1">// [9 to 31] 5 bits, 2^-4</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">AFix</span></code>支持运算且不用表示数扩展范围, 这种特点是通过选择每个输入的一致的最大最小范围来实现的。</p>
<p><code class="docutils literal notranslate"><span class="pre">+|</span></code>无扩展加, <code class="docutils literal notranslate"><span class="pre">-|</span></code>无扩展减。</p>
</section>
<section id="inequality-operators">
<h3>四、不相等操作(Inequality Operators)<a class="headerlink" href="#inequality-operators" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AFix</span></code>支持标准比较操作</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="nc">A</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">B</span><span class="w"></span>
<span class="nc">A</span><span class="w"> </span><span class="o">=\=</span><span class="w"> </span><span class="nc">B</span><span class="w"></span>
<span class="nc">A</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nc">B</span><span class="w"></span>
<span class="nc">A</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nc">B</span><span class="w"></span>
<span class="nc">A</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nc">B</span><span class="w"></span>
<span class="nc">A</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nc">B</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p>注意：在编译时超出区间范围的操作会被优化掉！</p>
</div></blockquote>
</section>
<section id="bit-bitshifting">
<h3>五、Bit移位(Bitshifting)<a class="headerlink" href="#bit-bitshifting" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AFix</span></code>支持小数点和bit移位。</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>把小数点向左移动, 移动的距离加到指数上。<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>把小数点向右移动, 移动的距离从指数中减去。<code class="docutils literal notranslate"><span class="pre">&lt;&lt;|</span></code>把bits左移, 添加bits 0。<code class="docutils literal notranslate"><span class="pre">&gt;&gt;|</span></code>把bits右移, 移除bits</p>
</section>
<section id="saturation-and-rounding">
<h3>六、近似和饱和(Saturation and Rounding)<a class="headerlink" href="#saturation-and-rounding" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AFix</span></code>实现了饱和和所有普遍的近似方法。</p>
<p>饱和可以饱和到<code class="docutils literal notranslate"><span class="pre">AFix</span></code>值的可支持的值, 有很多辅助函数考虑了指数。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">AFix</span><span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w"> </span><span class="c1">// [0 to 63, 2^-2]</span>
<span class="n">a</span><span class="p">.</span><span class="n">sat</span><span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">                    </span><span class="c1">// [0 to 63, 2^-2]</span>
<span class="n">a</span><span class="p">.</span><span class="n">sat</span><span class="p">(</span><span class="mi">63</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w">            </span><span class="c1">// [0 to 31, 2^-2]</span>
<span class="n">a</span><span class="p">.</span><span class="n">sat</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">AFix</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="n">exp</span><span class="p">))</span><span class="w">  </span><span class="c1">// [0 to 31, 2^-2]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">AFix</span></code>近似模式：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// The following require exp &lt; 0</span>
<span class="p">.</span><span class="n">floor</span><span class="p">()</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="p">.</span><span class="n">truncate</span><span class="p">()</span><span class="w"></span>
<span class="p">.</span><span class="n">ceil</span><span class="p">()</span><span class="w"></span>
<span class="p">.</span><span class="n">floorToZero</span><span class="p">()</span><span class="w"></span>
<span class="p">.</span><span class="n">ceilToInf</span><span class="p">()</span><span class="w"></span>
<span class="c1">// The following require exp &lt; -1</span>
<span class="p">.</span><span class="n">roundHalfUp</span><span class="p">()</span><span class="w"></span>
<span class="p">.</span><span class="n">roundHalfDown</span><span class="p">()</span><span class="w"></span>
<span class="p">.</span><span class="n">roundHalfToZero</span><span class="p">()</span><span class="w"></span>
<span class="p">.</span><span class="n">roundHalfToInf</span><span class="p">()</span><span class="w"></span>
<span class="p">.</span><span class="n">roundHalfToEven</span><span class="p">()</span><span class="w"></span>
<span class="p">.</span><span class="n">roundHalfToOdd</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>这些近似模式的数学上的表述可以查看Wiki</p>
<p>所有这些模式都会产生一个指数部分为0的<code class="docutils literal notranslate"><span class="pre">AFix</span></code>。如果近似到不同的指数需要考虑移位或者用<code class="docutils literal notranslate"><span class="pre">truncated</span></code>赋值。</p>
</section>
<section id="assignment">
<h3>七、赋值(Assignment)<a class="headerlink" href="#assignment" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">AFix</span></code>会在赋值的时候自动地检查范围和精度。默认的, 把<code class="docutils literal notranslate"><span class="pre">AFix</span></code>赋值给另一个有更小的范围或精度的<code class="docutils literal notranslate"><span class="pre">AFix</span></code>会产生错误。</p>
<p><code class="docutils literal notranslate"><span class="pre">.truncated</span></code>函数用来控制如何给更小的数值类型赋值。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">truncated</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">saturation</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">overflow</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">rounding</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="nc">RoundType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RoundType</span><span class="p">.</span><span class="nc">FLOOR</span><span class="p">)</span><span class="w"></span>

<span class="k">def</span><span class="w"> </span><span class="nf">saturated</span><span class="p">():</span><span class="w"> </span><span class="nc">AFix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">truncated</span><span class="p">(</span><span class="n">saturation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">overflow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">RoundType</span></code></p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="nc">RoundType</span><span class="p">.</span><span class="nc">FLOOR</span><span class="w"></span>
<span class="nc">RoundType</span><span class="p">.</span><span class="nc">CEIL</span><span class="w"></span>
<span class="nc">RoundType</span><span class="p">.</span><span class="nc">FLOORTOZERO</span><span class="w"></span>
<span class="nc">RoundType</span><span class="p">.</span><span class="nc">CEILTOINF</span><span class="w"></span>
<span class="nc">RoundType</span><span class="p">.</span><span class="nc">ROUNDUP</span><span class="w"></span>
<span class="nc">RoundType</span><span class="p">.</span><span class="nc">ROUNDDOWN</span><span class="w"></span>
<span class="nc">RoundType</span><span class="p">.</span><span class="nc">ROUNDTOZERO</span><span class="w"></span>
<span class="nc">RoundType</span><span class="p">.</span><span class="nc">ROUNDTOINF</span><span class="w"></span>
<span class="nc">RoundType</span><span class="p">.</span><span class="nc">ROUNDTOEVEN</span><span class="w"></span>
<span class="nc">RoundType</span><span class="p">.</span><span class="nc">ROUNDTOODD</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">saturation</span></code>标志在赋值数据类型的时候增加逻辑产生饱和。</p>
<p><code class="docutils literal notranslate"><span class="pre">overflow</span></code>标志在近似后不检查范围区间直接赋值。</p>
<p>当用精度不同的数据去赋值的时候都需要近似处理。</p>
<div STYLE="page-break-after: always;"></div></section>
</section>
</section>
<section id="structuring">
<h1>结构(Structuring)<a class="headerlink" href="#structuring" title="Permalink to this heading"></a></h1>
<section id="component-and-hierarchy">
<h2>模块和层次(Component and hierarchy)<a class="headerlink" href="#component-and-hierarchy" title="Permalink to this heading"></a></h2>
<section id="id30">
<h3>一、简介(Introduction)<a class="headerlink" href="#id30" title="Permalink to this heading"></a></h3>
<p>正如VHDL和Verilog, 你可以在SpinalHDL中定义模块来进行层次化设计。然而, 在SpinalHDL中, 你不需要在例化的时候分配他们的端口。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">AdderCell</span><span class="p">()</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//声明外部端口, 推荐在Bundle中用io命名</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">cin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">sum</span><span class="p">,</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">//写一些逻辑</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">sum</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="n">^</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="n">^</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">cin</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">cout</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">cin</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">cin</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Adder</span><span class="p">(</span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="c1">//例化两个AdderCell</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">cell0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">AdderCell</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">cell1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">AdderCell</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">cell1</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">cin</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">cell0</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">cout</span><span class="w">       </span><span class="c1">//连接cell0的cout和cell1的cin</span>

<span class="w">    </span><span class="c1">//创建ArrayCell阵列的另一个例化例子</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">cellArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Array</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">width</span><span class="p">)(</span><span class="k">new</span><span class="w"> </span><span class="nc">AdderCell</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="n">cellArray</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">io</span><span class="p">.</span><span class="n">cin</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">cellArray</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">io</span><span class="p">.</span><span class="n">cout</span><span class="w">     </span><span class="c1">//连接cell0的cout和cell1的cin</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">Adder</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cell0_io_a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cell0_io_b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cell0_io_cin</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cell1_io_a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cell1_io_b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cellArray_0_io_a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cellArray_0_io_b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cellArray_0_io_cin</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cellArray_1_io_a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cellArray_1_io_b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cell0_io_sum</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cell0_io_cout</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cell1_io_sum</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cell1_io_cout</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cellArray_0_io_sum</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cellArray_0_io_cout</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cellArray_1_io_sum</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">cellArray_1_io_cout</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">AdderCell</span><span class="w"> </span><span class="n">cell0</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">io_a</span><span class="w">    </span><span class="p">(</span><span class="n">cell0_io_a</span><span class="w">   </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_b</span><span class="w">    </span><span class="p">(</span><span class="n">cell0_io_b</span><span class="w">   </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_cin</span><span class="w">  </span><span class="p">(</span><span class="n">cell0_io_cin</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_sum</span><span class="w">  </span><span class="p">(</span><span class="n">cell0_io_sum</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_cout</span><span class="w"> </span><span class="p">(</span><span class="n">cell0_io_cout</span><span class="p">)</span><span class="w">  </span><span class="c1">//o</span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">AdderCell</span><span class="w"> </span><span class="n">cell1</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">io_a</span><span class="w">    </span><span class="p">(</span><span class="n">cell1_io_a</span><span class="w">   </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_b</span><span class="w">    </span><span class="p">(</span><span class="n">cell1_io_b</span><span class="w">   </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_cin</span><span class="w">  </span><span class="p">(</span><span class="n">cell0_io_cout</span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_sum</span><span class="w">  </span><span class="p">(</span><span class="n">cell1_io_sum</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_cout</span><span class="w"> </span><span class="p">(</span><span class="n">cell1_io_cout</span><span class="p">)</span><span class="w">  </span><span class="c1">//o</span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">AdderCell</span><span class="w"> </span><span class="n">cellArray_0</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">io_a</span><span class="w">    </span><span class="p">(</span><span class="n">cellArray_0_io_a</span><span class="w">   </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_b</span><span class="w">    </span><span class="p">(</span><span class="n">cellArray_0_io_b</span><span class="w">   </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_cin</span><span class="w">  </span><span class="p">(</span><span class="n">cellArray_0_io_cin</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_sum</span><span class="w">  </span><span class="p">(</span><span class="n">cellArray_0_io_sum</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_cout</span><span class="w"> </span><span class="p">(</span><span class="n">cellArray_0_io_cout</span><span class="p">)</span><span class="w">  </span><span class="c1">//o</span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">AdderCell</span><span class="w"> </span><span class="n">cellArray_1</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">io_a</span><span class="w">    </span><span class="p">(</span><span class="n">cellArray_1_io_a</span><span class="w">   </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_b</span><span class="w">    </span><span class="p">(</span><span class="n">cellArray_1_io_b</span><span class="w">   </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_cin</span><span class="w">  </span><span class="p">(</span><span class="n">cellArray_0_io_cout</span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_sum</span><span class="w">  </span><span class="p">(</span><span class="n">cellArray_1_io_sum</span><span class="w"> </span><span class="p">),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_cout</span><span class="w"> </span><span class="p">(</span><span class="n">cellArray_1_io_cout</span><span class="p">)</span><span class="w">  </span><span class="c1">//o</span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>

<span class="c1">//AdderCell replaced by AdderCell</span>

<span class="c1">//AdderCell replaced by AdderCell</span>

<span class="c1">//AdderCell replaced by AdderCell</span>

<span class="k">module</span><span class="w"> </span><span class="n">AdderCell</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_a</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_b</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_cin</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">io_sum</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">io_cout</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>


<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">io_a</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">io_b</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">io_cin</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_cout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">io_a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">io_b</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">io_a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">io_cin</span><span class="p">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">io_b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">io_cin</span><span class="p">));</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">io</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">Bundle</span> <span class="pre">{...}</span></code>推荐在Bundle中声明了名为<code class="docutils literal notranslate"><span class="pre">io</span></code>的外部端口。如果把bundle命名为<code class="docutils literal notranslate"><span class="pre">io</span></code>, SpinalHDL会检查其元素是否都定义为输入或输出。</p>
</div></blockquote>
<blockquote>
<div><p>如果你更喜欢, 你也可以用<code class="docutils literal notranslate"><span class="pre">Module</span></code>语句替代<code class="docutils literal notranslate"><span class="pre">Component</span></code>(他们本质上一样)</p>
</div></blockquote>
</section>
<section id="input-output-definition">
<h3>二、输入/输出定义(Input/output definition)<a class="headerlink" href="#input-output-definition" title="Permalink to this heading"></a></h3>
<p>定义输入输出的语句如下所示：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">语句</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">in Bool()/out Bool()</td>
<td style="text-align: center;">创建输入Bool类型/输出Bool类型</td>
<td style="text-align: center;">Bool</td>
</tr>
<tr>
<td style="text-align: center;">in/out Bits/UInt/SInt[(x bits)]</td>
<td style="text-align: center;">创建对应类型的输入/输出</td>
<td style="text-align: center;">Bits/UInt/SInt</td>
</tr>
<tr>
<td style="text-align: center;">in/out(T)</td>
<td style="text-align: center;">对于其他数据类型, 需要加括号, 这是Scala的约束</td>
<td style="text-align: center;">T</td>
</tr>
<tr>
<td style="text-align: center;">master/slave(T)</td>
<td style="text-align: center;">这条语句需要spinal.lib库的支持(如果你在对象里只用<code>slave</code>语句, 用spinal.lib.slave就可以)T应该加上IMasterSlave-这里有一些doc做解释。你也可以不带括号, maste T也可以</td>
<td style="text-align: center;">T</td>
</tr>
</tbody>
</table><p>关于模块的互联还有一些规则如下：</p>
<ul class="simple">
<li><p>模块能读取output和子模块的input信号。</p></li>
<li><p>模块能读取他们自己output端口的值(不像VHDL)。</p></li>
</ul>
<blockquote>
<div><p>备注：如出于某些原因需要从本层次外很远的地方读取信号(比如debugg或临时补丁), 你可以用<code class="docutils literal notranslate"><span class="pre">some.where.else.theSignal.pull()</span></code>实现。</p>
</div></blockquote>
</section>
<section id="pruned-signals">
<h3>三、信号剪枝(Pruned signals)<a class="headerlink" href="#pruned-signals" title="Permalink to this heading"></a></h3>
<p>SpinalHDL会产生所有命名了的信号以及他们的依赖关系, 然而所有无用的/未命名的/0宽度的信号会在RTL产生时被移除。</p>
<p>你可以在生成的<code class="docutils literal notranslate"><span class="pre">SpinalReport</span></code>对象中用<code class="docutils literal notranslate"><span class="pre">printPruned</span></code>和<code class="docutils literal notranslate"><span class="pre">printPrunedIO</span></code>函数来产生所有被移除的和无用信号的列表：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">unusedSignal</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">unusedSignal2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">unusedSignal2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">unusedSignal</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">object</span><span class="w"> </span><span class="nc">Main</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nc">SpinalVhdl</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">TopLevel</span><span class="p">).</span><span class="n">printPruned</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="c1">//这会报告：</span>
<span class="w">        </span><span class="c1">//  [Warning] Unused wire detected : toplevel/unusedSignal : UInt[8 bits]</span>
<span class="w">        </span><span class="c1">//  [Warning] Unused wire detected : toplevel/unusedSignal2 : UInt[8 bits]    </span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="generic-vhdl-parameter-verilog">
<h3>四、参数化硬件电路(”Generic”——VHDL, “Parameter”——Verilog)<a class="headerlink" href="#generic-vhdl-parameter-verilog" title="Permalink to this heading"></a></h3>
<p>如果你想要参数化模块, 你可以在模块生成的地方通过如下方式给定参数：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyAdder</span><span class="p">(</span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="nc">BitCount</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">object</span><span class="w"> </span><span class="nc">Main</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nc">SpinalVhdl</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">MyAdder</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果有很多参数, 以一种特定的配置类来参数化很方便：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MySocConfig</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">axiFrequency</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="nc">HertzNumber</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">onChipRamSize</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">cpu</span><span class="w">             </span><span class="p">:</span><span class="w"> </span><span class="nc">RiscCoreConfig</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">iCache</span><span class="w">          </span><span class="p">:</span><span class="w"> </span><span class="nc">InstructionCacheConfig</span><span class="p">)</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">MySoc</span><span class="p">(</span><span class="n">config</span><span class="p">:</span><span class="w"> </span><span class="nc">MySocConfig</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>你可以在配置中使用函数, 以及对配置属性设置要求(requirements)：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MyBusConfig</span><span class="p">(</span><span class="n">addressWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">dataWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">bytePerWord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dataWidth</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">addressType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">addressWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">dataType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">require</span><span class="p">(</span><span class="n">dataWidth</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">dataWidth</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Data width must be 32 or 64&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="synthesized-component-names">
<h3>五、综合模块名(Synthesized component names)<a class="headerlink" href="#synthesized-component-names" title="Permalink to this heading"></a></h3>
<p>在module中, 每个模块都有名字, 叫做“不完全的名字(partial name)”。“全名(full name)”通过用“_”连接每个模块的父类名字得到, 例如：<code class="docutils literal notranslate"><span class="pre">io_clockDomain_reset</span></code>。你可以用<code class="docutils literal notranslate"><span class="pre">setName</span></code>用定制化的名字替代原始名。这在与外部模块用接口链接的时候非常有用。类似的方法相对应的还有<code class="docutils literal notranslate"><span class="pre">getName</span></code>, <code class="docutils literal notranslate"><span class="pre">setPartialName</span></code>, <code class="docutils literal notranslate"><span class="pre">getPartialName</span></code>。</p>
<p>在综合时, 每个模块的名字由Scala的类定义得到, 你也可以使用<code class="docutils literal notranslate"><span class="pre">setDefinitionName</span></code>将其替换。</p>
</section>
</section>
<section id="area">
<h2>区域(Area)<a class="headerlink" href="#area" title="Permalink to this heading"></a></h2>
<section id="id31">
<h3>一、简介(Introduction)<a class="headerlink" href="#id31" title="Permalink to this heading"></a></h3>
<p>有时, 用<code class="docutils literal notranslate"><span class="pre">Component</span></code>定义逻辑可能是致命的, 因为你：</p>
<ul class="simple">
<li><p>需要定义所有的生成器参数和IO(冗长的, 重复的)</p></li>
<li><p>分隔你的代码</p></li>
</ul>
<p>在这种时候你可以用<code class="docutils literal notranslate"><span class="pre">Area</span></code>来定义一组信号/逻辑：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">UartCtrl</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">timer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">tick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">100</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">tickCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">           </span><span class="c1">//参考timer区域的tick</span>
<span class="w">            </span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">stateMachine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:(有问题，为什么counter这么写)</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">UartCtrl</span><span class="w"> </span><span class="n">myUart</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">clk</span><span class="w">   </span><span class="p">(</span><span class="n">clk</span><span class="w">  </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w">  </span><span class="c1">//i</span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>

<span class="k">module</span><span class="w"> </span><span class="n">UartCtrl</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">timer_counter</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">timer_tick</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">tickCounter_value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">tickCounter_reset</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">timer_tick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">timer_counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">tickCounter_reset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">timer_counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">timer_counter</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">8&#39;h01</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">timer_tick</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">timer_counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h64</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">timer_tick</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">tickCounter_value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">tickCounter_value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b001</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">tickCounter_reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">tickCounter_value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p>备注：在VHDL和Verilog中, 有时候前缀可以用来把变量拆分成逻辑块, 在SpinalHDL中可以用<code class="docutils literal notranslate"><span class="pre">Area</span></code>实现</p>
</div></blockquote>
<blockquote>
<div><p>备注：ClockingArea是一种特殊的<code class="docutils literal notranslate"><span class="pre">Area</span></code>允许你用给定的<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>定义一块硬件电路。</p>
</div></blockquote>
</section>
</section>
<section id="function">
<h2>函数(Function)<a class="headerlink" href="#function" title="Permalink to this heading"></a></h2>
<section id="id32">
<h3>一、简介(Introduction)<a class="headerlink" href="#id32" title="Permalink to this heading"></a></h3>
<p>用Scala函数产生硬件的方式与VHDL/Verilog中非常不同, 原因如下：</p>
<ul class="simple">
<li><p>你可以在他们内部例化寄存器、组合逻辑和模块。</p></li>
<li><p>你不需要使用<code class="docutils literal notranslate"><span class="pre">process</span></code>/<code class="docutils literal notranslate"><span class="pre">&#64;always</span></code>模块, 因此也不会限制你对信号声明的范围。</p></li>
<li><p>所有事情都是通过引用传递, 这使得各种操作都便于控制。<br>例如你可以把总线作为变量传递到函数中, 这样函数就可以在内部读写总线。你也可以返回一个模块, 一个总线, 或是任何来自于Scala世界的东西。</p></li>
</ul>
</section>
<section id="rga-rgb-to-grey">
<h3>二、RGA到灰度(RGB to grey)<a class="headerlink" href="#rga-rgb-to-grey" title="Permalink to this heading"></a></h3>
<p>例如, 如果想要把红/绿/蓝颜色通过系数转化为灰度, 可以用如下函数来实现：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//输入RGB色彩</span>
<span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="c1">//定义灰度系数乘的函数</span>
<span class="k">def</span><span class="w"> </span><span class="nf">coef</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="p">,</span><span class="w"> </span><span class="n">by</span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">):</span><span class="w"> </span><span class="nc">UInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nc">U</span><span class="p">((</span><span class="mi">255</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">by</span><span class="p">).</span><span class="n">toInt</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>

<span class="c1">//计算灰度</span>
<span class="kd">val</span><span class="w"> </span><span class="n">gray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">coef</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">coef</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="mf">0.4f</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">coef</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_gray</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_gray_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_gray_2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_gray_3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_gray_4</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_gray_5</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_gray_6</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">r</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">g</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">gray</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_gray_1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_zz_gray_3</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gray_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_gray_2</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="mh">8</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gray_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">8&#39;h4c</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gray_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_gray_4</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="mh">8</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gray_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">8&#39;h66</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gray_5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_gray_6</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="mh">8</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gray_6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">8&#39;h4c</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">gray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_gray</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_zz_gray_5</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="validready-valid-ready-payload-bus">
<h3>三、Valid和Ready负载总线(Valid Ready Payload bus)<a class="headerlink" href="#validready-valid-ready-payload-bus" title="Permalink to this heading"></a></h3>
<p>例如, 如果你用<code class="docutils literal notranslate"><span class="pre">valid</span></code>, <code class="docutils literal notranslate"><span class="pre">ready</span></code>和<code class="docutils literal notranslate"><span class="pre">payload</span></code>信号定义了一条简单的总线, 你可以在其中定义一些常用的函数。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MyBus</span><span class="p">(</span><span class="n">payloadWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">payloadWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">//在master模式中定义数据的方向</span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="p">(</span><span class="n">valid</span><span class="p">,</span><span class="w"> </span><span class="n">payload</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">in</span><span class="p">(</span><span class="n">ready</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//把that链接到this上</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">&lt;&lt;</span><span class="p">(</span><span class="n">that</span><span class="p">:</span><span class="w"> </span><span class="nc">MyBus</span><span class="p">):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">this</span><span class="p">.</span><span class="n">valid</span><span class="w">   </span><span class="o">:=</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="n">valid</span><span class="w"></span>
<span class="w">        </span><span class="n">that</span><span class="p">.</span><span class="n">ready</span><span class="w">   </span><span class="o">:=</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">ready</span><span class="w"></span>
<span class="w">        </span><span class="bp">this</span><span class="p">.</span><span class="n">payload</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="n">payload</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//把this连接到FIFO的输入, 返回FIFO的输出</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">queue</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">):</span><span class="w"> </span><span class="nc">MyBus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">fifo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">MyBusFifo</span><span class="p">(</span><span class="n">payloadWidth</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">fifo</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="bp">this</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fifo</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyBusFifo</span><span class="p">(</span><span class="n">payloadWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">push</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">MyBus</span><span class="p">(</span><span class="n">payloadWidth</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">pop</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">MyBus</span><span class="p">(</span><span class="n">payloadWidth</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Mem</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="n">payloadWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:(有问题，this和that的作用还没搞懂)</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">test_io_push_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">test_io_push_payload</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">test_io_pop_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">test_io_push_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">test_io_pop_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">test_io_pop_payload</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">MyBusFifo</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">io_push_valid</span><span class="w">   </span><span class="p">(</span><span class="n">test_io_push_valid</span><span class="w">        </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_push_ready</span><span class="w">   </span><span class="p">(</span><span class="n">test_io_push_ready</span><span class="w">        </span><span class="p">),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_push_payload</span><span class="w"> </span><span class="p">(</span><span class="n">test_io_push_payload</span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_pop_valid</span><span class="w">    </span><span class="p">(</span><span class="n">test_io_pop_valid</span><span class="w">         </span><span class="p">),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_pop_ready</span><span class="w">    </span><span class="p">(</span><span class="n">test_io_pop_ready</span><span class="w">         </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_pop_payload</span><span class="w">  </span><span class="p">(</span><span class="n">test_io_pop_payload</span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w">  </span><span class="c1">//o</span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>

<span class="k">module</span><span class="w"> </span><span class="n">MyBusFifo</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_push_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">io_push_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_push_payload</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">io_pop_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_pop_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_pop_payload</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">7</span><span class="p">];</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="clock-domains">
<h2>时钟域(Clock domains)<a class="headerlink" href="#clock-domains" title="Permalink to this heading"></a></h2>
<section id="id33">
<h3>一、简介(Introduction)<a class="headerlink" href="#id33" title="Permalink to this heading"></a></h3>
<p>在SpinalHDL中, 时钟和复位信号能结合起来构成时钟域(clock domain)。时钟域可以应用于设计的某些区域中, 例化在这些区域中的所有同步单元都会隐式地使用这些时钟域。</p>
<p>时钟域的应用的工作模式类似于堆栈, 这意味着你在一个给定的时钟域中仍然可以在本地施加另一个时钟域。</p>
<p>需要注意的是, 一个寄存器在它被创建的时候捕捉时钟域, 而非它被赋值的时候。所以请确保在你所希望的<code class="docutils literal notranslate"><span class="pre">ClockingArea</span></code>中创建寄存器。</p>
</section>
<section id="instantiation">
<h3>二、例化(Instantiation)<a class="headerlink" href="#instantiation" title="Permalink to this heading"></a></h3>
<p>定义时钟域的语句如下所示(使用EBNF语句)：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="nc">ClockDomain</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">clock</span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="w">    </span><span class="p">[,</span><span class="w"> </span><span class="n">reset</span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[,</span><span class="w"> </span><span class="n">softReset</span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[,</span><span class="w"> </span><span class="n">clockEnable</span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[,</span><span class="w"> </span><span class="n">frequency</span><span class="p">:</span><span class="w"> </span><span class="nc">IClockDomainFrequency</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[,</span><span class="w"> </span><span class="n">config</span><span class="p">:</span><span class="w"> </span><span class="nc">ClockDomainConfig</span><span class="p">]</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>在这个定义中包含五个参数：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">变量</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">默认</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>clock</code></td>
<td style="text-align: center;">定义该时钟域的时钟</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><code>reset</code></td>
<td style="text-align: center;">复位信号。如果存在需要复位信号但没有提供它的时钟域的寄存器, 就会报错</td>
<td style="text-align: center;">null</td>
</tr>
<tr>
<td style="text-align: center;"><code>softReset</code></td>
<td style="text-align: center;">推断额外同步复位的复位</td>
<td style="text-align: center;">null</td>
</tr>
<tr>
<td style="text-align: center;"><code>clockEnable</code></td>
<td style="text-align: center;">该信号的目的在于取消整个时钟域的时钟, 而不用在每个同步单元上手动取消</td>
<td style="text-align: center;">null</td>
</tr>
<tr>
<td style="text-align: center;"><code>frequency</code></td>
<td style="text-align: center;">允许你在给定的时钟域中设定频率, 并且之后在设计中读取</td>
<td style="text-align: center;">UnknownFrequency</td>
</tr>
<tr>
<td style="text-align: center;"><code>config</code></td>
<td style="text-align: center;">设定信号的极性和reset的实质</td>
<td style="text-align: center;">Current config</td>
</tr>
</tbody>
</table><p>以下例子给出在设计中定义特定时钟域的实例：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">coreClock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">coreReset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>

<span class="c1">//定义新的时钟域</span>
<span class="kd">val</span><span class="w"> </span><span class="n">coreClockDomain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">(</span><span class="n">coreClock</span><span class="p">,</span><span class="w"> </span><span class="n">coreReset</span><span class="p">)</span><span class="w"></span>

<span class="c1">//在设计的某个区域内应用该时钟域</span>
<span class="kd">val</span><span class="w"> </span><span class="n">coreArea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockingArea</span><span class="p">(</span><span class="n">coreClockDomain</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">coreClockedRegister</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">coreClock</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">coreReset</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">coreArea_coreClockedRegister</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">counter</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">coreClock</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">coreReset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">coreReset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">coreArea_coreClockedRegister</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">io_cond1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">coreArea_coreClockedRegister</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0010</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>
</pre></div>
</div>
<p>当一个<em>Area</em>不需要时钟时(门控), 也可以直接应用时钟域：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Counters</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">enable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">freeCount</span><span class="p">,</span><span class="w"> </span><span class="n">gatedCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">freeCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">CounterFreeRun</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">freeCount</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">freeCounter</span><span class="p">.</span><span class="n">value</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">gatedClk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">readClockWire</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">enable</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">gated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">(</span><span class="n">gatedClk</span><span class="p">,</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">readResetWire</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//这里在门控加法器中应用门控时钟域</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">gatedCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gated</span><span class="p">(</span><span class="nc">CounterFreeRun</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">gatedCount</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">gatedCounter</span><span class="p">.</span><span class="n">value</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">Counters</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_enable</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_freeCount</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_gatedCount</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_freeCounter_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_freeCounter_valueNext_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_gatedCounter_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_gatedCounter_valueNext_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">freeCounter_willIncrement</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">freeCounter_willClear</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">freeCounter_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">freeCounter_value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">freeCounter_willOverflowIfInc</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">freeCounter_willOverflow</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">gatedClk</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">gatedCounter_willIncrement</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">gatedCounter_willClear</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">gatedCounter_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">gatedCounter_value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">gatedCounter_willOverflowIfInc</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">gatedCounter_willOverflow</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_freeCounter_valueNext_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">freeCounter_willIncrement</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_freeCounter_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">3</span><span class="mi">&#39;d0</span><span class="p">,</span><span class="w"> </span><span class="n">_zz_freeCounter_valueNext_1</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gatedCounter_valueNext_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gatedCounter_willIncrement</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gatedCounter_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">3</span><span class="mi">&#39;d0</span><span class="p">,</span><span class="w"> </span><span class="n">_zz_gatedCounter_valueNext_1</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">freeCounter_willClear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">freeCounter_willOverflowIfInc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">freeCounter_value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b1111</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">freeCounter_willOverflow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">freeCounter_willOverflowIfInc</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">freeCounter_willIncrement</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">freeCounter_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">freeCounter_value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_zz_freeCounter_valueNext</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">freeCounter_willClear</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">freeCounter_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">freeCounter_willIncrement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_freeCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">freeCounter_value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">gatedClk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">clk</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">io_enable</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">gatedCounter_willClear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">gatedCounter_willOverflowIfInc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">gatedCounter_value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b1111</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">gatedCounter_willOverflow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">gatedCounter_willOverflowIfInc</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">gatedCounter_willIncrement</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">gatedCounter_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">gatedCounter_value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_zz_gatedCounter_valueNext</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">gatedCounter_willClear</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">gatedCounter_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">gatedCounter_willIncrement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_gatedCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gatedCounter_value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">freeCounter_value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">freeCounter_value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">freeCounter_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">gatedClk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">gatedCounter_value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">gatedCounter_value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">gatedCounter_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
<ol class="simple">
<li><p>配置(Configuration)</p></li>
</ol>
<p>除了生成器参数(constructor parameters), 以下针对每个时钟域的设置可以通过<code class="docutils literal notranslate"><span class="pre">ClockDomainConfig</span></code>类进行配置：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">性质</th>
<th style="text-align: center;">有效值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>clockEdge</code></td>
<td style="text-align: center;"><code>RISING</code>, <code>FALLING</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>resetKind</code></td>
<td style="text-align: center;">在一些FPGA(FF的值通过bitstream加载)中支持的<code>ASYNC</code>, <code>SYNC</code>和<code>BOOT</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>resetActiveLevel</code></td>
<td style="text-align: center;"><code>HIGH</code>, <code>LOW</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>softResetActiveLevel</code></td>
<td style="text-align: center;"><code>HIGH</code>, <code>LOW</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>clockEnableActiveLevel</code></td>
<td style="text-align: center;"><code>HIGH</code>, <code>LOW</code></td>
</tr>
</tbody>
</table><div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CustomClockExample</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">clk</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">resetn</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//配置时钟域</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">myClockDomain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">clock</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">reset</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">resetn</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">config</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomainConfig</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">clockEdge</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="nc">RISING</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">resetKind</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="nc">ASYNC</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">resetActiveLevel</span><span class="w"> </span><span class="o">=</span><span class="nc">LOW</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//定义用myClockDomain的区域</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">myArea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockingArea</span><span class="p">(</span><span class="n">myClockDomain</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">myReg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">myReg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">myReg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="w">        </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">myReg</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">CustomClockExample</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_resetn</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_result</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myArea_myReg</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myArea_myReg</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">io_clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">negedge</span><span class="w"> </span><span class="n">io_resetn</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">io_resetn</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">myArea_myReg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0111</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">myArea_myReg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">myArea_myReg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0001</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>
</pre></div>
</div>
<p>默认地, 一个<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>应用于整个设计, 这个全局时钟的默认配置如下：</p>
<ul class="simple">
<li><p>Clock: 上升沿</p></li>
<li><p>Reset: asynchronous, active high</p></li>
<li><p>没有时钟使能</p></li>
</ul>
<p>对应如下的<code class="docutils literal notranslate"><span class="pre">ClockDomainConfig</span></code>：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">defaultCC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomainConfig</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">clockEdge</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="nc">RISING</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">resetKind</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="nc">ASYNC</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">resetActiveLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">HIGH</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<ol>
<li><p>内部时钟(Internal clock)</p>
<p>创建时钟域的另一种语句如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">internal</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">config</span><span class="p">:</span><span class="w"> </span><span class="nc">ClockDomainConfig</span><span class="p">,</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">withReset</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">withSoftReset</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">withClockEnable</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">frequency</span><span class="p">:</span><span class="w"> </span><span class="nc">IClockDomainFrequency</span><span class="p">]</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>该定义有以下六个参数：</p>
</li>
</ol>
<pre><code>|       变量        |               描述               |       默认       |
| :---------------: | :------------------------------: | :--------------: |
|      `name`       |       clk和reset信号的名字       |                  |
|     `config`      | 给定信号的极性以及复位信号的特点 |  Current config  |
|    `withReset`    |           增加复位信号           |       true       |
|  `withSoftReset`  |         增加软件复位信号         |      false       |
| `withClockEnable` |           增加时钟使能           |      false       |
|    `frequency`    |            时钟域频率            | UnknownFrequency |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>这种方法的优势在于用已知的/给定的名字创建时钟域和复位信号而非继承一个时钟域。

一旦时钟域被创建, 你需要给`ClockDomain`的信号赋值, 赋值方式如下：

```Scala
class InternalClockWithPllExample extends Component {
    val io = new Bundle {
        val clk100M = in Bool()
        val aReset  = in Bool()
        val result  = out UInt(4 bits)
    }
    //myClockDomain.clock会被命名为myClockName_clk
    //myClockDomain.reset会被命名为myClockName_reset
    val myClockDomain = ClockDomain.interna(&quot;myClockName&quot;)

    //例化PLL(可能是黑盒)
    val pll = new Pll()
    pll.io.clkIn := io.clk100M

    //给myClockDomain信号赋值
    myClockDomain.clock := pll.io.clockOut
    myClockDomain.reset := io.aReset || !pll.io     //有问题：这里缺少语句

    //之后在myCLockDomain可以任你发挥
    val myArea = new ClockingArea(myClockDomain) {
        val myReg = Reg(UInt(4 bits)) init(7)
        myReg := myReg + 1

        io.result := myReg
    }

}
```
</pre></div>
</div>
<ol>
<li><p>外部时钟(External clock)</p>
<p>你可以定义一个在由外部驱动的时钟域, 这个外部驱动可能来自于任何地方。它会自动在顶层给所有这些时序同步单元增加时钟和复位wire。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">external</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">config</span><span class="p">:</span><span class="w"> </span><span class="nc">ClockDomainConfig</span><span class="p">,</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">withReset</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">withSoftReset</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">withClockEnable</span><span class="p">:</span><span class="w"> </span><span class="nc">Bollean</span><span class="p">,</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">frequency</span><span class="p">:</span><span class="w"> </span><span class="nc">IClockDomainFrequency</span><span class="p">]</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ClockDomain.external</span></code>函数的变量和<code class="docutils literal notranslate"><span class="pre">ClockDomainin.internal</span></code>函数中完全一样。以下是使用<code class="docutils literal notranslate"><span class="pre">ClockDomain.external</span></code>的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ExternalClockExample</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//在顶层你有两个信号： myClockName_clk和myClockName_reset</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">myClockDomain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">external</span><span class="p">(</span><span class="s">&quot;myClockName&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">myArea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockingArea</span><span class="p">(</span><span class="n">myClockDomain</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">myReg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">myReg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">myReg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="w">        </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">myReg</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">CustomClockExample</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">io_clk</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">io_resetn</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_result</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">myClockName_clk</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">myClockName_reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">tt_io_result</span><span class="p">;</span><span class="w"></span>

<span class="n">ExternalClockExample</span><span class="w"> </span><span class="n">tt</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">io_result</span><span class="w">         </span><span class="p">(</span><span class="n">tt_io_result</span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">myClockName_clk</span><span class="w">   </span><span class="p">(</span><span class="n">myClockName_clk</span><span class="w">  </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">myClockName_reset</span><span class="w"> </span><span class="p">(</span><span class="n">myClockName_reset</span><span class="p">)</span><span class="w">  </span><span class="c1">//i</span>
<span class="p">);</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>

<span class="k">module</span><span class="w"> </span><span class="n">ExternalClockExample</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_result</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">myClockName_clk</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">myClockName_reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">myArea_myReg</span><span class="p">;</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">io_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myArea_myReg</span><span class="p">;</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">myClockName_clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">myClockName_reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">myClockName_reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">myArea_myReg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0111</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">myArea_myReg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">myArea_myReg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0001</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>


<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>HDL生成中的信号优先级(Signal priorities in HDL generation)</p>
<p>在当前版本, reset和时钟使能信号有不同的性质, 其顺序是：<code class="docutils literal notranslate"><span class="pre">asyncReset</span></code>, <code class="docutils literal notranslate"><span class="pre">clockEnable</span></code>, <code class="docutils literal notranslate"><span class="pre">syncReset</span></code>和<code class="docutils literal notranslate"><span class="pre">softReset</span></code>。</p>
<p>请注意<code class="docutils literal notranslate"><span class="pre">clockEnable</span></code>比<code class="docutils literal notranslate"><span class="pre">syncReset</span></code>的优先级更高。如果在没有时钟使能的时候进行同步复位(尤其是在仿真的开始), 门寄存器不会被复位。</p>
<p>这里有一个例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">clockedArea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockEnableArea</span><span class="p">(</span><span class="n">clockEnable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这会产生如下VerilogHDL代码：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">clockedArea_newClockEnable</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">resetn</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">clockedArea_reg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">clockedArea_reg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_input</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p>如果这个行为是有问题的, 一个变通方法是用<code class="docutils literal notranslate"><span class="pre">when</span></code>语句而不是<code class="docutils literal notranslate"><span class="pre">ClockDomain.enable</span></code>作为时钟使能, 这在未来会得到改进。</p>
</div></blockquote>
</li>
<li><p>上下文(Context)</p>
<p>无论在哪, 你都可以通过调用<code class="docutils literal notranslate"><span class="pre">ClockDomain.current</span></code>取回时钟域。</p>
<p>返回的<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>实例有如下可以调用的函数：</p>
</li>
</ol>
<pre><code>|       函数名        |             描述             | 返回类型 |
| :-----------------: | :--------------------------: | :------: |
| frequency.getValue  |        返回时钟域频率        |  Double  |
|      hasReset       |   返回时钟域是否有复位信号   | Boolean  |
|    hasSoftReset     | 返回时钟域是否有软件复位信号 | Boolean  |
|   hasClockEnable    | 返回时钟域是否有时钟使能信号 | Boolean  |
|    readClockWire    |    返回时钟信号派生的信号    |   Bool   |
|    readResetWire    |  返回软件复位信号派生的信号  |   Bool   |
|  readSoftResetWire  |    返回复位信号派生的信号    |   Bool   |
| readClockEnableWire |  返回时钟使能信号派生的信号  |   Bool   |
|    isResetActive    |      当复位有效返回True      |   Bool   |
|  isSoftResetActive  |    当软件复位有效返回True    |   Bool   |
| isClockEnableActive |    当时钟使能有效返回True    |   Bool   |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如下是一个例子, UART控制器使用它的频率规格设置始终分频：

```Scala
val coreClockDomain = ClockDomain(coreClock, coreReset, frequency=FixedFrequency(100e6))

val coreArea = new ClockingArea(coreClockDomain) {
    val ctrl = new UartCtrl()
    ctrl.io.config.clockDivider := (coreClk.frequency.getValue / 57.6e3 / 8).toInt
}
```
</pre></div>
</div>
</section>
<section id="clock-domain-crossing">
<h3>三、跨时钟域(Clock domain crossing)<a class="headerlink" href="#clock-domain-crossing" title="Permalink to this heading"></a></h3>
<p>SpinalHDL会在编译时检查有没有未定义的跨时钟域的信号的读取, 如果你想要读取另一个<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>区域的信号, 你应该给目标信号增加<code class="docutils literal notranslate"><span class="pre">crossClockDomain</span></code>标签, 如下例所示：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//             _____                        _____             _____</span>
<span class="c1">//            |     |  (crossClockDomain)  |     |           |     |</span>
<span class="c1">//  dataIn --&gt;|     |---------------------&gt;|     |----------&gt;|     |--&gt; dataOut</span>
<span class="c1">//            | FF  |                      | FF  |           | FF  |</span>
<span class="c1">//  clkA   --&gt;|     |              clkB --&gt;|     |   clkB --&gt;|     |</span>
<span class="c1">//  rstA   --&gt;|_____|              rstB --&gt;|_____|   rstB --&gt;|_____|</span>

<span class="c1">//补全时钟和复位引脚所通过哪个模块IO给定的</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CrossingExample</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">clkA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">rstA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>

<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">clkB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">rstB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>

<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">dataIn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">dataOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//clkA时钟域下的样本输入</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">area_clkA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockingArea</span><span class="p">(</span><span class="nc">ClockDomain</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">clkA</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">rstA</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">dataIn</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//两级寄存器避免亚稳态</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">area_clkB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockingArea</span><span class="p">(</span><span class="nc">ClockDomain</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">clkB</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">rstB</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">buf0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">area_clkA</span><span class="p">.</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"> </span><span class="n">addTag</span><span class="p">(</span><span class="n">crossClockDomain</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">buf1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">buf0</span><span class="p">)</span><span class="w">          </span><span class="n">init</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">dataOut</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">area_clkB</span><span class="p">.</span><span class="n">buf1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">//另一种时钟域以参数方式给定的实现方式</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CrossingExample</span><span class="p">(</span><span class="n">clkA</span><span class="p">:</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">,</span><span class="w"> </span><span class="n">clkB</span><span class="p">:</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">dataIn</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">dataOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//clkA时钟域下的样本输入</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">area_clkA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockingArea</span><span class="p">(</span><span class="n">clkA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">dataIn</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//两级寄存器避免亚稳态</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">area_clkB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockingArea</span><span class="p">(</span><span class="n">clkB</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">buf0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">area_clkA</span><span class="p">.</span><span class="n">reg</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"> </span><span class="n">addTap</span><span class="p">(</span><span class="n">crossClockDomain</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">buf1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">buf0</span><span class="p">)</span><span class="w">          </span><span class="n">init</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">dataOut</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">area_clkB</span><span class="p">.</span><span class="n">buf1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">CrossingExample</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_clkA</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_rstA</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_clkB</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_rstB</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_dataIn</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">io_dataOut</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">area_clkA_reg</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="n">async_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="kt">reg</span><span class="w">                 </span><span class="n">area_clkB_buf0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">area_clkB_buf1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_dataOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">area_clkB_buf1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">io_clkA</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">io_rstA</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_rstA</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">area_clkA_reg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">area_clkA_reg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_dataIn</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">io_clkB</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">io_rstB</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_rstB</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">area_clkB_buf0</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">area_clkB_buf1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">area_clkB_buf0</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">area_clkA_reg</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">area_clkB_buf1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">area_clkB_buf0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>


<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
<p>一般来说, 用2个或更多的触发器驱动目标时钟域可以避免亚稳态的产生。提供在<code class="docutils literal notranslate"><span class="pre">spinal.lib._</span></code>中的<code class="docutils literal notranslate"><span class="pre">BufferCC(input:</span> <span class="pre">T,</span> <span class="pre">init:</span> <span class="pre">T</span> <span class="pre">=</span> <span class="pre">null,</span> <span class="pre">bufferDepth:</span> <span class="pre">Int</span> <span class="pre">=</span> <span class="pre">2)</span></code>函数能例化必要的触发器(触发器的数量取决于<code class="docutils literal notranslate"><span class="pre">bufferDepth</span></code>参数大小)来减轻亚稳态。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CrossingExample</span><span class="p">(</span><span class="n">clkA</span><span class="p">:</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">,</span><span class="w"> </span><span class="n">clkB</span><span class="p">:</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">dataIn</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">dataOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//clkA时钟域下的样本输入</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">area_clkA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockingArea</span><span class="p">(</span><span class="n">clkA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">dataIn</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//BufferCC避免亚稳态</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">area_clkB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockingArea</span><span class="p">(</span><span class="n">clkB</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">buf1</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">BufferCC</span><span class="p">(</span><span class="n">area_clkA</span><span class="p">.</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="nc">False</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">dataOut</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">area_clkB</span><span class="p">.</span><span class="n">buf1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">CrossingExample</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_dataIn</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">io_dataOut</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk1_clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk1_reset</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk2_clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk2_reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">area_clkA_reg_buffercc_io_dataOut</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">area_clkA_reg</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">area_clkB_buf1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">BufferCC</span><span class="w"> </span><span class="n">area_clkA_reg_buffercc</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">io_dataIn</span><span class="w">  </span><span class="p">(</span><span class="n">area_clkA_reg</span><span class="w">                    </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_dataOut</span><span class="w"> </span><span class="p">(</span><span class="n">area_clkA_reg_buffercc_io_dataOut</span><span class="p">),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk2_clk</span><span class="w">   </span><span class="p">(</span><span class="n">clk2_clk</span><span class="w">                         </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk2_reset</span><span class="w"> </span><span class="p">(</span><span class="n">clk2_reset</span><span class="w">                       </span><span class="p">)</span><span class="w">  </span><span class="c1">//i</span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">area_clkB_buf1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">area_clkA_reg_buffercc_io_dataOut</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_dataOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">area_clkB_buf1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk1_clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">clk1_reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">clk1_reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">area_clkA_reg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">area_clkA_reg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_dataIn</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>


<span class="k">endmodule</span><span class="w"></span>

<span class="k">module</span><span class="w"> </span><span class="n">BufferCC</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_dataIn</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">io_dataOut</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk2_clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk2_reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="n">async_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="kt">reg</span><span class="w">                 </span><span class="n">buffers_0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="n">async_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="kt">reg</span><span class="w">                 </span><span class="n">buffers_1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_dataOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffers_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk2_clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">clk2_reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">clk2_reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">buffers_0</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">buffers_1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">buffers_0</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_dataIn</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">buffers_1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">buffers_0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>


<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p>注意：<code class="docutils literal notranslate"><span class="pre">BufferCC</span></code>函数只能用于<code class="docutils literal notranslate"><span class="pre">Bit</span></code>类型, 或像灰度编码计数器(每周期翻转1bit)一样的<code class="docutils literal notranslate"><span class="pre">Bits</span></code>操作, 不能用于多bit跨时钟域处理。对于多bit情况, 推荐使用<code class="docutils literal notranslate"><span class="pre">StreamFifoCC</span></code>以应对高带宽需求, 或用<code class="docutils literal notranslate"><span class="pre">StreamCCByToggle</span></code>在带宽不重要的情况下减少数据源的使用。</p>
</div></blockquote>
</section>
<section id="clocking-areas">
<h3>四、特殊的时序区域(clocking areas)<a class="headerlink" href="#clocking-areas" title="Permalink to this heading"></a></h3>
<ol>
<li><p>慢区域(Slow Area)</p>
<p><code class="docutils literal notranslate"><span class="pre">SlowArea</span></code>用来创建一个比当前时钟域慢的时钟域：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">:{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">counter1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">counter2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">counter3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">//当前使用时钟域：100MHz</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">areaStd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">CounterFreeRun</span><span class="p">(</span><span class="mi">16</span><span class="p">).</span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//把当前时钟域减少4倍到25MHz</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">areaDiv4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">SlowArea</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">CounterFreeRun</span><span class="p">(</span><span class="mi">16</span><span class="p">).</span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//把当前时钟域减少到50MHz</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">area50MHz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">SlowArea</span><span class="p">(</span><span class="mi">50</span><span class="w"> </span><span class="nc">MHz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">CounterFreeRun</span><span class="p">(</span><span class="mi">16</span><span class="p">).</span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">counter1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">areaStd</span><span class="p">.</span><span class="n">counter</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">counter2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">areaDiv4</span><span class="p">.</span><span class="n">counter</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">counter3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">area50MHz</span><span class="p">.</span><span class="n">counter</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nc">SpinalConfig</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">defaultClockDomainFrequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">FixedFrequency</span><span class="p">(</span><span class="mi">100</span><span class="w"> </span><span class="nc">MHz</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">).</span><span class="n">generateVhdl</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">TopLevel1</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>BootReset</p>
<p><code class="docutils literal notranslate"><span class="pre">clockDomain.withBootReset()</span></code>能够把寄存器的resetkinde指定成boot。<code class="docutils literal notranslate"><span class="pre">clockDomain.withSyncReset()</span></code>能够把寄存器的resetkinde指定成Sync-reset。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Top</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bit</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">clockDomain</span><span class="p">.</span><span class="n">withBootReset</span><span class="p">()</span><span class="w">  </span><span class="n">on</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">clockDomain</span><span class="p">.</span><span class="n">withSyncReset</span><span class="p">()</span><span class="w">  </span><span class="n">on</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">d</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">clockDomain</span><span class="p">.</span><span class="n">withAsyncReset</span><span class="p">()</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="nc">SpinalVerilog</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Top</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">MyTopLevel</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_data</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_a</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_b</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_c</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_d</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_data_regNext</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_data_regNext_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_data_regNext_2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_data_regNext_3</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">initial</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_data_regNext_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_data_regNext</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_data_regNext_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_data_regNext_2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_data_regNext_3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">io_data_regNext</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">io_data_regNext_3</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">io_data_regNext</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_data</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">io_data_regNext_3</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_data</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_data_regNext_1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_data</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">io_data_regNext_2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">io_data_regNext_2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_data</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>


<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>重置区域(Reset Area)</p>
<p><code class="docutils literal notranslate"><span class="pre">ResetArea</span></code>可以用来创建新的时钟域, 在这个时钟域中一个特殊的复位信号和当前时钟域复位信号相结合：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">specialReset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w">       </span><span class="c1">//需要初始化</span>

<span class="w">    </span><span class="c1">//这个区域的reset由specialReset实现</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">areaRst_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ResetArea</span><span class="p">(</span><span class="n">specialReset</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">CounterFreeRun</span><span class="p">(</span><span class="mi">16</span><span class="p">).</span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//这个区域的复位信号是当前复位和specialReset的结合</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">areaRst_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ResetArea</span><span class="p">(</span><span class="n">specialReset</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">CounterFreeRun</span><span class="p">(</span><span class="mi">16</span><span class="p">).</span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">assign</span><span class="w"> </span><span class="n">_zz__zz_io_counter1_1_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_counter1</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">_zz__zz_io_counter1_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">3</span><span class="mi">&#39;d0</span><span class="p">,</span><span class="w"> </span><span class="n">_zz__zz_io_counter1_1_1</span><span class="p">};</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">_zz__zz_io_counter2_1_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_counter2</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">_zz__zz_io_counter2_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">3</span><span class="mi">&#39;d0</span><span class="p">,</span><span class="w"> </span><span class="n">_zz__zz_io_counter2_1_1</span><span class="p">};</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">specialReset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">  </span><span class="n">_zz_io_counter1_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_io_counter1_2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_zz__zz_io_counter1_1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_counter1_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">_zz_io_counter1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">areaRst_2_newReset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">reset</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">specialReset</span><span class="p">);</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">  </span><span class="n">_zz_io_counter2_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_io_counter2_2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_zz__zz_io_counter2_1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_counter2_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">_zz_io_counter2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">io_counter1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_counter1_2</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">io_counter2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_counter2_2</span><span class="p">;</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">specialReset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">specialReset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_counter1_2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_counter1_2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">_zz_io_counter1_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">areaRst_2_newReset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">areaRst_2_newReset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_counter2_2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_counter2_2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">_zz_io_counter2_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>时钟使能区域(ClockEnableArea)</p>
<p><code class="docutils literal notranslate"><span class="pre">ClockEnableArea</span></code>可以在当前时钟域增加额外的时钟使能：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">clockEnable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w">        </span><span class="c1">//需要初始化</span>

<span class="w">    </span><span class="c1">//在这个区域增加时钟使能</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">area_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockEnableArea</span><span class="p">(</span><span class="n">clockEnable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">CounterFreeRun</span><span class="p">(</span><span class="mi">16</span><span class="p">).</span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">assign</span><span class="w"> </span><span class="n">_zz__zz_io_counter1_1_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_counter1</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">_zz__zz_io_counter1_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">3</span><span class="mi">&#39;d0</span><span class="p">,</span><span class="w"> </span><span class="n">_zz__zz_io_counter1_1_1</span><span class="p">};</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">clockEnable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">area_1_newClockEnable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">clockEnable</span><span class="p">);</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">  </span><span class="n">_zz_io_counter1_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_io_counter1_2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_zz__zz_io_counter1_1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_counter1_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>

<span class="k">assign</span><span class="w"> </span><span class="n">_zz_io_counter1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="k">assign</span><span class="w"> </span><span class="n">io_counter1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_counter1_2</span><span class="p">;</span><span class="w"></span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_counter1_2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">area_1_newClockEnable</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">_zz_io_counter1_2</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">_zz_io_counter1_1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>
<span class="k">end</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="vhdlverilog-ip-instantiate-vhdl-and-verilog-ip">
<h2>VHDL例化和Verilog IP(Instantiate VHDL and Verilog IP)<a class="headerlink" href="#vhdlverilog-ip-instantiate-vhdl-and-verilog-ip" title="Permalink to this heading"></a></h2>
<section id="id34">
<h3>一、描述(Description)<a class="headerlink" href="#id34" title="Permalink to this heading"></a></h3>
<p>黑盒(blackbox)允许使用者把已有的VHDL/Verilog模块通过指定接口集成到当前设计中, 这种调用的正确描述取决于仿真器或综合器。</p>
</section>
<section id="defining-an-blackbox">
<h3>二、定义黑盒(Defining an blackbox)<a class="headerlink" href="#defining-an-blackbox" title="Permalink to this heading"></a></h3>
<p>一个定义黑盒的例子如下所示：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//定义Ram黑盒</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Ram_1w_1r</span><span class="p">(</span><span class="n">wordWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">wordCount</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">BlackBox</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//给黑盒增加VHDL范式/Verilog参数</span>
<span class="w">    </span><span class="c1">//你可以用String, Int, Double, Boolean和所有基于SpinalHDL的类型作为参数值</span>
<span class="w">    </span><span class="n">addGeneric</span><span class="p">(</span><span class="s">&quot;wordCount&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">wordCount</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">addGeneric</span><span class="p">(</span><span class="s">&quot;wordWidth&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">wordWidth</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//定义VHDL通道的io/Verilog模块</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">wr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">en</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">log2Up</span><span class="p">(</span><span class="n">wordCount</span><span class="p">)</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">wordWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">rd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">en</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">log2Up</span><span class="p">(</span><span class="n">wordCount</span><span class="p">)</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">wordWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//把当前时钟域映射到io.clk引脚</span>
<span class="w">    </span><span class="n">mapClockDomain</span><span class="p">(</span><span class="n">clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">clk</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">Ram_1w_1r</span><span class="w"> </span><span class="p">#(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">wordCount</span><span class="p">(</span><span class="mh">4</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">wordWidth</span><span class="p">(</span><span class="mh">4</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">io_clk</span><span class="w">     </span><span class="p">(</span><span class="n">clk</span><span class="w">                 </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_wr_en</span><span class="w">   </span><span class="p">(</span><span class="n">wren</span><span class="w">                </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_wr_addr</span><span class="w"> </span><span class="p">(</span><span class="n">wraddr</span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">         </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_wr_data</span><span class="w"> </span><span class="p">(</span><span class="n">wrdata</span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">         </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_rd_en</span><span class="w">   </span><span class="p">(</span><span class="n">rden</span><span class="w">                </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_rd_addr</span><span class="w"> </span><span class="p">(</span><span class="n">rdaddr</span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">         </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_rd_data</span><span class="w"> </span><span class="p">(</span><span class="n">test_io_rd_data</span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">])</span><span class="w">  </span><span class="c1">//o</span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>在VHDL, <code class="docutils literal notranslate"><span class="pre">Bool</span></code>信号类型会被翻译成<code class="docutils literal notranslate"><span class="pre">std_logic</span></code>, <code class="docutils literal notranslate"><span class="pre">Bits</span></code>会被翻译成<code class="docutils literal notranslate"><span class="pre">std_logic_vector</span></code>。如果你想得到<code class="docutils literal notranslate"><span class="pre">std_ulogic</span></code>, 你需要用<code class="docutils literal notranslate"><span class="pre">BlackBoxULogic</span></code>而不是<code class="docutils literal notranslate"><span class="pre">BlackBox</span></code>。</p>
<p>在Verilog中, <code class="docutils literal notranslate"><span class="pre">BlackBoxUlogic</span></code>没有影响。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Ram_1w_1r</span><span class="p">(</span><span class="n">wordWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">wordCount</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">BlackBoxULogic</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="generics">
<h3>三、范式(Generics)<a class="headerlink" href="#generics" title="Permalink to this heading"></a></h3>
<p>有两种方式定义范式：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Ram</span><span class="p">(</span><span class="n">wordWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">wordCount</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">BlackBox</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">addGeneric</span><span class="p">(</span><span class="s">&quot;wordCount&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">wordCount</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">addGeneric</span><span class="p">(</span><span class="s">&quot;wordWidth&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">wordWidth</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//或者</span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">generic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Generic</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">wordCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ram</span><span class="p">.</span><span class="bp">this</span><span class="p">.</span><span class="n">wordCount</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">wordWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ram</span><span class="p">.</span><span class="bp">this</span><span class="p">.</span><span class="n">wirdWidth</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="instantiating-a-blackbox">
<h3>四、例化黑盒(Instantiating a blackbox)<a class="headerlink" href="#instantiating-a-blackbox" title="Permalink to this heading"></a></h3>
<p>只需要像例化<code class="docutils literal notranslate"><span class="pre">Component</span></code>一样例化<code class="docutils literal notranslate"><span class="pre">BlackBox</span></code>：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//创建顶层并例化Ram</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">wr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">en</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">log2Up</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">rd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">en</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">log2Up</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//例化黑盒</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ram</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Ram_1w_1r</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//连接所有信号</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">wr</span><span class="p">.</span><span class="n">en</span><span class="w">    </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">ram</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">wr</span><span class="p">.</span><span class="n">en</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">wr</span><span class="p">.</span><span class="n">addr</span><span class="w">  </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">ram</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">wr</span><span class="p">.</span><span class="n">addr</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">wr</span><span class="p">.</span><span class="n">data</span><span class="w">    </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">ram</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">wr</span><span class="p">.</span><span class="n">data</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">rd</span><span class="p">.</span><span class="n">en</span><span class="w">  </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">ram</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">rd</span><span class="p">.</span><span class="n">en</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">rd</span><span class="p">.</span><span class="n">addr</span><span class="w">    </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">ram</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">rd</span><span class="p">.</span><span class="n">addr</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">rd</span><span class="p">.</span><span class="n">data</span><span class="w">  </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">ram</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">rd</span><span class="p">.</span><span class="n">data</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">object</span><span class="w"> </span><span class="nc">Main</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nc">SpinalVhdl</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">TopLevel</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">MyTopLevel</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_wr_en</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_wr_addr</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_wr_data</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_rd_en</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_rd_addr</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_rd_data</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">ram_io_rd_data</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">Ram_1w_1r</span><span class="w"> </span><span class="p">#(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">wordCount</span><span class="p">(</span><span class="mh">16</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">wordWidth</span><span class="p">(</span><span class="mh">8</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="n">ram</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">io_clk</span><span class="w">     </span><span class="p">(</span><span class="n">clk</span><span class="w">                </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_wr_en</span><span class="w">   </span><span class="p">(</span><span class="n">io_wr_en</span><span class="w">           </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_wr_addr</span><span class="w"> </span><span class="p">(</span><span class="n">io_wr_addr</span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_wr_data</span><span class="w"> </span><span class="p">(</span><span class="n">io_wr_data</span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_rd_en</span><span class="w">   </span><span class="p">(</span><span class="n">io_rd_en</span><span class="w">           </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_rd_addr</span><span class="w"> </span><span class="p">(</span><span class="n">io_rd_addr</span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_rd_data</span><span class="w"> </span><span class="p">(</span><span class="n">ram_io_rd_data</span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">])</span><span class="w">  </span><span class="c1">//o</span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_rd_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ram_io_rd_data</span><span class="p">;</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="clock-and-reset-mapping">
<h3>五、时钟和复位的布局(Clock and reset mapping)<a class="headerlink" href="#clock-and-reset-mapping" title="Permalink to this heading"></a></h3>
<p>在你定义的黑盒中, 你需要清晰地定义出时钟和复位wire。为了能把<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>的信号映射到对应的黑盒输入端, 你可以使用<code class="docutils literal notranslate"><span class="pre">mapClockDomain</span></code>或<code class="docutils literal notranslate"><span class="pre">mapCurrentClockDomain</span></code>函数。<code class="docutils literal notranslate"><span class="pre">mapClockDomain</span></code>有如下参数：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">参数名</th>
<th style="text-align: center;">数据类型</th>
<th style="text-align: center;">默认</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">clockDomain</td>
<td style="text-align: center;">ClockDomain</td>
<td style="text-align: center;">clockDomain.current</td>
<td style="text-align: center;">指定提供信号的时钟域</td>
</tr>
<tr>
<td style="text-align: center;">clock</td>
<td style="text-align: center;">Bool</td>
<td style="text-align: center;">Nothing</td>
<td style="text-align: center;">连接时钟域时钟的黑盒输入</td>
</tr>
<tr>
<td style="text-align: center;">reset</td>
<td style="text-align: center;">Bool</td>
<td style="text-align: center;">Nothing</td>
<td style="text-align: center;">连接时钟域复位的黑盒输入</td>
</tr>
<tr>
<td style="text-align: center;">enable</td>
<td style="text-align: center;">Bool</td>
<td style="text-align: center;">Nothing</td>
<td style="text-align: center;">连接时钟域使能的黑盒输入</td>
</tr>
</tbody>
</table><p><code class="docutils literal notranslate"><span class="pre">mapCurrentClockDomain</span></code>和<code class="docutils literal notranslate"><span class="pre">mapClockDomain</span></code>有着近乎相同的参数, 唯一区别是没有<code class="docutils literal notranslate"><span class="pre">clockDomain</span></code>。</p>
<p>例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyRam</span><span class="p">(</span><span class="n">clkDomain</span><span class="p">:</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">BlackBox</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">clkA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">clkB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//A时钟映射在给定时钟域</span>
<span class="w">    </span><span class="n">mapClockDomain</span><span class="p">(</span><span class="n">clkDomain</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">clkA</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c1">//B时钟映射在当前时钟域</span>
<span class="w">    </span><span class="n">mapCurrentClockDomain</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">clkB</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="io-io-prefix">
<h3>六、io前缀(io prefix)<a class="headerlink" href="#io-io-prefix" title="Permalink to this heading"></a></h3>
<p>为了避免在黑盒的IO口书写“io_”前缀, 也可以使用<code class="docutils literal notranslate"><span class="pre">noIoPrefix()</span></code>函数, 如下所示：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Ram_1w_1r</span><span class="p">(</span><span class="n">wordWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">wordCount</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">BlackBox</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">generic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Generic</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">wordCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ram_1w_1r</span><span class="p">.</span><span class="bp">this</span><span class="p">.</span><span class="n">wordCount</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">wordWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ram_1w_1r</span><span class="p">.</span><span class="bp">this</span><span class="p">.</span><span class="n">wordWidth</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">wr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">en</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">log2Up</span><span class="p">(</span><span class="n">_wordCount</span><span class="p">)</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">_wordWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">rd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">en</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">log2Up</span><span class="p">(</span><span class="n">_wordCount</span><span class="p">)</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">_wordWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">noIoPrefix</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="n">mapCurrentClockDomain</span><span class="p">(</span><span class="n">clock</span><span class="o">=</span><span class="n">io</span><span class="p">.</span><span class="n">clk</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="io-rename-all-io-of-a-blackbox">
<h3>七、重命名黑盒的所有io(Rename all io of a blackbox)<a class="headerlink" href="#io-rename-all-io-of-a-blackbox" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">BlackBox</span></code>或<code class="docutils literal notranslate"><span class="pre">Component</span></code>中的IOs能通过<code class="docutils literal notranslate"><span class="pre">addPrePopTask</span></code>在编译期间重命名。这个函数接受一个在编译期间无变量的函数, 并且这个函数在增加重命名通道的时候很有用, 如下所示：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyRam</span><span class="p">()</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Blackbox</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">portA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">cs</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">rwn</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">dIn</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">dOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">portB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">cs</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">rwn</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">dIn</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="kd">val</span><span class="w"> </span><span class="n">dOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">//映射时钟</span>
<span class="w">    </span><span class="n">mapCurrentClockDomain</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">clk</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//移除io_ prefix</span>
<span class="w">    </span><span class="n">noIoPrefix</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="c1">//用函数给黑盒中所有信号重命名</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">renameIO</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">io</span><span class="p">.</span><span class="n">flatten</span><span class="p">.</span><span class="n">foreach</span><span class="p">(</span><span class="n">bt</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">bt</span><span class="p">.</span><span class="n">getName</span><span class="p">().</span><span class="n">contains</span><span class="p">(</span><span class="s">&quot;portA&quot;</span><span class="p">))</span><span class="w"> </span><span class="n">bt</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="n">bt</span><span class="p">.</span><span class="n">getName</span><span class="p">().</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;portA_&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;_A&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">bt</span><span class="p">.</span><span class="n">getName</span><span class="p">().</span><span class="n">contains</span><span class="p">(</span><span class="s">&quot;portB&quot;</span><span class="p">))</span><span class="w"> </span><span class="n">bt</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="n">bt</span><span class="p">.</span><span class="n">getName</span><span class="p">().</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;portB_&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;_B&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">})</span><span class="w"></span>

<span class="w">        </span><span class="c1">//在创建模块后执行重命名函数</span>
<span class="w">        </span><span class="n">addPrePopTask</span><span class="p">(()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">renameIO</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">//这段代码会产生如下信号名字:</span>
<span class="c1">//    clk</span>
<span class="c1">//    cs_A, rwn_A, dIn_A, dOut_A</span>
<span class="c1">//    cs_B, rwn_B, dIn_B, dOut_B</span>
</pre></div>
</div>
</section>
<section id="rtl-add-rtl-source">
<h3>八、添加RTL源(Add RTL source)<a class="headerlink" href="#rtl-add-rtl-source" title="Permalink to this heading"></a></h3>
<p>通过<code class="docutils literal notranslate"><span class="pre">addRTLPath()</span></code>你可以把黑盒和RTL源代码联系起来。在生成SpinalHDL代码后可以调用函数<code class="docutils literal notranslate"><span class="pre">mergeRTLSource</span></code>把这些源代码整合起来。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyBlackBox</span><span class="p">()</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Blackbox</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">clk</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">start</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">dIn</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">dOut</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">ready</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">//映射时钟</span>
<span class="w">    </span><span class="n">mapCurrentClockDomain</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">clk</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//移除io_前缀</span>
<span class="w">    </span><span class="n">noIoPrefix</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="c1">//增加所有rtl依赖</span>
<span class="w">    </span><span class="n">addRTLPath</span><span class="p">(</span><span class="s">&quot;./rtl/RegisterBank.v&quot;</span><span class="p">)</span><span class="w">                      </span><span class="c1">//增加verilog文件</span>
<span class="w">    </span><span class="n">addRTLPath</span><span class="p">(</span><span class="s">s&quot;./rtl/myDesign.vhd&quot;</span><span class="p">)</span><span class="w">                       </span><span class="c1">//增加VHDL文件</span>
<span class="w">    </span><span class="n">addRTLPath</span><span class="p">(</span><span class="s">s&quot;</span><span class="si">${</span><span class="n">sys</span><span class="p">.</span><span class="n">env</span><span class="p">(</span><span class="s">&quot;MY_PROJECT&quot;</span><span class="p">)</span><span class="si">}</span><span class="s">/myTopLevel.vhd&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1">//使用环境变量MY_PROJECT(System.getenv(&quot;MY_PROJECT&quot;))</span>
<span class="p">}</span><span class="w"></span>

<span class="p">...</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">report</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SpinalVhdl</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">MyBlackBox</span><span class="p">)</span><span class="w"></span>
<span class="n">report</span><span class="p">.</span><span class="n">mergeRTLSource</span><span class="p">(</span><span class="s">&quot;mergeRTL&quot;</span><span class="p">)</span><span class="w">       </span><span class="c1">//把所有rtl源代码整合进mergeRTL.vhd和mergeRTL.v文件</span>
</pre></div>
</div>
</section>
<section id="vhdl-vhdl-no-numeric-type">
<h3>九、VHDL——非数字类型(VHDL-No numeric type)<a class="headerlink" href="#vhdl-vhdl-no-numeric-type" title="Permalink to this heading"></a></h3>
<p>如果你只想在黑盒模块中使用<code class="docutils literal notranslate"><span class="pre">std_logic_vector</span></code>, 你可以给黑河增加<code class="docutils literal notranslate"><span class="pre">noNumericType</span></code>标签。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyBlackBox</span><span class="p">()</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">BlackBox</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">clk</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">increment</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">initValue</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">map</span><span class="w"> </span><span class="nc">CurrentClockDomain</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">clk</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">noIoPrefix</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="n">addTag</span><span class="p">(</span><span class="n">noNumericType</span><span class="p">)</span><span class="w">       </span><span class="c1">//只有std_logic_vector</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码会生成以下VHDL：</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="k">component</span><span class="w"> </span><span class="nc">MyBlackBox</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="w">  </span><span class="k">port</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">clk</span><span class="w">       </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w">  </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">increment</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w">  </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">initValue</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w">  </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">component</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="preserving-names">
<h2>保留名称(Preserving names)<a class="headerlink" href="#preserving-names" title="Permalink to this heading"></a></h2>
<section id="id35">
<h3>一、简介(Introduction)<a class="headerlink" href="#id35" title="Permalink to this heading"></a></h3>
<p>这一章会介绍SpinalHDL如何把名字从scala代码传递到产生的硬件中。知道这些能帮助你更好地了解如何保留名字, 以尽可能增加生成的网表的可读性。</p>
</section>
<section id="nameable-base-class">
<h3>二、可命名的基础类(Nameable base class)<a class="headerlink" href="#nameable-base-class" title="Permalink to this heading"></a></h3>
<p>在SpinalHDL中所有可以被命名的东西都扩展了可命名的基类。</p>
<p>所以实际上, 以下的类拓展了可命名特点：</p>
<ul class="simple">
<li><p>模块(Component)</p></li>
<li><p>区域(Area)</p></li>
<li><p>数据(UInt, SInt, Bundle, …)</p></li>
</ul>
<p>这里有一些可命名的API的例子</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;rawrr&quot;</span><span class="p">)</span><span class="w">      </span><span class="c1">//强制命名</span>
<span class="w">    </span><span class="n">c</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&quot;rawrr&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">weak</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w">     </span><span class="c1">//提出一个弱名字, 如果有更强的名字已经被使用则不会更改名字</span>
<span class="w">    </span><span class="n">d</span><span class="p">.</span><span class="n">setCompositeName</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">postfix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;wuff&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">//强制命名成b.getname()+&quot;_wuff&quot;</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码会生成：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">module</span><span class="w"> </span><span class="nc">Mycomponent</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">wire</span><span class="w">    </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">wire</span><span class="w">    </span><span class="n">rawrr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">wire</span><span class="w">    </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">wire</span><span class="w">    </span><span class="n">rawrr_wuff</span><span class="p">;</span><span class="w"></span>
<span class="n">endmodule</span><span class="w"></span>
</pre></div>
</div>
<p>一般来说, 除非你出于debug或精细化的目的, 你不必一定要用这个API来修改名字。</p>
</section>
<section id="scala-name-extraction-from-scala">
<h3>三、从Scala中提取名字(Name extraction from Scala)<a class="headerlink" href="#scala-name-extraction-from-scala" title="Permalink to this heading"></a></h3>
<p>首先, 自从v.1.4.0, 在类的建立期间, 当每次新的<code class="docutils literal notranslate"><span class="pre">val</span></code>被定义的时候, SpinalHDL用的Scala编译器插件可以提供一个返回值。</p>
<p>以下这个例子或多或少地展示了SpinalHDL是如何实现的：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//spinal.idslplugin.ValCallback是Scala编译器插件的特征, 用来产生callback</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="n">spinal</span><span class="p">.</span><span class="n">idslplugin</span><span class="p">.</span><span class="nc">ValCallback</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">valCallback</span><span class="p">[</span><span class="nc">T</span><span class="p">](</span><span class="n">ref</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;Got </span><span class="si">$</span><span class="n">ref</span><span class="s"> named </span><span class="si">$</span><span class="n">name</span><span class="s">&quot;</span><span class="p">)</span><span class="w">    </span><span class="c1">//这里我们把我们得到的打印出来作为demo</span>
<span class="w">        </span><span class="n">ref</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">UInt</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Bits</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">wuff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;miaou&quot;</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">toto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">UInt</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">rawrr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bits</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">object</span><span class="w"> </span><span class="nc">Debug3</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">App</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nc">MyComponent</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="c1">//这会打印出：</span>
<span class="w">    </span><span class="c1">// Got 2 named two</span>
<span class="w">    </span><span class="c1">// Got miaou named wuff</span>
<span class="w">    </span><span class="c1">// Got spinal.tester.code.sandbox.UInt@691a7f8f named toto</span>
<span class="w">    </span><span class="c1">// Got spinal.tester.code.sandbox.Bits@161b062a named rawrr</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>通过使用返回值的“自省”特点, SpinalHDL的模块类能时刻知道他们的内容和名字。</p>
<p>但这也意味着如果你想让某些东西得到名字, 并且你只依赖于这个自动命名的特点, 你例化的数据(UInt, SInt, …)的引用应该以模块(component)val的形式存在某些地方。</p>
<p>例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="n">extend</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">  </span><span class="c1">//会被正确地命名</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">toto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="c1">//也会被正确地命名</span>

<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">doStuff</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">  </span><span class="c1">//这不会被命名, 因为它没作为component val存储(之后会有解释)</span>
<span class="w">        </span><span class="n">tmp</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x20</span><span class="w"></span>
<span class="w">        </span><span class="n">toto</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">doStuff</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这会产生：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">MyComponent</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">a</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">b</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w">  </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">toto</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">//注意在Scala中定义的tmp信号被SpinalHDL切掉了, 因为它没有被命名并且是可剪切的</span>

<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">toto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h20</span><span class="p">;</span><span class="w"></span>
<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="area-in-a-component">
<h3>四、模块中的区域(Area in a Component)<a class="headerlink" href="#area-in-a-component" title="Permalink to this heading"></a></h3>
<p>在命名系统时一个很重要的方面是你可以在模块内定义新的命名空间(namespaces)并使用它。</p>
<p>例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">logicA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w">     </span><span class="c1">//这定义了一个叫做“logicA”的命名空间</span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">toggle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bool</span><span class="p">)</span><span class="w">  </span><span class="c1">//这个寄存器会被命名为”logicA_toggle“</span>
<span class="w">        </span><span class="n">toggle</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">!</span><span class="n">toggle</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这会产生：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">MyComponent</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="n">clk</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">reg</span><span class="w">     </span><span class="n">logicA_toggle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@</span><span class="w"> </span><span class="p">(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">logicA_toggle</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">logicA_toggle</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="area-in-a-function">
<h3>五、函数中的区域(Area in a function)<a class="headerlink" href="#area-in-a-function" title="Permalink to this heading"></a></h3>
<p>你也可以定义产生新区域的函数来为它的内容提供命名空间。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">isZero</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">comparator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">someLogic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isZero</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">someLogic</span><span class="p">.</span><span class="n">comparator</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这会生成：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">Mycomponent</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">value</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w">          </span><span class="n">result</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">wire</span><span class="w">            </span><span class="n">someLogic_comparator</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">someLogic_comparator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">someLogic_comparator</span><span class="p">;</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="composite-in-a-function">
<h3>六、在函数中组合(Composite in a function)<a class="headerlink" href="#composite-in-a-function" title="Permalink to this heading"></a></h3>
<p>在SpinalHDL 1.5.0中, 增加了在函数中组合的操作(Composite in a function), 这允许你将创建的区域作为另一个可命名量的前缀：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//基本上, 组合操作就是一个用它结构体参数作为命名空间前缀的区域</span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">isZero</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Composite</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">comparator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="p">}.</span><span class="n">comparator</span><span class="w">    </span><span class="c1">//注意我们不返回组合, 但是会返回我们感兴趣的组合</span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">isZero</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这会生成：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">module</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">input</span><span class="w">   </span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="n">value</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">output</span><span class="w">          </span><span class="n">result</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">wire</span><span class="w">            </span><span class="n">value_comparator</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">assign</span><span class="w"> </span><span class="n">value_comparator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="ss">&#39;h0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assign</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_comparator</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="composite-chains">
<h3>七、组合链(Composite chains)<a class="headerlink" href="#composite-chains" title="Permalink to this heading"></a></h3>
<p>你也可以把组合连接起来：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">isZero</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Composite</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">comparator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="p">}.</span><span class="n">comparator</span><span class="w"></span>

<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">inverted</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Composite</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">inverter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">value</span><span class="w"></span>
<span class="w">    </span><span class="p">}.</span><span class="n">inverter</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">inverted</span><span class="p">(</span><span class="n">isZero</span><span class="p">(</span><span class="n">value</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这会生成：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">MyComponent</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">value</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w">          </span><span class="n">result</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">wire</span><span class="w">            </span><span class="n">value_comparator</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">wire</span><span class="w">            </span><span class="n">value_comparator_inverter</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">value_comparator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">value_comparator_inverter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">value_comparator</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_comparator_inverter</span><span class="p">;</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="bundle-composite-in-a-bundle-s-function">
<h3>八、Bundle函数中的组合(Composite in a Bundle’s function)<a class="headerlink" href="#bundle-composite-in-a-bundle-s-function" title="Permalink to this heading"></a></h3>
<p>这个特性在实现Bundle工具的时候非常有用, 例如在spinal.lib.Stream类中如下定义：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Stream</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="kd">val</span><span class="w"> </span><span class="n">payloadType</span><span class="p">:</span><span class="w"> </span><span class="nc">HardType</span><span class="p">[</span><span class="nc">T</span><span class="p">])</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">valid</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ready</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">payloadType</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">queue</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">):</span><span class="w"> </span><span class="nc">Stream</span><span class="p">[</span><span class="nc">T</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Composite</span><span class="p">(</span><span class="bp">this</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">fifo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StreamFifo</span><span class="p">(</span><span class="n">payloadType</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">fifo</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">self</span><span class="w">    </span><span class="c1">//&#39;self&#39;引用了组合结构体参数(在本例中是this), 这避免了繁琐的‘Stream.this’</span>
<span class="w">    </span><span class="p">}.</span><span class="n">fifo</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="w"></span>

<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">m2sPipe</span><span class="p">():</span><span class="w"> </span><span class="nc">Stream</span><span class="p">[</span><span class="nc">T</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Composite</span><span class="p">(</span><span class="bp">this</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">m2sPipe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="n">payloadType</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">rValid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegInit</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">rData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="n">payloadType</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">ready</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">m2sPipe</span><span class="p">.</span><span class="n">valid</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">m2sPipe</span><span class="p">.</span><span class="n">ready</span><span class="w"></span>

<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">ready</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">rValid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">valid</span><span class="w"></span>
<span class="w">            </span><span class="n">rData</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">payload</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">m2sPipe</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rValid</span><span class="w"></span>
<span class="w">        </span><span class="n">m2sPipe</span><span class="p">.</span><span class="n">payload</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rData</span><span class="w"></span>
<span class="w">    </span><span class="p">}.</span><span class="n">m2sPipe</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这允许在保留名字的同时嵌套调用：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">Stream</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">sink</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">Stream</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="n">sink</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">queue</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">).</span><span class="n">m2sPipe</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这会生成：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">MyComponent</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">source_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">source_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_payload</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">sink_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">sink_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">sink_payload</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">source_fifo_io_pop_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">source_fifo_io_push_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">source_fifo_io_pop_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_fifo_io_pop_payload</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_fifo_io_occupancy</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_fifo_io_availability</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">source_fifo_io_pop_m2sPipe_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">source_fifo_io_pop_m2sPipe_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_fifo_io_pop_m2sPipe_payload</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">source_fifo_io_pop_rValid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_fifo_io_pop_rData</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">StreamFifo</span><span class="w"> </span><span class="n">source_fifo</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">io_push_valid</span><span class="w">      </span><span class="p">(</span><span class="n">source_valid</span><span class="w">                 </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_push_ready</span><span class="w">      </span><span class="p">(</span><span class="n">source_fifo_io_push_ready</span><span class="w">    </span><span class="p">),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_push_payload</span><span class="w">    </span><span class="p">(</span><span class="n">source_payload</span><span class="w">               </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_pop_valid</span><span class="w">       </span><span class="p">(</span><span class="n">source_fifo_io_pop_valid</span><span class="w">     </span><span class="p">),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_pop_ready</span><span class="w">       </span><span class="p">(</span><span class="n">source_fifo_io_pop_ready</span><span class="w">     </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_pop_payload</span><span class="w">     </span><span class="p">(</span><span class="n">source_fifo_io_pop_payload</span><span class="w">   </span><span class="p">),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_flush</span><span class="w">           </span><span class="p">(</span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="w">                         </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_occupancy</span><span class="w">       </span><span class="p">(</span><span class="n">source_fifo_io_occupancy</span><span class="w">     </span><span class="p">),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_availability</span><span class="w">    </span><span class="p">(</span><span class="n">source_fifo_io_availability</span><span class="w">  </span><span class="p">),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk</span><span class="w">                </span><span class="p">(</span><span class="n">clk</span><span class="w">                          </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">reset</span><span class="w">              </span><span class="p">(</span><span class="n">reset</span><span class="w">                        </span><span class="p">)</span><span class="w">  </span><span class="c1">//i</span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">source_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_fifo_io_push_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">source_fifo_io_pop_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">source_fifo_io_pop_m2sPipe_valid</span><span class="p">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">source_fifo_io_pop_m2sPipe_ready</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">source_fifo_io_pop_m2sPipe_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_fifo_io_pop_rValid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">source_fifo_io_pop_m2sPipe_payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_fifo_io_pop_rData</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">sink_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_fifo_io_pop_m2sPipe_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">source_fifo_io_pop_m2sPipe_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sink_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">sink_payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_fifo_io_pop_m2sPipe_payload</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@</span><span class="w"> </span><span class="p">(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">source_fifo_io_pop_rValid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">source_fifo_io_pop_ready</span><span class="p">)</span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">source_fifo_io_pop_rValid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">source_fifo_io_pop_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@</span><span class="w"> </span><span class="p">(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">source_fifo_io_pop_ready</span><span class="p">)</span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">source_fifo_io_pop_rData</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">source_fifo_io_pop_payload</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>
<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="unamed-signal-handling">
<h3>九、处理未命名信号(Unamed signal handling)<a class="headerlink" href="#unamed-signal-handling" title="Permalink to this heading"></a></h3>
<p>在1.5.0版本后, 对于没有名字的信号, SpinalHDL会找到被该命名信号驱动的信号作为他的名字。只要你没有太多未命名的信号, 这种未命名方式会非常便利。</p>
<p>此类未命名信号的的名字是：<em>zz</em> + drivenSignal.getName()</p>
<blockquote>
<div><p>备注：这种命名方式也适用于后期生成时, 需要把一些特定的表达式或长的表达式链拆分成多个信号的情况。</p>
</div></blockquote>
<ol>
<li><p>Verilog表达式拆分(Verilog expression splitting)</p>
<p>这里有一个SpinalHDL需要以专用信号表达来匹配Scala API的行为的表达式的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这会生成：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">MyComponent</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">a</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">b</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">c</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">d</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_result</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_result_1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">result</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_result_1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_result_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_result</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="p">);</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Verilog长表达式拆分(Verilog long expression splitting)</p>
<p>这里举了一个如何通过SpinalHDL将长表达式链拆分开的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">conditions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="nc">Bool</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">conditions</span><span class="p">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w">  </span><span class="c1">//在所有条件单元之间增加逻辑or</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这会生成：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">MyComponent</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">conditions_0</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">conditions_1</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">conditions_2</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">conditions_3</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">conditions_58</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">conditions_59</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">conditions_60</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">conditions_61</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">conditions_62</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">conditions_63</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_result</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_result_1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_result_2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">wire</span><span class="w">                </span><span class="n">result</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((((((((((((((((</span><span class="n">_zz_result_1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_32</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_33</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_34</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_35</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w">   </span><span class="n">conditions_36</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_37</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_38</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_39</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_40</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_41</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_42</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w">     </span><span class="n">conditions_43</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_44</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_45</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_46</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_47</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_result_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((((((((((((((((</span><span class="n">_zz_result_2</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_16</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_17</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_18</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_19</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w">     </span><span class="n">conditions_20</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_21</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_22</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_23</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_24</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_25</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_26</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w">   </span><span class="n">conditions_27</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_28</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_29</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_30</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_31</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_result_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((((((((((((((</span><span class="n">conditions_0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_1</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_2</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_3</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_4</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w">  </span><span class="n">conditions_5</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_6</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_7</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_8</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_9</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_10</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_11</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w">     </span><span class="n">conditions_12</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_13</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_14</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_15</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((((((((((((((((</span><span class="n">_zz_result</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_48</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_49</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_50</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_51</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w">     </span><span class="n">conditions_52</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_53</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_54</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_55</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_56</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_57</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_58</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w">   </span><span class="n">conditions_59</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_60</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_61</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_62</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">conditions_63</span><span class="p">);</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>When条件语句(When statement condition)</p>
<p><code class="docutils literal notranslate"><span class="pre">when(cond)</span> <span class="pre">{}</span></code>条件语句在生成时会拆分成名为when_ + fileName + line的信号, swith也同理：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//在Test.scala文件中</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">isZero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="p">(</span><span class="nc">Bool</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="p">(</span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">isZero</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">isZero</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这会生成：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">MyComponent</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">value</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w">          </span><span class="n">isZero</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">counter</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_Test_l117</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">isZero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">when_Test_l117</span><span class="p">)</span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">isZero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>

<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">when_Test_l117</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@</span><span class="w"> </span><span class="p">(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">when_Test_l117</span><span class="p">)</span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">8&#39;h01</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>万不得已(In last resort)</p>
<p>万不得已, 如果有信号没有名字(无名信号), SpinalHDL会找到该信号驱动的有名信号并用它作为后缀：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">enable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="n">cond</span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="p">):</span><span class="w"> </span><span class="nc">UInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="c1">//该寄存器是未命名的</span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">ret</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">count</span><span class="p">(</span><span class="n">enable</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这会生成：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">MyComponent</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">enable</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">value</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_value</span><span class="p">;</span><span class="w"> </span><span class="c1">//Name given to the register in last resort by looking what was driven by it</span>

<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@</span><span class="w"> </span><span class="p">(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">enable</span><span class="p">)</span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">_zz_value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">8&#39;h01</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
<p>最后一种命名方式并不是在所有情况下都是理想的, 但有时会有所帮助。</p>
<blockquote>
<div><p>备注：带有下划线的信号不会存储在Verilator波形中。</p>
</div></blockquote>
</li>
</ol>
</section>
</section>
<section id="parametrization">
<h2>参数化(Parametrization)<a class="headerlink" href="#parametrization" title="Permalink to this heading"></a></h2>
<section id="id36">
<h3>一、简介(Introduction)<a class="headerlink" href="#id36" title="Permalink to this heading"></a></h3>
<p>SpinalHDL的参数化概念涉及多个方面：</p>
<ul class="simple">
<li><p>给设计提供细化阶段(elaboration time)的参数</p></li>
<li><p>可选择的硬件生成</p></li>
</ul>
</section>
<section id="elaboration-time-parameters">
<h3>二、细化阶段的参数(Elaboration time parameters)<a class="headerlink" href="#elaboration-time-parameters" title="Permalink to this heading"></a></h3>
<p>你可以用整个Scala语言来提供细化时间时的参数。</p>
<p>下面是类参数的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MyBus</span><span class="p">(</span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">mySignal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="p">(</span><span class="n">width</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">bus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">MyBus</span><span class="p">(</span><span class="n">width</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>你也可以在scala对象中定义全局变量, 但是需要注意最近增加的ScopeProperty特点能提供更好的解决办法。</p>
</section>
<section id="optional-hardware">
<h3>三、可选择的硬件生成(Optional hardware)<a class="headerlink" href="#optional-hardware" title="Permalink to this heading"></a></h3>
<p>这里有很多可能性。</p>
<p>对于可选择的信号：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="p">(</span><span class="n">flag</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">mySignal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">generate</span><span class="w"> </span><span class="p">(</span><span class="nc">Bool</span><span class="p">())</span><span class="w">   </span><span class="c1">//等价于&quot;if(flag) in Bool() else null&quot;</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>你也可以在Bundle中做相同的事情。</p>
<blockquote>
<div><p>备注：你也可以用Scala选项。</p>
</div></blockquote>
<p>如果你想无效一块硬件的生成：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="p">(</span><span class="n">flag</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">myHardware</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="n">generate</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">//可选择的电路</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>你也可以用scala循环：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">myHardware</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">amount</span><span class="p">)</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">//可选择的电路</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>所以, 在细化期间你想怎么运用Scala就怎么运用, 包括始终整个Scala集合(List, Set, Map, …)来搭建数据模型并把他们以程序的方式转化成硬件(例如对列表元素迭代)。</p>
<div STYLE="page-break-after: always;"></div></section>
</section>
</section>
<section id="semantic">
<h1>语义(Semantic)<a class="headerlink" href="#semantic" title="Permalink to this heading"></a></h1>
<section id="id37">
<h2>赋值(Assignments)<a class="headerlink" href="#id37" title="Permalink to this heading"></a></h2>
<section id="id38">
<h3>一、赋值(Assignments)<a class="headerlink" href="#id38" title="Permalink to this heading"></a></h3>
<p>SpinalHDL中有多个赋值运算：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">符号</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>:=</code></td>
<td style="text-align: center;">标准赋值, 等价于VHDL/Verilog中的<code>&lt;=</code>；对变量的最后一次赋值有效；直到下一个仿真周期数据才更新</td>
</tr>
<tr>
<td style="text-align: center;"><code>\=</code></td>
<td style="text-align: center;">等价于VHDL中的<code>:=</code>和Verilog中的<code>=</code>, 数据会立即更新</td>
</tr>
<tr>
<td style="text-align: center;"><code>&lt;&gt;</code></td>
<td style="text-align: center;">自动地链接两个信号或相同类型的两个Bundle, 信号的方向通过in/out推断(行为上更像<code>:=</code>)</td>
</tr>
</tbody>
</table><div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//因为硬件的并发性, `a`的值一直是1</span>
<span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="c1">//a := 1 &quot;wins&quot;</span>
<span class="n">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>

<span class="kd">var</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="n">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">x</span><span class="w">      </span><span class="c1">//y读到0</span>
<span class="n">x</span><span class="w"> </span><span class="o">\=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="n">z</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">x</span><span class="w">      </span><span class="c1">//z读到1</span>

<span class="c1">//自动连接两个UART接口</span>
<span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">uart</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">uart</span><span class="w"></span>
</pre></div>
</div>
<p>也支持打包赋值, 把多个信号用()打包来赋值：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">d</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">12</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">e</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">f</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="nc">SInt</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">g</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">()</span><span class="w"></span>

<span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">B</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">asBits</span><span class="w"></span>
<span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">).</span><span class="n">asBits</span><span class="w"></span>
<span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">).</span><span class="n">asBits</span><span class="w"></span>
</pre></div>
</div>
<p>在SpinalHDL中, 理解信号的本质(combinational/sequential)是由它的声明定义的, 并不是赋值的方式。所有的数据类型例化都会定义一个组合信号, 用<code class="docutils literal notranslate"><span class="pre">Reg(...)</span></code>包装的数据类型例化会定义时序(registered)信号。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">        </span><span class="c1">//定义组合信号</span>
<span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w">   </span><span class="c1">//定义寄存器信号</span>
<span class="kd">val</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">   </span><span class="c1">//定义复位为0的寄存器信号</span>
</pre></div>
</div>
</section>
<section id="width-checking">
<h3>二、位宽检查(Width checking)<a class="headerlink" href="#width-checking" title="Permalink to this heading"></a></h3>
<p>SpinalHDL会检查赋值的左右两侧bit宽度是否一致。有多种方式能够去适应给定的Bit向量(<code class="docutils literal notranslate"><span class="pre">Bits</span></code>, <code class="docutils literal notranslate"><span class="pre">UInt</span></code>, <code class="docutils literal notranslate"><span class="pre">SInt</span></code>)：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">改变尺寸的方法</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">x:=y.resized</td>
<td style="text-align: center;">用y的改变大小后的复制赋值给x, 改变的值会根据匹配的x自适应</td>
</tr>
<tr>
<td style="text-align: center;">x:=y.resize(newWidth)</td>
<td style="text-align: center;">用y的改变大小后的复制赋值给x, 尺寸是手工计算的</td>
</tr>
</tbody>
</table><p>有一个SpinalHDL自动改变值的位宽的例子：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">赋值</th>
<th style="text-align: center;">问题</th>
<th style="text-align: center;">SpinalHDL行为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">myUIntOf_8bit:=U(3)</td>
<td style="text-align: center;">U(3)创建2 bits的UInt, 不能匹配左侧8 bits的位宽</td>
<td style="text-align: center;">因为推断出U(3)的bit数较小, SpinalHDL自动改变尺寸</td>
</tr>
</tbody>
</table></section>
<section id="combinatorial-loops">
<h3>三、组合逻辑环路(Combinatorial loops)<a class="headerlink" href="#combinatorial-loops" title="Permalink to this heading"></a></h3>
<p>SpinalHDL会检查在设计中有没有组合逻辑环路(Latches), 如果检查到, SpinalHDL会提示error并把环路路径打印出来。</p>
</section>
</section>
<section id="when-switch-mux">
<h2>When/Switch/Mux<a class="headerlink" href="#when-switch-mux" title="Permalink to this heading"></a></h2>
<section id="when">
<h3>一、When<a class="headerlink" href="#when" title="Permalink to this heading"></a></h3>
<p>正如在VHDL和Verilog中, 信号可以根据条件是否符合来选择性地赋值：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">when</span><span class="p">(</span><span class="n">cond1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//当cond1真时执行操作</span>
<span class="p">}.</span><span class="n">elsewhen</span><span class="p">(</span><span class="n">cond2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//当cond1假但cond2真时执行操作</span>
<span class="p">}.</span><span class="n">otherwise</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//cond1和cond2同假时执行操作</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p>注意：如果<code class="docutils literal notranslate"><span class="pre">otherwise</span></code>关键字和花括号的后半部分<code class="docutils literal notranslate"><span class="pre">}</span></code>在同一行, <code class="docutils literal notranslate"><span class="pre">.</span></code>可以省略</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">when</span><span class="p">(</span><span class="n">cond1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">//当cond1真时执行操作</span>
<span class="p">}</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">//cond1和cond2同假时执行操作</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>但如果<code class="docutils literal notranslate"><span class="pre">.otherwise</span></code>在另一行, 需要<code class="docutils literal notranslate"><span class="pre">.</span></code></p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">when</span><span class="p">(</span><span class="n">cond1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">//当cond1真时执行操作</span>
<span class="p">}</span><span class="w"></span>
<span class="p">.</span><span class="n">otherwise</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">//cond1和cond2同假时执行操作</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="switch">
<h3>二、Switch<a class="headerlink" href="#switch" title="Permalink to this heading"></a></h3>
<p>就像在VHDL和Verilog, 当信号得到固定值的时候可以条件执行运算：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">switch</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="n">value1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">//当x===value1执行</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="n">value2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">//当x===value2执行</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">default</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">//当之前的条件都没有符合执行</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">is</span></code>子句可以用<code class="docutils literal notranslate"><span class="pre">is(value1,</span> <span class="pre">value2)</span></code>这种逗号分割的方式书写。</p>
<p>举例：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">switch</span><span class="p">(</span><span class="n">aluop</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="nc">ALUOp</span><span class="p">.</span><span class="n">add</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">immediate</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">instruction</span><span class="p">.</span><span class="n">immI</span><span class="p">.</span><span class="n">signExtend</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="nc">ALUOp</span><span class="p">.</span><span class="n">slt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">immediate</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">instruction</span><span class="p">.</span><span class="n">immI</span><span class="p">.</span><span class="n">signExtend</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="nc">ALUOp</span><span class="p">.</span><span class="n">sltu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">immediate</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">instruction</span><span class="p">.</span><span class="n">immI</span><span class="p">.</span><span class="n">signExtend</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="nc">ALUOp</span><span class="p">.</span><span class="n">sll</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">immediate</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">instruction</span><span class="p">.</span><span class="n">shamt</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="nc">ALUOp</span><span class="p">.</span><span class="n">sra</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">immediate</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">instruction</span><span class="p">.</span><span class="n">shamt</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码等价于</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">switch</span><span class="p">(</span><span class="n">aluop</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="nc">ALU0p</span><span class="p">.</span><span class="n">add</span><span class="p">,</span><span class="w"> </span><span class="nc">ALU0p</span><span class="p">.</span><span class="n">slt</span><span class="p">,</span><span class="w"> </span><span class="nc">ALU0p</span><span class="p">.</span><span class="n">sltu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">immediate</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">instruction</span><span class="p">.</span><span class="n">immI</span><span class="p">.</span><span class="n">signExtend</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="nc">ALU0p</span><span class="p">.</span><span class="n">sll</span><span class="p">,</span><span class="w"> </span><span class="nc">ALU0p</span><span class="p">.</span><span class="n">sra</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">immediate</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">instruction</span><span class="p">.</span><span class="n">shamt</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="local-declaration">
<h3>三、本地声明(Local declaration)<a class="headerlink" href="#local-declaration" title="Permalink to this heading"></a></h3>
<p>也可以在when/switch描述内定义新的信号：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p>备注：SpinalHDL会检查信号是否只在该区域内被定义。</p>
</div></blockquote>
</section>
<section id="mux">
<h3>四、Mux<a class="headerlink" href="#mux" title="Permalink to this heading"></a></h3>
<p>如果你只需要带有<code class="docutils literal notranslate"><span class="pre">Bool</span></code>选择信号的<code class="docutils literal notranslate"><span class="pre">Mux</span></code>, 有两种等价的语句形式：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">语句</th>
<th style="text-align: center;">返回类型</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Mux(cond, whenTrue, whenFalse)</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">当<code>cond</code>为真, 返回<code>whenTrue</code>, 否则返回<code>whenFalse</code></td>
</tr>
<tr>
<td style="text-align: center;">cond ? whenTrue &#124; whenFalse</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">当<code>cond</code>为真, 返回<code>whenTrue</code>, 否则返回<code>whenFalse</code></td>
</tr>
</tbody>
</table><div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">whenTrue</span><span class="p">,</span><span class="w"> </span><span class="n">whenFalse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">muxOutput</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">Mux</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span><span class="w"> </span><span class="n">whenTrue</span><span class="p">,</span><span class="w"> </span><span class="n">whenFalse</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">muxOutput2</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">whenTrue</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">whenFalse</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="bit-bitwise-selection">
<h3>五、Bit级选择(Bitwise selection)<a class="headerlink" href="#bit-bitwise-selection" title="Permalink to this heading"></a></h3>
<p>bit级的选择看起来像VHDL中<code class="docutils literal notranslate"><span class="pre">when</span></code>语句。</p>
<p><strong>举例</strong></p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">bitwiseSelect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">bitwiseResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bitwiseSelect</span><span class="p">.</span><span class="n">mux</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">src0</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">src1</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="mi">1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">src0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">src1</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="mi">2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">src0</span><span class="w"> </span><span class="n">^</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">src1</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">default</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">src0</span><span class="p">)</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>同样, 如果条件是完备的, 不需要些default：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">bitwiseSelect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">bitwiseResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bitwiseSelect</span><span class="p">.</span><span class="n">mux</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">src0</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">src1</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="mi">1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">src0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">src1</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="mi">2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">src0</span><span class="w"> </span><span class="n">^</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">src1</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="mi">3</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">src0</span><span class="p">)</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>或者, 如果未覆盖的值并不重要, 他们可以用<code class="docutils literal notranslate"><span class="pre">muxListDc</span></code>使其不赋值。</p>
<p><code class="docutils literal notranslate"><span class="pre">muxLists(...)</span></code>是另一种bit级选择器, 该选择器以元组作为输入, 下图是一个把128 bits分割成32 bits的例子。</p>
<p><img alt="MuxList" src="_images/MuxList.png" /></p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">sel</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">data</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">128</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="c1">//把宽bit类型分成小块, 可以用mux：</span>
<span class="kd">val</span><span class="w"> </span><span class="n">dataWord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sel</span><span class="p">.</span><span class="n">muxList</span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="n">index</span><span class="o">*</span><span class="mi">32</span><span class="o">+</span><span class="mi">32</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="n">downto</span><span class="w"> </span><span class="n">index</span><span class="o">*</span><span class="mi">32</span><span class="p">)))</span><span class="w"></span>

<span class="c1">//一种书写更短的方式书写上述代码：</span>
<span class="kd">val</span><span class="w"> </span><span class="n">dataWord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">subdivideIn</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)(</span><span class="n">sel</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="rules">
<h2>规则(Rules)<a class="headerlink" href="#rules" title="Permalink to this heading"></a></h2>
<section id="id39">
<h3>一、简介(Introduction)<a class="headerlink" href="#id39" title="Permalink to this heading"></a></h3>
<p>SpinalHDL背后的语义学很重要, 学会语义你就能理解在这些情景背后到底发生了什么, 并且如何去控制它。</p>
<p>这些语义通过以下几条规则定义：</p>
<ul class="simple">
<li><p>信号和寄存器互相并行地执行(正如VHDL和Verilog, 硬件并发特点)</p></li>
<li><p>对组合逻辑的赋值很像是写出它何时是true的表达式</p></li>
<li><p>对寄存器的赋值很像是写出在时钟域下施加什么信号的规则</p></li>
<li><p>对于每个信号, 以最后一个赋值的为准</p></li>
<li><p>每个信号和寄存器都能以OOP方式在硬件描述细化期间作为对象控制</p></li>
</ul>
</section>
<section id="concurrency">
<h3>二、并行性(Concurrency)<a class="headerlink" href="#concurrency" title="Permalink to this heading"></a></h3>
<p>你给每个组合逻辑或寄存器赋值的顺序对其硬件行为没有影响。</p>
<p>例如, 以下两段代码完全等价：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="c1">// Define 3 combinational signals</span>
<span class="n">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">  </span><span class="c1">// c will be set to 7</span>
<span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span><span class="w">      </span><span class="c1">// b will be set to 2</span>
<span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="c1">// a will be set to 5</span>
</pre></div>
</div>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="c1">// Define 3 combinational signals</span>
<span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span><span class="w">      </span><span class="c1">// b will be set to 2</span>
<span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="c1">// a will be set to 5</span>
<span class="n">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">  </span><span class="c1">// c will be set to 7</span>
</pre></div>
</div>
<p>更加通俗来说, 当你用<code class="docutils literal notranslate"><span class="pre">:=</span></code>赋值操作符, 就好比给左侧的信号/寄存器一个新的数据产生规则。</p>
</section>
<section id="last-valid-assignment-wins">
<h3>三、以最后赋值为准(Last valid assignment wins)<a class="headerlink" href="#last-valid-assignment-wins" title="Permalink to this heading"></a></h3>
<p>如果组合逻辑信号或寄存器多次被赋值, 最后一次赋值有效。</p>
<p>例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w">           </span><span class="c1">//定义两个组合逻辑信号</span>
<span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">   </span><span class="c1">//定义一个组合逻辑信号</span>

<span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这会产生如下真值表：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">x</th>
<th style="text-align: center;">y</th>
<th style="text-align: center;">=&gt;</th>
<th style="text-align: center;">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">False</td>
<td style="text-align: center;">False</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">Fasle</td>
<td style="text-align: center;">True</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">True</td>
<td style="text-align: center;">False</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">True</td>
<td style="text-align: center;">True</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">3</td>
</tr>
</tbody>
</table></section>
<section id="scala-signal-and-register-interactions-with-scala-oop">
<h3>四、Scala下的信号和寄存器的内在联系(Signal and register interactions with Scala)(OOP引用+函数)<a class="headerlink" href="#scala-signal-and-register-interactions-with-scala-oop" title="Permalink to this heading"></a></h3>
<p>在SpinalHDL中, 每个硬件单元通过类例化被建模。这意味着你可以用他们的引用使用例化, 例如把他们作为变量传递给函数。</p>
<p>以下例子实现了当<code class="docutils literal notranslate"><span class="pre">inc</span></code>为真时自增, 当<code class="docutils literal notranslate"><span class="pre">clear</span></code>为真时清零的寄存器(<code class="docutils literal notranslate"><span class="pre">clear</span></code>的优先级高于<code class="docutils literal notranslate"><span class="pre">inc</span></code>)：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">inc</span><span class="p">,</span><span class="w"> </span><span class="n">clear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w">             </span><span class="c1">//定义两个组合逻辑信号/线类型</span>
<span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w">     </span><span class="c1">//定义8 bit寄存器</span>

<span class="n">when</span><span class="p">(</span><span class="n">inc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">clear</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="c1">//如果inc和clear都为真, 该赋值有效</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>你可以通过用赋值给<code class="docutils literal notranslate"><span class="pre">counter</span></code>的函数混合之前的例子来实现完全一致的函数性：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">inc</span><span class="p">,</span><span class="w"> </span><span class="n">clear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>

<span class="k">def</span><span class="w"> </span><span class="nf">setCounter</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="p">):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">when</span><span class="p">(</span><span class="n">inc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">setCounter</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">clear</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>你也可以把条件集成到函数内：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">inc</span><span class="p">,</span><span class="w"> </span><span class="n">clear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>

<span class="k">def</span><span class="w"> </span><span class="nf">setCounterWhen</span><span class="p">(</span><span class="n">cond</span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="p">):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">setCounterWhen</span><span class="p">(</span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inc</span><span class="p">,</span><span class="w">      </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="n">setCounterWhen</span><span class="p">(</span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clear</span><span class="p">,</span><span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>并且也可以描述应该给函数赋什么值：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">inc</span><span class="p">,</span><span class="w"> </span><span class="n">clear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>

<span class="k">def</span><span class="w"> </span><span class="nf">setSomethingWhen</span><span class="p">(</span><span class="n">something</span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="p">,</span><span class="w"> </span><span class="n">cond</span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="p">):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">something</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">setSomethingWhen</span><span class="p">(</span><span class="n">something</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="p">,</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inc</span><span class="p">,</span><span class="w">   </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="n">setSomethingWhen</span><span class="p">(</span><span class="n">something</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="p">,</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clear</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>之前所有的例子都和他们生成的RTL与SpinalHDL编译器方面严格等价, 这是因为SpinalHDL只关心Scala的运行和例化的对象, 不关心Scala语法本身。</p>
<p>换句话说, 从生成SpinalHDL/RTL生成器角度来说, 当你在Scala用函数生成电路, 这就好像函数是内联的。这对于Scala loop也同样适用, 因为他们将以展开的形式生成RTL。</p>
<div STYLE="page-break-after: always;"></div></section>
</section>
</section>
<section id="sequential-logic">
<h1>时序逻辑(Sequential logic)<a class="headerlink" href="#sequential-logic" title="Permalink to this heading"></a></h1>
<section id="registers">
<h2>寄存器(Registers)<a class="headerlink" href="#registers" title="Permalink to this heading"></a></h2>
<section id="id40">
<h3>一、简介(Introduction)<a class="headerlink" href="#id40" title="Permalink to this heading"></a></h3>
<p>在SpinalHDL中创建寄存器与VHDL和Verilog中区别很大。</p>
<p>在SpinalHDL中, 没有process/always块, 寄存器在声明的时候就清晰地定义出来。这种和传统事件驱动HDL的不同带来了巨大的影响：</p>
<ul class="simple">
<li><p>你可以在同一区域对寄存器和wire赋值, 意味着代码不需要再分成process/always块</p></li>
<li><p>这让很多事情变得灵活多变, 参考Functions</p></li>
</ul>
<p>时钟和复位是分别处理的, 参考时钟域章节。</p>
</section>
<section id="id41">
<h3>二、例化(Instantiation)<a class="headerlink" href="#id41" title="Permalink to this heading"></a></h3>
<p>有四种方式例化寄存器：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">语句</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Reg(type: Data)</td>
<td style="text-align: center;">给定类型的寄存器</td>
</tr>
<tr>
<td style="text-align: center;">RegInit(resetValue: Data)</td>
<td style="text-align: center;">当复位信号有效, 复位值是<code>resetValue</code>的寄存器</td>
</tr>
<tr>
<td style="text-align: center;">RegNext(nextValue: Data)</td>
<td style="text-align: center;">每周期采样给定<code>nextValue</code>的寄存器</td>
</tr>
<tr>
<td style="text-align: center;">RegNextWhen(nextValue: Data, cond: Bool)</td>
<td style="text-align: center;">当条件触发时采样给定<code>nextValue</code>的寄存器</td>
</tr>
</tbody>
</table><p>以下是一些寄存器声明的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//4 bits UInt寄存器</span>
<span class="kd">val</span><span class="w"> </span><span class="n">reg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>

<span class="c1">//每周期采样reg1的寄存器</span>
<span class="kd">val</span><span class="w"> </span><span class="n">reg2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">reg1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>

<span class="c1">//当复位信号有效初始化为0的4 bits寄存器</span>
<span class="kd">val</span><span class="w"> </span><span class="n">reg3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegInit</span><span class="p">(</span><span class="nc">U</span><span class="s">&quot;0000&quot;</span><span class="p">)</span><span class="w"></span>
<span class="n">reg3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">reg2</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">reg2</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">reg3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0xF</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">//当条件真时采样reg3的寄存器</span>
<span class="kd">val</span><span class="w"> </span><span class="n">reg4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNextWhen</span><span class="p">(</span><span class="n">reg3</span><span class="p">,</span><span class="w"> </span><span class="n">cond</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>以上代码会产生如下电路图：</p>
<p><img alt="register" src="_images/register.svg" /></p>
<blockquote>
<div><p>备注：上述的<code class="docutils literal notranslate"><span class="pre">reg3</span></code>例子展示了如何给<code class="docutils literal notranslate"><span class="pre">RegInit</span></code>赋值。同样的方法也适用于给其他寄存器类型赋值(<code class="docutils literal notranslate"><span class="pre">Reg</span></code>, <code class="docutils literal notranslate"><span class="pre">RegNext</span></code>, <code class="docutils literal notranslate"><span class="pre">RegNextWhen</span></code>)。正如在组合逻辑赋值中, 最后被赋值的语句有效, 但是如果没有赋值语句, 寄存器会保留原值。</p>
</div></blockquote>
<p>同样的, <code class="docutils literal notranslate"><span class="pre">RegNext</span></code>是在<code class="docutils literal notranslate"><span class="pre">Reg</span></code>语句上建立的抽象层次, 以下两种时序代码是完全等价的：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//标准方式</span>
<span class="kd">val</span><span class="w"> </span><span class="n">something</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bool</span><span class="p">())</span><span class="w"></span>
<span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">something</span><span class="w"></span>

<span class="c1">//简短方式</span>
<span class="kd">val</span><span class="w"> </span><span class="n">something</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">something</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="reset-value">
<h3>三、复位值(Reset value)<a class="headerlink" href="#reset-value" title="Permalink to this heading"></a></h3>
<p>除了<code class="docutils literal notranslate"><span class="pre">RegInit(value:</span> <span class="pre">Data)</span></code>语句可以直接创建带有复位值的寄存器, 也可以通过在寄存器上调用<code class="docutils literal notranslate"><span class="pre">init(value:</span> <span class="pre">Data)</span></code>函数设置复位值。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//当reset发生被初始化为0的UInt 4bits寄存器</span>
<span class="kd">val</span><span class="w"> </span><span class="n">reg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>如果你有一个包含包(Bundle)的寄存器, 你可以对包的每一个元素用<code class="docutils literal notranslate"><span class="pre">init</span></code>函数。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ValidRGB</span><span class="p">()</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">valid</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">ValidRGB</span><span class="p">())</span><span class="w"></span>
<span class="n">reg</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w">       </span><span class="c1">//只有寄存器包有效, 才会有复位值</span>
</pre></div>
</div>
</section>
<section id="initialization-value-for-simulation">
<h3>四、仿真下的例化(Initialization value for simulation)<a class="headerlink" href="#initialization-value-for-simulation" title="Permalink to this heading"></a></h3>
<p>对于在RTL中不需要复位值但是在仿真时需要初始值的寄存器(避免传递x值), 你可以通过调用<code class="docutils literal notranslate"><span class="pre">randBoot()</span></code>函数产生随机初始值。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//随机初始化的UInt寄存器</span>
<span class="kd">val</span><span class="w"> </span><span class="n">reg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">randBoot</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="register-vectors">
<h3>五、寄存器向量(Register vectors)<a class="headerlink" href="#register-vectors" title="Permalink to this heading"></a></h3>
<p>对于wire, 可以用<code class="docutils literal notranslate"><span class="pre">Vec</span></code>定义寄存器向量。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">vecReg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)),</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">vecReg2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">8</span><span class="p">)(</span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bool</span><span class="p">()))</span><span class="w"></span>
</pre></div>
</div>
<p>像往常一样可以用<code class="docutils literal notranslate"><span class="pre">init</span></code>方法初始化, 该方法可以和<code class="docutils literal notranslate"><span class="pre">foreach</span></code>迭代结合作用在寄存器上。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">vecReg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">vecReg2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">8</span><span class="p">)(</span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bool</span><span class="p">()))</span><span class="w"></span>
<span class="n">vecReg2</span><span class="p">.</span><span class="n">foreach</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="nc">False</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>对于当<code class="docutils literal notranslate"><span class="pre">init</span></code>值未知时初始化必须被推迟的情况, 可以用以下函数：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ShiftRegister</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">dataType</span><span class="p">:</span><span class="w"> </span><span class="n">hardType</span><span class="p">[</span><span class="nc">T</span><span class="p">],</span><span class="w"> </span><span class="n">depth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">initFunc</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Unit</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">input</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="n">dataType</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">output</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="n">dataType</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">regs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">depth</span><span class="p">)(</span><span class="nc">Reg</span><span class="p">(</span><span class="n">dataType</span><span class="p">()))</span><span class="w"></span>
<span class="w">    </span><span class="n">regs</span><span class="p">.</span><span class="n">foreach</span><span class="p">(</span><span class="n">initFunc</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="p">(</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">regs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">regs</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">regs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">input</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">ouutput</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">regs</span><span class="p">(</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">object</span><span class="w"> </span><span class="nc">SRConsumer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">initIdleFlow</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">flow</span><span class="p">:</span><span class="w"> </span><span class="nc">Flow</span><span class="p">[</span><span class="nc">T</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">flow</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">SRConsumer</span><span class="p">()</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//...</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">sr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ShiftRegister</span><span class="p">(</span><span class="nc">Flow</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)),</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="nc">SRConsumer</span><span class="p">.</span><span class="n">initIdleFlow</span><span class="p">[</span><span class="nc">UInt</span><span class="p">])</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="transforming-a-wire-into-a-register">
<h3>六、把线类型转化为寄存器(Transforming a wire into a register)<a class="headerlink" href="#transforming-a-wire-into-a-register" title="Permalink to this heading"></a></h3>
<p>有时把wire转换为register很有用。例如当你用包(Bundle), 如果你想让产生一些寄存器类型输出, 你可能更倾向于写成<code class="docutils literal notranslate"><span class="pre">io.myBundle.PORT</span> <span class="pre">:=</span> <span class="pre">newValue</span></code>而不是用<code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">PORT</span> <span class="pre">=</span> <span class="pre">Reg(...)</span></code>来声明寄存器, 并把他们的输出与<code class="docutils literal notranslate"><span class="pre">io.myBundle.PORT</span> <span class="pre">:=</span> <span class="pre">PORT</span></code>端口连接起来。为了实现这个, 你只需要在你想要转换为寄存器的端口使用<code class="docutils literal notranslate"><span class="pre">.setAsReg()</span></code>：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">apb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">Apb3</span><span class="p">(</span><span class="n">apb3Config</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="p">.</span><span class="nc">PADDR</span><span class="p">.</span><span class="n">setAsReg</span><span class="p">()</span><span class="w"></span>
<span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="p">.</span><span class="nc">PWRITE</span><span class="p">.</span><span class="n">setAsReg</span><span class="p">()</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"></span>

<span class="n">when</span><span class="p">(</span><span class="n">someCondition</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="p">.</span><span class="nc">PWRITE</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p>在上述代码你需要注意的是, 你也可以给定一个初始值</p>
</div></blockquote>
<blockquote>
<div><p>备注：寄存器的时钟域用的是wire的时钟域, 并不取决于<code class="docutils literal notranslate"><span class="pre">.setAsReg()</span></code>在哪里调用。
在上述例子中, wire定义在<code class="docutils literal notranslate"><span class="pre">io</span></code>包中, 和模块有着相同的时钟域。即便<code class="docutils literal notranslate"><span class="pre">io.apb.PADDR.setAsReg()</span></code>在有着不同时钟域的<code class="docutils literal notranslate"><span class="pre">ClockingArea</span></code>中书写, 寄存器还是会采用模块的时钟而非<code class="docutils literal notranslate"><span class="pre">ClockingArea</span></code>的时钟。</p>
</div></blockquote>
</section>
</section>
<section id="ram-rom">
<h2>RAM/ROM<a class="headerlink" href="#ram-rom" title="Permalink to this heading"></a></h2>
<section id="syntax">
<h3>一、语义(Syntax)<a class="headerlink" href="#syntax" title="Permalink to this heading"></a></h3>
<p>用<code class="docutils literal notranslate"><span class="pre">Mem</span></code>类在SpinalHDL中创建memory, 它允许你定义memory并增加读写端口。</p>
<p>以下表格展示了如何例化memory：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">语句</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Mem(type: Data, size: Int)</td>
<td style="text-align: center;">创建RAM</td>
</tr>
<tr>
<td style="text-align: center;">Mem(type: Data, initialContent: Array[Data])</td>
<td style="text-align: center;">创建ROM, 如果目标是FPGA, 因为memory会被推断成ram模块, 故也可以创建写端口</td>
</tr>
</tbody>
</table><blockquote>
<div><p>备注：如果你想定义ROM, <code class="docutils literal notranslate"><span class="pre">initialContent</span></code>阵列的元素应该是纯粹的值(没有操作符, 没有改变尺寸函数), 在例子里有Sinus rom的例子。</p>
</div></blockquote>
<blockquote>
<div><p>备注：给RAM初始化时, 也可以用<code class="docutils literal notranslate"><span class="pre">init</span></code>函数。</p>
</div></blockquote>
<blockquote>
<div><p>备注：写mask宽度是灵活的, 可以把mem字拆分成和mask宽度一样的片段。例如如果你有32 bits的mem字并提供了4 bits的mask, 那么这就是字节(byte)mask。如果你提供32 bits的mask, 那这就是bit mask。</p>
</div></blockquote>
<p>以下表格展示了如何给memory增加端口：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: left;">语句</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">mem(address):=data</td>
<td style="text-align: center;">同步写</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">mem(x)</td>
<td style="text-align: center;">异步读</td>
<td style="text-align: center;">T</td>
</tr>
<tr>
<td style="text-align: left;">mem.write(<br>address<br>data<br>[enable]<br>[mask]<br>)</td>
<td style="text-align: center;">用可选择的mask同步写。如果没有给定enable, 它会自动从被引用的条件区域里推断</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">mem.readAsync(<br>address<br>[readUnderWrite]<br>)</td>
<td style="text-align: center;">基于可选择的读下写原则异步读</td>
<td style="text-align: center;">T</td>
</tr>
<tr>
<td style="text-align: left;">mem.readSync(<br>address<br>[enable]<br>[readUnderWrite]<br>[clockCrossing]<br>)</td>
<td style="text-align: center;">用可选择的enable, 读下写原则和<code>clockCrossing</code>模式同步写</td>
<td style="text-align: center;">T</td>
</tr>
<tr>
<td style="text-align: left;">mem.readWriteSync(<br>address<br>data<br>enable<br>write<br>[mask]<br>[readUnderWrite]<br>[clockCrossing]<br>)</td>
<td style="text-align: center;">推断读写端口。当<code>enable &amp;&amp; write</code>时<code>data</code>被写入。返回读数据, 当<code>enable</code>为真时触发读</td>
<td style="text-align: center;">T</td>
</tr>
</tbody>
</table><blockquote>
<div><p>备注：如果处于某些原因你需要指定非SpinalHDL实现的memory端口, 你可以通过给memory指定一个黑盒来抽象它。</p>
</div></blockquote>
<blockquote>
<div><p>重要：SpinalHDL的memory端口不是推断得到的, 而是清晰地定义出的。你不能用像VHDL/Verilog一样的代码模板帮助综合工具推断出memory。</p>
</div></blockquote>
<p>以下是一个推断出双端口ram(32 bits*256)的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Mem</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="n">wordCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">256</span><span class="p">)</span><span class="w"></span>
<span class="n">mem</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">enable</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">writeValid</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">writeAddress</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">writeData</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>

<span class="n">io</span><span class="p">.</span><span class="n">readData</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mem</span><span class="p">.</span><span class="n">readSync</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">enable</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">readValid</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">readAddress</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">MyTopLevel</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_writeValid</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_writeAddress</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_writeData</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_readValid</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_readAddress</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_readData</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_mem_port1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">255</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_writeValid</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">mem</span><span class="p">[</span><span class="n">io_writeAddress</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_writeData</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_readValid</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">_zz_mem_port1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">mem</span><span class="p">[</span><span class="n">io_readAddress</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_readData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_mem_port1</span><span class="p">;</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="quirk-synchronous-enable-quirk">
<h3>二、同步使能quirk(Synchronous enable quirk)<a class="headerlink" href="#quirk-synchronous-enable-quirk" title="Permalink to this heading"></a></h3>
<p>如果在条件模块中使用使能信号, 如同<code class="docutils literal notranslate"><span class="pre">when</span></code>, 只有使能信号会作为访存条件生成, <code class="docutils literal notranslate"><span class="pre">when</span></code>条件被忽视。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">rom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Mem</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">rdata</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rom</span><span class="p">.</span><span class="n">readSync</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">rdEna</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在上述例子中, 条件<code class="docutils literal notranslate"><span class="pre">cond</span></code>不会在生成后的RTL中描述, 在使能信号中包含条件<code class="docutils literal notranslate"><span class="pre">cond</span></code>的方法如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">io</span><span class="p">.</span><span class="n">rdata</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rom</span><span class="p">.</span><span class="n">readSync</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">rdEna</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="n">cond</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="read-under-write-policy">
<h3>三、读下写原则(Read-under-write policy)<a class="headerlink" href="#read-under-write-policy" title="Permalink to this heading"></a></h3>
<p>这个规则指定了当在读和写发生在同一周期同一地址时, 写会如何影响。</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">类别</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>dontCare</code></td>
<td style="text-align: center;">当情况发生时不关心读的值</td>
</tr>
<tr>
<td style="text-align: center;"><code>readFirst</code></td>
<td style="text-align: center;">读会取到旧(写前)的值</td>
</tr>
<tr>
<td style="text-align: center;"><code>writeFirst</code></td>
<td style="text-align: center;">读会得到新(写后)的值</td>
</tr>
</tbody>
</table><blockquote>
<div><p>重要：生成的VHDL/Verilog总是<code class="docutils literal notranslate"><span class="pre">readFirst</span></code>模式, 会兼容<code class="docutils literal notranslate"><span class="pre">dontCare</span></code>但是不兼容<code class="docutils literal notranslate"><span class="pre">writeFirst</span></code>。为了产生有这个特点的电路, 需要使能<em>自动化mem黑盒</em></p>
</div></blockquote>
</section>
<section id="ram-mixed-width-ram">
<h3>四、混合宽度ram(Mixed-width ram)<a class="headerlink" href="#ram-mixed-width-ram" title="Permalink to this heading"></a></h3>
<p>你可以指定访存mem的端口的位宽, 这个位宽是mem位宽的一部分, 是二的幂次方, 函数如下：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">语句</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">mem.writeMixedWidth(<br>address<br>data<br>[readUnderWrite]<br>)</td>
<td style="text-align: center;">类似于<code>mem.write</code></td>
</tr>
<tr>
<td style="text-align: center;">mem.readAsyncMixedWidth(<br>address<br>data<br>[readUnderWrite]<br>)</td>
<td style="text-align: center;">类似于<code>mem.readAsync</code>, 但是它会驱动<code>data</code>给定的信号/对象而不是返回读的值</td>
</tr>
<tr>
<td style="text-align: center;">mem.readSyncMixedWidth(<br>address<br>data<br>[enable]<br>[readUnderWrite]<br>[clockCrossing]<br>)</td>
<td style="text-align: center;">类似于<code>mem.readSync</code>, 但是它会驱动<code>data</code>给定的信号/对象而不是返回读的值</td>
</tr>
<tr>
<td style="text-align: center;">mem.readWriteSyncMixedWidth(<br>address<br>data<br>enable<br>write<br>[mask]<br>[readUnderWrite]<br>[clockCrossing]<br>)</td>
<td style="text-align: center;">等价于<code>mem.readWriteSync</code></td>
</tr>
</tbody>
</table><blockquote>
<div><p>重要：对于读下写机制, 为了使用这个特点你需要使能<em>自动化mem黑盒</em>, 因为没有一般性的VHDL/Verilog代码模板推断ram的混合位宽</p>
</div></blockquote>
</section>
<section id="mem-automatic-blackboxing">
<h3>五、自动化mem黑盒(Automatic blackboxing)<a class="headerlink" href="#mem-automatic-blackboxing" title="Permalink to this heading"></a></h3>
<p>因为用传统VHDL/Verilog推断所有ram类型是不可能的, SpinalHDL集成了可选择的自动化黑盒(automatic blackboxing system)系统。这个系统会检查你的RTL网表中所有出现了的mem并把他们用黑盒替代。之后产生的代码会根据第三方IP提供mem的特性, 例如读时写(read-during-write)机制和混合带宽端口。</p>
<p>以下例子说明了如何默认开启mem黑盒：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nc">SpinalConfig</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">addStandardMemBlackboxing</span><span class="p">(</span><span class="n">blackboxAll</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">generateVhdl</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">TopLevel</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果对于你的设计, 标准黑盒工具还不够用, 不要犹豫去创建一个<em>Github issue</em>。这里还有一种你创建自己黑盒工具的方法。</p>
<ol class="simple">
<li><p>黑盒机制(Blackboxing policy)</p></li>
</ol>
<p>有多种机制供你使用, 你可以选择你想要把哪个mem变成黑盒, 并且当黑盒不可用时要做什么：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">种类</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>blackboxAll</code></td>
<td style="text-align: center;">把所有mem变成黑盒。对于无法黑盒化的mem报错</td>
</tr>
<tr>
<td style="text-align: center;"><code>blackboxAllWhatsYouCan</code></td>
<td style="text-align: center;">把所有可黑盒化的mem变成黑盒</td>
</tr>
<tr>
<td style="text-align: center;"><code>blackboxRequestedAndUninferable</code></td>
<td style="text-align: center;">把用户给定的和已知可被推断的mem变成黑盒。对于无法黑盒化的mem报错</td>
</tr>
<tr>
<td style="text-align: center;"><code>blackboxOnlyIfRequested</code></td>
<td style="text-align: center;">用户指定哪些mem变成黑盒。对于无法黑盒化的mem报错</td>
</tr>
</tbody>
</table><p>为了清晰地把mem设置成黑盒, 你可以用<code class="docutils literal notranslate"><span class="pre">generateAsBlackBox</span></code>函数</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Mem</span><span class="p">(</span><span class="nc">Rgb</span><span class="p">(</span><span class="n">rgbConfig</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"></span>
<span class="n">mem</span><span class="p">.</span><span class="n">generateAsBlackBox</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>你也可以通过拓展<code class="docutils literal notranslate"><span class="pre">MemBlackboxingPolicy</span></code>类定义你自己的黑盒机制。</p>
<ol class="simple">
<li><p>标准mem黑盒(Standard memory blackboxed)</p></li>
</ol>
<p>以下展示的是SpinalHDL中用的标准黑盒的VHDL定义：</p>
<div class="highlight-VHDL notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Simple asynchronous dual port (1 write port, 1 read port)</span><span class="w"></span>
<span class="k">component</span><span class="w"> </span><span class="nc">Ram_1w_1ra</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="w">    </span><span class="k">generic</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">wordCount</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wordWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">technology</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">readUnderWrite</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wrAddressWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wrDataWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wrMaskWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wrMaskEnable</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">boolean</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rdAddressWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rdDataWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">port</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">clk</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wr_en</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wr_mask</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wr_addr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wr_data</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rd_addr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rd_data</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">component</span><span class="p">;</span><span class="w"></span>

<span class="c1">-- Simple synchronous dual port (1 write port, 1 read port)</span><span class="w"></span>
<span class="k">component</span><span class="w"> </span><span class="nc">Ram_1w_1rs</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="w">    </span><span class="k">generic</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">wordCount</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wordWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">clockCrossing</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">boolean</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">technology</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">readUnderWrite</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wrAddressWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wrDataWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wrMaskWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wrMaskEnable</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">boolean</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rdAddressWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rdDataWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rdEnEnable</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">boolean</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">port</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">wr_clk</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wr_en</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wr_mask</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wr_addr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wr_data</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rd_clk</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rd_en</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rd_addr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rd_data</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">component</span><span class="p">;</span><span class="w"></span>

<span class="c1">-- Single port (1 readWrite port)</span><span class="w"></span>
<span class="k">component</span><span class="w"> </span><span class="nc">Ram_1wrs</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="w">    </span><span class="k">generic</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">wordCount</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wordWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">readUnderWrite</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">technology</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">port</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">clk</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">en</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">addr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wrData</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">rdData</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">component</span><span class="p">;</span><span class="w"></span>

<span class="c1">--True dual port (2 readWrite port)</span><span class="w"></span>
<span class="k">component</span><span class="w"> </span><span class="nc">Ram_2wrs</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="w">    </span><span class="k">generic</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">wordCount</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">wordWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">clockCrossing</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">boolean</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">technology</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portA_readUnderWrite</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portA_addressWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portA_dataWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portA_maskWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portA_maskEnable</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">boolean</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portB_readUnderWrite</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portB_addressWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portB_dataWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portB_maskWidth</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portB_maskEnable</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">boolean</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">port</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">portA_clk</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portA_en</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portA_wr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portA_mask</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portA_addr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portA_wrData</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portA_rdData</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portB_clk</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portB_en</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portB_wr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portB_mask</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portB_addr</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portB_wrData</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">portB_rdData</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">component</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>如你所见, 黑盒有一个技术参数。你可以在对应的mem上用<code class="docutils literal notranslate"><span class="pre">setTechnology</span></code>函数来设置它。当前有4中可用的技术：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">auto</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ramBlock</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">distributedLut</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">registerFile</span></code></p></li>
</ul>
<div STYLE="page-break-after: always;"></div></section>
</section>
</section>
<section id="design-errors">
<h1>设计错误(Design Errors)<a class="headerlink" href="#design-errors" title="Permalink to this heading"></a></h1>
<section id="id42">
<h2>简介(Introduction)<a class="headerlink" href="#id42" title="Permalink to this heading"></a></h2>
<p>SpinalHDL编译器会做很多设计检查，来确保生成的VHDL/Verilog是可仿真的可综合的。基本上，SpinalHDL不会生成破损的VHDL/Verilog设计。以下是SpinalHDL检查的简要概括:</p>
<ul class="simple">
<li><p>重复赋值</p></li>
<li><p>时钟域交叉</p></li>
<li><p>层次化违例</p></li>
<li><p>组合逻辑环路</p></li>
<li><p>Latch</p></li>
<li><p>未驱动的信号</p></li>
<li><p>位宽不匹配</p></li>
<li><p>得不到的switch生命</p></li>
</ul>
<p>在每个SpinalHDL错误报告中，你会得到栈轨迹(stack trace)，能够帮你精准地确定哪里出错。这个设计检查第一次可能会感到有些过犹不及，但一旦你跳脱出传统的硬件描述方式这会变得非常宝贵。</p>
</section>
<section id="assignment-overlap">
<h2>赋值覆盖(Assignment Overlap)<a class="headerlink" href="#assignment-overlap" title="Permalink to this heading"></a></h2>
<section id="id43">
<h3>一、简介<a class="headerlink" href="#id43" title="Permalink to this heading"></a></h3>
<p>SpinalHDL将会检查, 没有任何的信号赋值会完全抹除前面的赋值。</p>
</section>
<section id="id44">
<h3>二、例子<a class="headerlink" href="#id44" title="Permalink to this heading"></a></h3>
<p>下列代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">66</span><span class="w"> </span><span class="c1">// Erase the a := 42 assignment</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>将会产生如下报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ASSIGNMENT</span> <span class="n">OVERLAP</span> <span class="n">completely</span> <span class="n">the</span> <span class="n">previous</span> <span class="n">one</span> <span class="n">of</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">a</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span>
  <span class="o">***</span>
  <span class="n">Source</span> <span class="n">file</span> <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">66</span> <span class="n">assignment</span> <span class="n">via</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">trace</span>
  <span class="o">***</span>
</pre></div>
</div>
<p>可以修复为：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">something</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">66</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>但当某些情况下, 如果用户真的需要去覆盖掉之前的赋值(因为在某些时候覆盖是有意义的), 则可以使用如下表达：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="p">.</span><span class="n">allowOverride</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">66</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="clock-crossing-violation">
<h2>跨时钟域违例(Clock crossing violation)<a class="headerlink" href="#clock-crossing-violation" title="Permalink to this heading"></a></h2>
<section id="id45">
<h3>一、简介<a class="headerlink" href="#id45" title="Permalink to this heading"></a></h3>
<p>SpinalHDL会检查用户设计中的寄存器只会与相同时钟域的寄存器以组合逻辑方式连接。</p>
</section>
<section id="id46">
<h3>二、例子<a class="headerlink" href="#id46" title="Permalink to this heading"></a></h3>
<p>下述代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">clkA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">external</span><span class="p">(</span><span class="s">&quot;clkA&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">clkB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">external</span><span class="p">(</span><span class="s">&quot;clkB&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">regA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clkA</span><span class="p">(</span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w">   </span><span class="c1">// PlayDev.scala:834</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">regB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clkB</span><span class="p">(</span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w">   </span><span class="c1">// PlayDev.scala:835</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regA</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">regA</span><span class="w">                </span><span class="c1">// PlayDev.scala:838</span>
<span class="w">  </span><span class="n">regB</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>会报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CLOCK</span> <span class="n">CROSSING</span> <span class="n">VIOLATION</span> <span class="kn">from</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">regA</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span> <span class="n">to</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">regB</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span><span class="o">.</span>
<span class="o">-</span> <span class="n">Register</span> <span class="n">declaration</span> <span class="n">at</span>
  <span class="o">***</span>
  <span class="n">Source</span> <span class="n">file</span> <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="n">toplevel</span><span class="o">/</span><span class="n">regA</span> <span class="n">definition</span> <span class="n">via</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">trace</span>
  <span class="o">***</span>
<span class="o">-</span> <span class="n">through</span>
      <span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">regA</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span> <span class="n">at</span> <span class="o">***</span><span class="p">(</span><span class="n">PlayDev</span><span class="o">.</span><span class="n">scala</span><span class="p">:</span><span class="mi">834</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span>
      <span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">tmp</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span> <span class="n">at</span> <span class="o">***</span><span class="p">(</span><span class="n">PlayDev</span><span class="o">.</span><span class="n">scala</span><span class="p">:</span><span class="mi">838</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span>
      <span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">regB</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span> <span class="n">at</span> <span class="o">***</span><span class="p">(</span><span class="n">PlayDev</span><span class="o">.</span><span class="n">scala</span><span class="p">:</span><span class="mi">835</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>有多种修改方式如下：</p>
<ol>
<li><p>跨时钟域标记(crossClockDomain tag)</p>
<p>可以利用<code class="docutils literal notranslate"><span class="pre">crossClockDomain</span></code>来向SpinalHDL编译器传递“不用担心这种跨时钟赋值”的信息：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">clkA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">external</span><span class="p">(</span><span class="s">&quot;clkA&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">clkB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">external</span><span class="p">(</span><span class="s">&quot;clkB&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">regA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clkA</span><span class="p">(</span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">regB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clkB</span><span class="p">(</span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))).</span><span class="n">addTag</span><span class="p">(</span><span class="n">crossClockDomain</span><span class="p">)</span><span class="w"></span>


<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regA</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">regA</span><span class="w"></span>
<span class="w">    </span><span class="n">regB</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>setSyncronousWith</p>
<p>用户还可以通过使用一个<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>对象的<code class="docutils literal notranslate"><span class="pre">setSynchronousWith</span></code>方法指定两个时钟域一起同步。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">clkA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">external</span><span class="p">(</span><span class="s">&quot;clkA&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">clkB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">external</span><span class="p">(</span><span class="s">&quot;clkB&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">clkB</span><span class="p">.</span><span class="n">setSyncronousWith</span><span class="p">(</span><span class="n">clkA</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">regA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clkA</span><span class="p">(</span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">regB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clkB</span><span class="p">(</span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>


<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">regA</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">regA</span><span class="w"></span>
<span class="w">    </span><span class="n">regB</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>BufferCC</p>
<p>当交换单比特信号(如Bool类型), 或格雷码时, 可以使用BufferCC安全地跨时钟域。</p>
<blockquote>
<div><p><strong>警告：不要对多比特信号使用BufferCC, 因为如果时钟是异步的, 接收端有损坏读取的风险。更多信息请参见“Clock Domain”章节。</strong></p>
</div></blockquote>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">AsyncFifo</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">popToPushGray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">ptrWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">pushToPopGray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">ptrWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">pushCC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockingArea</span><span class="p">(</span><span class="n">pushClock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">pushPtr</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Counter</span><span class="p">(</span><span class="n">depth</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">pushPtrGray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">toGray</span><span class="p">(</span><span class="n">pushPtr</span><span class="p">.</span><span class="n">valueNext</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">popPtrGray</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">BufferCC</span><span class="p">(</span><span class="n">popToPushGray</span><span class="p">,</span><span class="w"> </span><span class="nc">B</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">ptrWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">full</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">isFull</span><span class="p">(</span><span class="n">pushPtrGray</span><span class="p">,</span><span class="w"> </span><span class="n">popPtrGray</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">popCC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockingArea</span><span class="p">(</span><span class="n">popClock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">popPtr</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="nc">Counter</span><span class="p">(</span><span class="n">depth</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">popPtrGray</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">toGray</span><span class="p">(</span><span class="n">popPtr</span><span class="p">.</span><span class="n">valueNext</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">pushPtrGray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BufferCC</span><span class="p">(</span><span class="n">pushToPopGray</span><span class="p">,</span><span class="w"> </span><span class="nc">B</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">ptrWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">empty</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">isEmpty</span><span class="p">(</span><span class="n">popPtrGray</span><span class="p">,</span><span class="w"> </span><span class="n">pushPtrGray</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="combinatorial-loop">
<h2>组合环(Combinatorial loop)<a class="headerlink" href="#combinatorial-loop" title="Permalink to this heading"></a></h2>
<section id="id47">
<h3>一、简介<a class="headerlink" href="#id47" title="Permalink to this heading"></a></h3>
<p>SpinalHDL会检查设计中没有组合逻辑环的存在。</p>
</section>
<section id="id48">
<h3>二、例子<a class="headerlink" href="#id48" title="Permalink to this heading"></a></h3>
<p>下述代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="c1">// PlayDev.scala line 831</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="c1">// PlayDev.scala line 832</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
<span class="w">  </span><span class="n">d</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">  </span><span class="n">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>会报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">COMBINATORIAL</span> <span class="n">LOOP</span> <span class="p">:</span>
  <span class="n">Partial</span> <span class="n">chain</span> <span class="p">:</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">a</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span> <span class="n">at</span> <span class="o">***</span><span class="p">(</span><span class="n">PlayDev</span><span class="o">.</span><span class="n">scala</span><span class="p">:</span><span class="mi">831</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">d</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span> <span class="n">at</span> <span class="o">***</span><span class="p">(</span><span class="n">PlayDev</span><span class="o">.</span><span class="n">scala</span><span class="p">:</span><span class="mi">834</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">b</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span> <span class="n">at</span> <span class="o">***</span><span class="p">(</span><span class="n">PlayDev</span><span class="o">.</span><span class="n">scala</span><span class="p">:</span><span class="mi">832</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">a</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span> <span class="n">at</span> <span class="o">***</span><span class="p">(</span><span class="n">PlayDev</span><span class="o">.</span><span class="n">scala</span><span class="p">:</span><span class="mi">831</span><span class="p">)</span> <span class="o">&gt;&gt;&gt;</span>

  <span class="n">Full</span> <span class="n">chain</span> <span class="p">:</span>
    <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">a</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span>
    <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">d</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span>
    <span class="p">(</span><span class="n">UInt</span> <span class="o">|</span> <span class="n">UInt</span><span class="p">)[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">]</span>
    <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">b</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span>
    <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">a</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span>
</pre></div>
</div>
<p>可能的修复方式为:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="c1">// PlayDev.scala line 831</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="c1">// PlayDev.scala line 832</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">d</span><span class="w"></span>
<span class="w">  </span><span class="n">d</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="w">  </span><span class="n">c</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="false-positives">
<h3>三、假阳性(false-positives)<a class="headerlink" href="#false-positives" title="Permalink to this heading"></a></h3>
<p>SpinalHDL检测组合逻辑环的策略是悲观的, 因此可能出现误报的情况。假如发生了误报, 用户可以无效化对某一信号的环检测, 如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">// 因为这行而发生了误报</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>可以被修复为：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">).</span><span class="n">noCombLoopCheck</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>还应该指出, 诸如(a(1):= a(0))这样的赋值会使Verilator等工具无法匹配。在这种情况下, 使用Vec(Bool, 8)可能会更好。</p>
</section>
</section>
<section id="hierarchy-violation">
<h2>层次违例(Hierarchy violation)<a class="headerlink" href="#hierarchy-violation" title="Permalink to this heading"></a></h2>
<section id="id49">
<h3>一、简介<a class="headerlink" href="#id49" title="Permalink to this heading"></a></h3>
<p>SpinalHDL将会检查当前层次设计的信号不会访问到该组件的外部区域。</p>
<p>下述信号可以被一个组件内所访问：</p>
<ul class="simple">
<li><p>在当前组件中定义的所有无方向(directionless)信号</p></li>
<li><p>当前组件的所有输入/输出和IO信号</p></li>
<li><p>子(child)组件的所有输入/输出和IO信号</p></li>
</ul>
<p>同时, 下列信号可以被分配赋值到组件内部：</p>
<ul class="simple">
<li><p>在当前组件中定义的所有无方向(directionless)信号</p></li>
<li><p>当前组件的所有输出和IO信号</p></li>
<li><p>子组件的所有输入/输出信号</p></li>
</ul>
<p>如果发生了一个<code class="docutils literal notranslate"><span class="pre">HIERARCHY</span> <span class="pre">VIOLATION</span></code>错误, 意味着上述的某一规则被违反。</p>
</section>
<section id="id50">
<h3>二、例子<a class="headerlink" href="#id50" title="Permalink to this heading"></a></h3>
<p>下列代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">U</span><span class="s">&quot;x42&quot;</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>会产生如下报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>HIERARCHY VIOLATION : (toplevel/io_a : in UInt[8 bits]) is driven by (toplevel/tmp :  UInt[8 bits]), but isn&#39;t accessible in the toplevel component.
  ***
  Source file location of the `io.a := tmp` via the stack trace
  ***
</pre></div>
</div>
<p>修复如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="c1">// in转为out</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">U</span><span class="s">&quot;x42&quot;</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tmp</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="io">
<h2>IO包<a class="headerlink" href="#io" title="Permalink to this heading"></a></h2>
<section id="id51">
<h3>一、简介<a class="headerlink" href="#id51" title="Permalink to this heading"></a></h3>
<p>SpinalHDL会检查每个<code class="docutils literal notranslate"><span class="pre">IO</span></code>包定义内都只有in/out/inout信号。</p>
</section>
<section id="id52">
<h3>二、例子<a class="headerlink" href="#id52" title="Permalink to this heading"></a></h3>
<p>下述代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>将会报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">IO</span> <span class="n">BUNDLE</span> <span class="n">ERROR</span> <span class="p">:</span> <span class="n">A</span> <span class="n">direction</span> <span class="n">less</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">io_a</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span> <span class="n">signal</span> <span class="n">was</span> <span class="n">defined</span> <span class="n">into</span> <span class="n">toplevel</span> <span class="n">component</span><span class="s1">&#39;s io bundle</span>
  <span class="o">***</span>
  <span class="n">Source</span> <span class="n">file</span> <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="n">toplevel</span><span class="o">/</span><span class="n">io_a</span> <span class="n">definition</span> <span class="n">via</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">trace</span>
  <span class="o">***</span>
</pre></div>
</div>
<p>修复如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>但是可能对于元(meta)硬件的设计真的需要<code class="docutils literal notranslate"><span class="pre">io.a</span></code>是无方向的, 则可以用：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="p">.</span><span class="n">allowDirectionLessIo</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="latch-detected">
<h2>锁存器检测(Latch detected)<a class="headerlink" href="#latch-detected" title="Permalink to this heading"></a></h2>
<section id="id53">
<h3>一、简介<a class="headerlink" href="#id53" title="Permalink to this heading"></a></h3>
<p>SpinalHDL会检查在综合时没有组合逻辑信号会引入锁存器。换句话说, 这是检查没有组合信号被部分赋值。</p>
</section>
<section id="id54">
<h3>二、例子<a class="headerlink" href="#id54" title="Permalink to this heading"></a></h3>
<p>下述代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nc">Bool</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>会产生如下报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LATCH</span> <span class="n">DETECTED</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">combinatorial</span> <span class="n">signal</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">a</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">]),</span> <span class="n">defined</span> <span class="n">at</span>
  <span class="o">***</span>
  <span class="n">Source</span> <span class="n">file</span> <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="n">toplevel</span><span class="o">/</span><span class="n">io_a</span> <span class="n">definition</span> <span class="n">via</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">trace</span>
  <span class="o">***</span>
</pre></div>
</div>
<p>修复为：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nc">Bool</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="no-driver-on">
<h2>无驱动检测(no driver on)<a class="headerlink" href="#no-driver-on" title="Permalink to this heading"></a></h2>
<section id="id55">
<h3>一、简介<a class="headerlink" href="#id55" title="Permalink to this heading"></a></h3>
<p>SpinalHDL将会检查设计中所有使用的组合逻辑信号都有相应的赋值连线声明。</p>
</section>
<section id="id56">
<h3>二、例子<a class="headerlink" href="#id56" title="Permalink to this heading"></a></h3>
<p>下述代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>会产生如下报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NO</span> <span class="n">DRIVER</span> <span class="n">ON</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">a</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">]),</span> <span class="n">defined</span> <span class="n">at</span>
  <span class="o">***</span>
  <span class="n">Source</span> <span class="n">file</span> <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="n">toplevel</span><span class="o">/</span><span class="n">a</span> <span class="n">definition</span> <span class="n">via</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">trace</span>
  <span class="o">***</span>
</pre></div>
</div>
<p>修复如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="w">  </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="nullpointerexception">
<h2>排除空指针(NullPointerException)<a class="headerlink" href="#nullpointerexception" title="Permalink to this heading"></a></h2>
<section id="id57">
<h3>一、简介<a class="headerlink" href="#id57" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">NullPointerException</span></code>是一个Scala运行时的报错, 它会在一个变量在初始化前就被访问时发生。</p>
</section>
<section id="id58">
<h3>二、例子<a class="headerlink" href="#id58" title="Permalink to this heading"></a></h3>
<p>下述代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>将会报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ne">Exception</span> <span class="ow">in</span> <span class="n">thread</span> <span class="s2">&quot;main&quot;</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="n">NullPointerException</span>
  <span class="o">***</span>
  <span class="n">Source</span> <span class="n">file</span> <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">42</span> <span class="n">assignment</span> <span class="n">via</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">trace</span>
  <span class="o">***</span>
</pre></div>
</div>
<p>修复为：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ol>
<li><p>问题解释(Issue explanation)</p>
<p>SpinalHDL不是一门语言, 它是一个Scala库, 这意味着它遵守与Scala通用编程语言相同的规则。</p>
<p>当运行上面的SpinalHDL硬件描述来生成相应的VHDL/Verilog RTL时, SpinalHDL硬件描述将作为一个Scala程序执行, 并且a将是一个空引用, 直到程序执行<code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">UInt(8</span> <span class="pre">bits)</span></code>, 所以在此之前试图给它赋值将导致<code class="docutils literal notranslate"><span class="pre">NullPointerException</span></code>。</p>
</li>
</ol>
</section>
</section>
<section id="register-defined-as-component-input">
<h2>定义为组件输入的寄存器(Register defined as component input)<a class="headerlink" href="#register-defined-as-component-input" title="Permalink to this heading"></a></h2>
<section id="id59">
<h3>一、简介<a class="headerlink" href="#id59" title="Permalink to this heading"></a></h3>
<p>在SpinalHDL中, 用户不被允许定义一个将寄存器作为输入的组件。原因是为了预防可能发生的意外, 如用户会尝试着将寄存器信号作为子组件的输入驱动。如果确实需要一个寄存器输入, 用户可以在<code class="docutils literal notranslate"><span class="pre">io</span></code>包中先定义一个非寄存器输入, 随后在组件内部对其添加寄存器。</p>
</section>
<section id="id60">
<h3>二、例子<a class="headerlink" href="#id60" title="Permalink to this heading"></a></h3>
<p>下述代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>会产生如下报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">REGISTER</span> <span class="n">DEFINED</span> <span class="n">AS</span> <span class="n">COMPONENT</span> <span class="n">INPUT</span> <span class="p">:</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">io_a</span> <span class="p">:</span> <span class="ow">in</span> <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span> <span class="ow">is</span> <span class="n">defined</span> <span class="k">as</span> <span class="n">a</span> <span class="n">registered</span> <span class="nb">input</span> <span class="n">of</span> <span class="n">the</span> <span class="n">toplevel</span> <span class="n">component</span><span class="p">,</span> <span class="n">but</span> <span class="n">isn</span><span class="s1">&#39;t allowed.</span>
  <span class="o">***</span>
  <span class="n">Source</span> <span class="n">file</span> <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="n">toplevel</span><span class="o">/</span><span class="n">io_a</span> <span class="n">definition</span> <span class="n">via</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">trace</span>
  <span class="o">***</span>
</pre></div>
</div>
<p>修复为：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果需要一个寄存器信号<code class="docutils literal notranslate"><span class="pre">a</span></code>, 可以按照如下方式使用：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="scope-violation">
<h2>作用域违例(Scope violation)<a class="headerlink" href="#scope-violation" title="Permalink to this heading"></a></h2>
<section id="id61">
<h3>一、简介<a class="headerlink" href="#id61" title="Permalink to this heading"></a></h3>
<p>SpinalHDL将会检查没有信号会在超出其定义的作用域之外被赋值使用。这个错误不容易触发, 因为它需要一些特定的元硬件描述技巧。</p>
</section>
<section id="id62">
<h3>二、例子<a class="headerlink" href="#id62" title="Permalink to this heading"></a></h3>
<p>下述代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="w"></span>
<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">tmp</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">U</span><span class="s">&quot;x42&quot;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>会报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SCOPE</span> <span class="n">VIOLATION</span> <span class="p">:</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">tmp</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span> <span class="ow">is</span> <span class="n">assigned</span> <span class="n">outside</span> <span class="n">its</span> <span class="n">declaration</span> <span class="n">scope</span> <span class="n">at</span>
  <span class="o">***</span>
  <span class="n">Source</span> <span class="n">file</span> <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="n">tmp</span> <span class="o">:=</span> <span class="sa">U</span><span class="s2">&quot;x42&quot;</span> <span class="n">via</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">trace</span>
  <span class="o">***</span>
</pre></div>
</div>
<p>修复为：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">tmp</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">U</span><span class="s">&quot;x42&quot;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="spinal-spinal-cant-clone-class">
<h2>Spinal无法克隆类(Spinal can’t clone class)<a class="headerlink" href="#spinal-spinal-cant-clone-class" title="Permalink to this heading"></a></h2>
<section id="id63">
<h3>一、简介<a class="headerlink" href="#id63" title="Permalink to this heading"></a></h3>
<p>当SpinalHDL想要通过<code class="docutils literal notranslate"><span class="pre">cloneOf</span></code>函数创建一个新的数据类型实例, 但是不能这样做时, 就会发生这个错误。出现这种情况的原因总是因为它无法检索<code class="docutils literal notranslate"><span class="pre">Bundle</span></code>的构造参数。</p>
</section>
<section id="id64">
<h3>二、例子1<a class="headerlink" href="#id64" title="Permalink to this heading"></a></h3>
<p>下述代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// cloneOf(this)无法检索用于构造自身的位宽</span>
<span class="k">class</span><span class="w"> </span><span class="nc">RGB</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">RGB</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="c1">// Stream需要cloneOf(new RGB(8))的功能</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>将会报错：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="o">***</span><span class="w"> </span><span class="nc">Spinal</span><span class="w"> </span><span class="n">can</span><span class="ss">&#39;t</span><span class="w"> </span><span class="n">clone</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">spinal</span><span class="p">.</span><span class="n">tester</span><span class="p">.</span><span class="nc">PlayDevMessages$RGB</span><span class="w"> </span><span class="n">datatype</span><span class="w"></span>
<span class="o">***</span><span class="w"> </span><span class="nc">You</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="n">way</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">solve</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="p">:</span><span class="w"></span>
<span class="o">***</span><span class="w"> </span><span class="nc">In</span><span class="w"> </span><span class="n">place</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="s">&quot;class Bundle(args){}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">create</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="s">&quot;case class Bundle(args){}&quot;</span><span class="w"></span>
<span class="o">***</span><span class="w"> </span><span class="nc">Or</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">your</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">bundle</span><span class="w"> </span><span class="n">clone</span><span class="w"> </span><span class="n">function</span><span class="w"></span>
<span class="w">  </span><span class="o">***</span><span class="w"></span>
<span class="w">  </span><span class="nc">Source</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="n">location</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="nc">RGB</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">definition</span><span class="w"> </span><span class="n">via</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="n">trace</span><span class="w"></span>
<span class="w">  </span><span class="o">***</span><span class="w"></span>
</pre></div>
</div>
<p>修复为：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">RGB</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">RGB</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id65">
<h3>二、例子2<a class="headerlink" href="#id65" title="Permalink to this heading"></a></h3>
<p>下列代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Xlen</span><span class="p">(</span><span class="kd">val</span><span class="w"> </span><span class="n">xlen</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MemoryAddress</span><span class="p">()(</span><span class="k">implicit</span><span class="w"> </span><span class="n">xlenConfig</span><span class="p">:</span><span class="w"> </span><span class="nc">Xlen</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">xlenConfig</span><span class="p">.</span><span class="n">xlen</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">DebugMemory</span><span class="p">(</span><span class="k">implicit</span><span class="w"> </span><span class="n">config</span><span class="p">:</span><span class="w"> </span><span class="nc">Xlen</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">inputAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nc">MemoryAddress</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">someAddress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">inputAddress</span><span class="p">)</span><span class="w"> </span><span class="c1">// -&gt; ERROR *****************************</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">error</span><span class="p">]</span> <span class="o">***</span> <span class="n">Spinal</span> <span class="n">can</span><span class="s1">&#39;t clone class debug.MemoryAddress datatype</span>
</pre></div>
</div>
<p>在这种情况下, 一种解决方案是覆盖克隆函数来传播隐式参数。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MemoryAddress</span><span class="p">()(</span><span class="k">implicit</span><span class="w"> </span><span class="n">xlenConfig</span><span class="p">:</span><span class="w"> </span><span class="nc">Xlen</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">xlenConfig</span><span class="p">.</span><span class="n">xlen</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">clone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">MemoryAddress</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p><strong>注意：我们需要克隆的是硬件的单元, 而不是最终在其中赋值的值</strong></p>
</div></blockquote>
<blockquote>
<div><p><strong>注意：另一种方法是使用ScopeProperty(请见”其他语言特性”章节中)</strong></p>
</div></blockquote>
</section>
</section>
<section id="unassigned-register">
<h2>未分配的寄存器(Unassigned register)<a class="headerlink" href="#unassigned-register" title="Permalink to this heading"></a></h2>
<section id="id66">
<h3>一、简介<a class="headerlink" href="#id66" title="Permalink to this heading"></a></h3>
<p>SpinalHDL将会检查所有设计中有用的寄存器都被分配了。</p>
</section>
<section id="id67">
<h3>二、例子<a class="headerlink" href="#id67" title="Permalink to this heading"></a></h3>
<p>下述代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>会报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UNASSIGNED</span> <span class="n">REGISTER</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">a</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">]),</span> <span class="n">defined</span> <span class="n">at</span>
  <span class="o">***</span>
  <span class="n">Source</span> <span class="n">file</span> <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="n">toplevel</span><span class="o">/</span><span class="n">a</span> <span class="n">definition</span> <span class="n">via</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">trace</span>
  <span class="o">***</span>
</pre></div>
</div>
<p>可以修复为：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="w">  </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="register-with-only-init">
<h3>三、只有初始化的寄存器(Register with only init)<a class="headerlink" href="#register-with-only-init" title="Permalink to this heading"></a></h3>
<p>在某些情况下, 可能由于硬件参数化, 生成只有<code class="docutils literal notranslate"><span class="pre">init</span></code>描述但无分配的寄存器也是有意义的。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">something</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">somethingElse</span><span class="w">  </span><span class="c1">//有问题，这个可综合</span>
<span class="w">  </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>会报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UNASSIGNED</span> <span class="n">REGISTER</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">a</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">]),</span> <span class="n">defined</span> <span class="n">at</span>
  <span class="o">***</span>
  <span class="n">Source</span> <span class="n">file</span> <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="n">toplevel</span><span class="o">/</span><span class="n">a</span> <span class="n">definition</span> <span class="n">via</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">trace</span>
  <span class="o">***</span>
</pre></div>
</div>
<p>为了修复它, 可以让SpinalHDL转换该只有<code class="docutils literal notranslate"><span class="pre">init</span></code>描述但未分配的寄存器为一个组合逻辑：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)).</span><span class="n">init</span><span class="p">(</span><span class="mi">42</span><span class="p">).</span><span class="n">allowUnsetRegToAvoidLatch</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">something</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">somethingElse</span><span class="w"></span>
<span class="w">  </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="is-unreachable-is-statement">
<h2>无法实现的is表述(Unreachable is statement)<a class="headerlink" href="#is-unreachable-is-statement" title="Permalink to this heading"></a></h2>
<section id="id68">
<h3>一、简介<a class="headerlink" href="#id68" title="Permalink to this heading"></a></h3>
<p>SpinalHDL会检查并确保<code class="docutils literal notranslate"><span class="pre">switch</span></code>中的所有<code class="docutils literal notranslate"><span class="pre">is</span></code>语句是可实现的</p>
</section>
<section id="id69">
<h3>二、例子<a class="headerlink" href="#id69" title="Permalink to this heading"></a></h3>
<p>下述代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">sel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">switch</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="mi">0</span><span class="p">){</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="mi">2</span><span class="p">){</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="mi">3</span><span class="p">){</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="mi">0</span><span class="p">){</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// 复制 is 语句!</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>会报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">UNREACHABLE</span> <span class="n">IS</span> <span class="n">STATEMENT</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">switch</span> <span class="n">statement</span> <span class="n">at</span>
  <span class="o">***</span>
  <span class="n">Source</span> <span class="n">file</span> <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="ow">is</span> <span class="n">statement</span> <span class="n">definition</span> <span class="n">via</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">trace</span>
  <span class="o">***</span>
</pre></div>
</div>
<p>可修复为：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">sel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">switch</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="mi">0</span><span class="p">){</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="mi">2</span><span class="p">){</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="mi">3</span><span class="p">){</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="width-mismatch">
<h2>位宽不匹配(Width mismatch)<a class="headerlink" href="#width-mismatch" title="Permalink to this heading"></a></h2>
<section id="id70">
<h3>一、简介<a class="headerlink" href="#id70" title="Permalink to this heading"></a></h3>
<p>SpinalHDL会检查赋值两侧的操作和信号有相同的位宽。</p>
</section>
<section id="id71">
<h3>二、分配赋值例子<a class="headerlink" href="#id71" title="Permalink to this heading"></a></h3>
<p>下述代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>将会报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">WIDTH</span> <span class="n">MISMATCH</span> <span class="n">on</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">b</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">4</span> <span class="n">bits</span><span class="p">])</span> <span class="o">:=</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">a</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span> <span class="n">at</span>
  <span class="o">***</span>
  <span class="n">Source</span> <span class="n">file</span> <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="n">OR</span> <span class="n">operator</span> <span class="n">via</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">trace</span>
  <span class="o">***</span>
</pre></div>
</div>
<p>可以修复为：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">resized</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id72">
<h3>三、操作实例<a class="headerlink" href="#id72" title="Permalink to this heading"></a></h3>
<p>下述代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>将会报错：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">WIDTH</span> <span class="n">MISMATCH</span> <span class="n">on</span> <span class="p">(</span><span class="n">UInt</span> <span class="o">|</span> <span class="n">UInt</span><span class="p">)[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">]</span>
<span class="o">-</span> <span class="n">Left</span>  <span class="n">operand</span> <span class="p">:</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">a</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">8</span> <span class="n">bits</span><span class="p">])</span>
<span class="o">-</span> <span class="n">Right</span> <span class="n">operand</span> <span class="p">:</span> <span class="p">(</span><span class="n">toplevel</span><span class="o">/</span><span class="n">b</span> <span class="p">:</span>  <span class="n">UInt</span><span class="p">[</span><span class="mi">4</span> <span class="n">bits</span><span class="p">])</span>
  <span class="n">at</span>
  <span class="o">***</span>
  <span class="n">Source</span> <span class="n">file</span> <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="n">OR</span> <span class="n">operator</span> <span class="n">via</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">trace</span>
  <span class="o">***</span>
</pre></div>
</div>
<p>可修复为：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">resized</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div STYLE="page-break-after: always;"></div></section>
</section>
</section>
<section id="other-language-features">
<h1>其他语言特征(Other language features)<a class="headerlink" href="#other-language-features" title="Permalink to this heading"></a></h1>
<section id="id73">
<h2>简介<a class="headerlink" href="#id73" title="Permalink to this heading"></a></h2>
<p>SpinalHDL语言的核心(Core)为多个特性(Features)定义了相应的语法：</p>
<ul class="simple">
<li><p>Types (类型) / Literal (字面量)</p></li>
<li><p>Register / Clock domains</p></li>
<li><p>Component / Area</p></li>
<li><p>RAM / ROM</p></li>
<li><p>When / Switch / Mux</p></li>
<li><p>BlackBox (用于将Verilog或VHDL的IP核整合入SpinalHDL)</p></li>
<li><p>SpinalHDL to VHDL converter</p></li>
</ul>
<p>随后, 利用这些特性, 用户可以定义数字硬件电路, 并且建立功能强大的库(Libraries)以及抽象(Abstractions)。SpinalHDL语言相比于其他HDL语言的一个主要优点在于：没有编译相关知识的用户依然可以拓展语言。</p>
<p>印证上述优点的其中一个例子是 <code class="docutils literal notranslate"><span class="pre">Spinal</span> <span class="pre">Lib</span></code> (请见<strong>Libraries</strong>章节), 它增加了许多实用程序(Utilities)、工具(Tools)、总线(Buses)以及其他方法(Methodologies)。</p>
<p>为了使用本章接下来介绍的这些特性, 用户需要在自己的代码中添加<code class="docutils literal notranslate"><span class="pre">&quot;import</span> <span class="pre">spinal.core._&quot;</span></code>字段。</p>
</section>
<section id="utils">
<h2>工具(Utils)<a class="headerlink" href="#utils" title="Permalink to this heading"></a></h2>
<section id="id74">
<h3>一、 总览<a class="headerlink" href="#id74" title="Permalink to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">句式</th>
<th style="text-align: center;">返回<br>类型</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>widthOf(x : BitVector)</code></td>
<td style="text-align: center;">Int</td>
<td style="text-align: center;">返回一个类型为Bits/UInt/SInt的信号的位宽</td>
</tr>
<tr>
<td style="text-align: center;"><code>log2Up(x : BigInt)</code></td>
<td style="text-align: center;">Int</td>
<td style="text-align: center;">返回表示输入状态<code>x</code>所需要的位数</td>
</tr>
<tr>
<td style="text-align: center;"><code>isPow2(x : BigInt)</code></td>
<td style="text-align: center;">Boolean</td>
<td style="text-align: center;">当<code>x</code>为2的指数时, 返回<code>True</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>roundUp(</code><br><code>that : BigInt,</code><br><code>by : BigInt)</code></td>
<td style="text-align: center;">BigInt</td>
<td style="text-align: center;">返回参数<code>by</code>乘参数<code>that</code>的结果</td>
</tr>
<tr>
<td style="text-align: center;"><code>Cat(x : Data*)</code></td>
<td style="text-align: center;">Bits</td>
<td style="text-align: center;">连接所有的参数, 其中第一个参数会放置在最高有效位(MSB), 最后一个参数放置在最低有效位(LSB)</td>
</tr>
</tbody>
</table></section>
<section id="cloning-hardware-datatypes">
<h3>二、克隆硬件数据类型(Cloning hardware datatypes)<a class="headerlink" href="#cloning-hardware-datatypes" title="Permalink to this heading"></a></h3>
<p>用户可以通过<code class="docutils literal notranslate"><span class="pre">cloneOf(x)</span></code>函数克隆给定的硬件数据类型。该函数将会返回一个拥有相同Scala类型和参数的新实例。例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">plusOne</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 将会生成一个和`value`同位宽的UInt类型</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cloneOf</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">temp</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">temp</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// treePlusOne 将会成为一个8比特的值</span>
<span class="kd">val</span><span class="w"> </span><span class="n">treePlusOne</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plusOne</span><span class="p">(</span><span class="nc">U</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p><strong>注意！：若对一个<code class="docutils literal notranslate"><span class="pre">Bundle</span></code>类型使用<code class="docutils literal notranslate"><span class="pre">cloneOf(x)</span></code>函数功能, 需要确保该<code class="docutils literal notranslate"><span class="pre">Bundle</span></code>是一个<code class="docutils literal notranslate"><span class="pre">case</span></code>类, 否则需要在<code class="docutils literal notranslate"><span class="pre">Bundle</span></code>内部重写克隆函数。</strong></p>
</div></blockquote>
</section>
<section id="passing-a-datatype-as-construction-parameter">
<h3>三、传递数据类型作为结构参数(Passing a datatype as construction parameter)<a class="headerlink" href="#passing-a-datatype-as-construction-parameter" title="Permalink to this heading"></a></h3>
<p>许多可重用的硬件要求能够被一些数据类型所参数化。例如如果用户想要定义一个FIFO或者移位寄存器, 则需要一个参数来定义该硬件所需的负载。</p>
<ol>
<li><p>传统方式</p>
<p>以定义一个<code class="docutils literal notranslate"><span class="pre">ShiftRegister</span></code>元件为例, 介绍传统的传递数据类型方式如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ShiftRegister</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">dataType</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">input</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="p">(</span><span class="n">cloneOf</span><span class="p">(</span><span class="n">dataType</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="n">cloneOf</span><span class="p">(</span><span class="n">dataType</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="c1">//需要在Case Class内部重写`cloneof`函数</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>实例化该元件的代码为：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">shiftReg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ShiftRegister</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>在上述例子中, 硬件的数据类型（位宽）直接作为构造参数传递。因此每次需要例化或是用该datatype时, 都需要使用<code class="docutils literal notranslate"><span class="pre">cloneOf</span></code>函数对其datatype进行定义。这种方式并不安全因为通常<code class="docutils literal notranslate"><span class="pre">cloneOf</span></code>函数会被遗忘。</p>
</li>
<li><p>更安全的方式</p>
<p>以更安全的方式来传递数据类型的例子如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ShiftRegister</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">dataType</span><span class="p">:</span><span class="w"> </span><span class="nc">HardType</span><span class="p">[</span><span class="nc">T</span><span class="p">],</span><span class="w"> </span><span class="n">depth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">input</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="p">(</span><span class="n">dataType</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="n">dataType</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>实例化该元件的代码为：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">shiftReg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ShiftRegister</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>在上述的更安全的方法中, 使用了<code class="docutils literal notranslate"><span class="pre">HardType</span></code>去封装数据类型<code class="docutils literal notranslate"><span class="pre">T</span></code>, 可以看成是<code class="docutils literal notranslate"><span class="pre">T</span></code>的蓝图(blueprint)。这种方式相比于传统方式更加简单, 因为每次例化使用该datatype时, 只需要调用<code class="docutils literal notranslate"><span class="pre">HardType</span></code>的<code class="docutils literal notranslate"><span class="pre">apply</span></code>函数即可。此外, 从用户的角度来看, 这种机制是完全透明的, 因为硬件数据类型可以隐式转换为<code class="docutils literal notranslate"><span class="pre">HardType</span></code>。</p>
</li>
</ol>
</section>
<section id="frequency-and-time">
<h3>四、频率与时间(Frequency and time)<a class="headerlink" href="#frequency-and-time" title="Permalink to this heading"></a></h3>
<p>SpinalHDL有专门的语法来定义频率和时间值:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">frequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="nc">MHz</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">timeoutLimit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">ms</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="n">us</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">periodCycles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frequency</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">period</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">timeoutCycles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frequency</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">timeoutLimit</span><span class="w"></span>
</pre></div>
</div>
<p>对一个时间定义, 可以利用如下后缀得到一个<code class="docutils literal notranslate"><span class="pre">TimeNumber</span></code>: <code class="docutils literal notranslate"><span class="pre">fs,</span> <span class="pre">ps,</span> <span class="pre">ns,</span> <span class="pre">us,</span> <span class="pre">ms,</span> <span class="pre">sec,</span> <span class="pre">mn,</span> <span class="pre">hr</span></code>; 可以利用如下后缀得到一个<code class="docutils literal notranslate"><span class="pre">HertzNumber</span></code>: <code class="docutils literal notranslate"><span class="pre">Hz,</span> <span class="pre">KHz,</span> <span class="pre">MHz,</span> <span class="pre">GHz,</span> <span class="pre">THz</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">TimeNumber</span></code>和<code class="docutils literal notranslate"><span class="pre">HertzNumber</span></code>是基于<code class="docutils literal notranslate"><span class="pre">PhysicalNumber</span></code>类, 该类在Scala中利用<code class="docutils literal notranslate"><span class="pre">BigDecimal</span></code>存储数据。</p>
</section>
<section id="binary-prefix">
<h3>五、二进制前缀(Binary prefix)<a class="headerlink" href="#binary-prefix" title="Permalink to this heading"></a></h3>
<p>SpinalHDL允许根据IEC, 来使用二进制前缀表示法定义整数。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">memSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">512</span><span class="w"> </span><span class="nc">MiB</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">dpRamSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="nc">KiB</span><span class="w"></span>
</pre></div>
</div>
<p>可使用的所有二进制前缀如下：
|  二进制前缀   |           表示值            |
| :———–: | :————————-: |
| <code class="docutils literal notranslate"><span class="pre">Byte,</span> <span class="pre">Bytes</span></code> |              1              |
|     <code class="docutils literal notranslate"><span class="pre">KiB</span></code>     |       1024 == 1 &lt;&lt; 10       |
|     <code class="docutils literal notranslate"><span class="pre">MiB</span></code>     | 1024<sup>2</sup> == 1 &lt;&lt; 20 |
|     <code class="docutils literal notranslate"><span class="pre">GiB</span></code>     | 1024<sup>3</sup> == 1 &lt;&lt; 30 |
|     <code class="docutils literal notranslate"><span class="pre">TiB</span></code>     | 1024<sup>4</sup> == 1 &lt;&lt; 40 |
|     <code class="docutils literal notranslate"><span class="pre">PiB</span></code>     | 1024<sup>5</sup> == 1 &lt;&lt; 50 |
|     <code class="docutils literal notranslate"><span class="pre">EiB</span></code>     | 1024<sup>6</sup> == 1 &lt;&lt; 60 |
|     <code class="docutils literal notranslate"><span class="pre">ZiB</span></code>     | 1024<sup>7</sup> == 1 &lt;&lt; 70 |
|     <code class="docutils literal notranslate"><span class="pre">YiB</span></code>     | 1024<sup>8</sup> == 1 &lt;&lt; 80 |</p>
</section>
</section>
<section id="stub">
<h2>Stub (存根)<a class="headerlink" href="#stub" title="Permalink to this heading"></a></h2>
<p>用户可以清空一个层次组件结构作为存根(stub):</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">SubSysModule</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">dx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">dy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">dy</span><span class="w"> </span><span class="o">&lt;-&lt;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">dx</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">TopLevle</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">SubSysModule</span><span class="p">().</span><span class="n">stub</span><span class="w">   </span><span class="c1">//实例化该模块为一个空的存根</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码为生成如下所示的Verilog：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">SubSysModule</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">io_dx_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w">              </span><span class="n">io_dx_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_dx_payload</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w">              </span><span class="n">io_dy_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">io_dy_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_dy_payload</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>


<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">io_dx_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">io_dy_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">io_dy_payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0</span><span class="p">;</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
<p>否则，会生成如下Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">SubSysModule</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_dx_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w">          </span><span class="n">io_dx_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_dx_payload</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">io_dy_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_dy_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_dy_payload</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">io_dx_m2sPipe_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">io_dx_m2sPipe_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_dx_m2sPipe_payload</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">io_dx_rValid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_dx_rData</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_Stream_l368</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_dx_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_dx_m2sPipe_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_Stream_l368</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">io_dx_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_Stream_l368</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">io_dx_m2sPipe_valid</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_dx_m2sPipe_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_dx_rValid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_dx_m2sPipe_payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_dx_rData</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_dy_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_dx_m2sPipe_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_dx_m2sPipe_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_dy_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_dy_payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_dx_m2sPipe_payload</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">io_dx_rValid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">io_dx_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">io_dx_rValid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_dx_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_dx_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">io_dx_rData</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_dx_payload</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>


<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
<p>也可以使用如下方式来清空顶层组件：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="nc">SpinalVerilog</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Pinsec</span><span class="p">(</span><span class="mi">500</span><span class="w"> </span><span class="nc">MHz</span><span class="p">).</span><span class="n">stub</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Stub存根的功能总结如下：</p>
<ul class="simple">
<li><p>首先遍历所有组件, 找出时钟, 然后保持时钟</p></li>
<li><p>删除所有子组件</p></li>
<li><p>删除所有用户不想要的赋值和逻辑</p></li>
<li><p>对所有输出端口赋值0</p></li>
</ul>
</section>
<section id="assertions">
<h2>Assertions(断言)<a class="headerlink" href="#assertions" title="Permalink to this heading"></a></h2>
<p>除了Scala本身的运行断言, 用户还可以使用以下语法添加硬件断言:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">assert</span><span class="p">(</span><span class="n">assertion</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="p">,</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="n">severity</span><span class="p">:</span><span class="w"> </span><span class="nc">AssertNodeSeverity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Error</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>严重性级别为：
| 严重性声明 |               描述               |
| :——–: | :——————————: |
|    NOTE    |       用于提供一个消息信息       |
|  WARNING   |      用于报告一个非常规情况      |
|   ERROR    |   用于报告一个本不该出现的情况   |
|  FAILURE   | 用于报告一个失败的情况并终止仿真 |</p>
<p>以一个实际例子为例, 需要检查握手协议的有效信号valid在ready为低时不会下降:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegInit</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>

<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">ready</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 这里可以添加某些逻辑</span>

<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">assertion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">valid</span><span class="p">.</span><span class="n">fall</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">ready</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">message</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Valid dropped when ready was low&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">severity</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">ERROR</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="report">
<h2>Report(报告)<a class="headerlink" href="#report" title="Permalink to this heading"></a></h2>
<p>用户可以使用如下语法来对RTL中加入调试语句用于仿真：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">Enum</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">SpinalEnum</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">MIAOU</span><span class="p">,</span><span class="w"> </span><span class="nc">RAWRR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newElement</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Enum</span><span class="p">.</span><span class="nc">RAWRR</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">U</span><span class="p">(</span><span class="mh">0x42</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">Enum</span><span class="p">.</span><span class="nc">RAWRR</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="p">(</span><span class="nc">U</span><span class="p">(</span><span class="mh">0x42</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">report</span><span class="p">(</span><span class="nc">Seq</span><span class="p">(</span><span class="s">&quot;miaou &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码会生成如下Verilog代码：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="nb">$display</span><span class="p">(</span><span class="s">&quot;NOTE miaou %s%x%s%x&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a_string</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c_string</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>自SpinalHDL1.4.4版本后, 下述语句也可以适用：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">report</span><span class="p">(</span><span class="nc">L</span><span class="s">&quot;miaou $a $b $c $d&quot;</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="scopeproperty">
<h2>ScopeProperty(作用域属性)<a class="headerlink" href="#scopeproperty" title="Permalink to this heading"></a></h2>
<p>作用域属性是一种可以在当前线程本地存储值的物体。它的API可用于设置/获知该值, 但也可用于以堆栈方式修改部分执行的值。</p>
<p>换而言之, 这是一种对全局变量、Scala隐式声明(Implicit)以及线程本地(ThredLocal)的代替品。</p>
<ul class="simple">
<li><p>相比于全局变量, 它允许多个运行相同代码的不同线程独立运行</p></li>
<li><p>相比于Scala Implicit, 它对代码库的干扰更小</p></li>
<li><p>相比于ThreadLocal, 它拥有一些API来收集所有ScopeProperty, 并在稍后将它们恢复到相同的状态</p></li>
</ul>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">Xlen</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">ScopeProperty</span><span class="p">[</span><span class="nc">Int</span><span class="p">]</span><span class="w"></span>

<span class="k">object</span><span class="w"> </span><span class="nc">ScopePropertyMiaou</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">App</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nc">Xlen</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">println</span><span class="p">(</span><span class="nc">Xlen</span><span class="p">.</span><span class="n">get</span><span class="p">)</span><span class="w"> </span><span class="c1">//1</span>
<span class="w">  </span><span class="nc">Xlen</span><span class="p">(</span><span class="mi">2</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="nc">Xlen</span><span class="p">.</span><span class="n">get</span><span class="p">)</span><span class="w"> </span><span class="c1">//2</span>
<span class="w">    </span><span class="nc">Xlen</span><span class="p">(</span><span class="mi">3</span><span class="p">){</span><span class="w"></span>
<span class="w">      </span><span class="n">println</span><span class="p">(</span><span class="nc">Xlen</span><span class="p">.</span><span class="n">get</span><span class="p">)</span><span class="w"> </span><span class="c1">//3</span>
<span class="w">      </span><span class="nc">Xlen</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">println</span><span class="p">(</span><span class="nc">Xlen</span><span class="p">.</span><span class="n">get</span><span class="p">)</span><span class="w"> </span><span class="c1">//4</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="nc">Xlen</span><span class="p">.</span><span class="n">get</span><span class="p">)</span><span class="w"> </span><span class="c1">//2</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="analog-and-inout-io">
<h2>Analog and inout (模拟与IO口)<a class="headerlink" href="#analog-and-inout-io" title="Permalink to this heading"></a></h2>
<section id="id75">
<h3>一、简介<a class="headerlink" href="#id75" title="Permalink to this heading"></a></h3>
<p>用户可以利用<code class="docutils literal notranslate"><span class="pre">Analog</span></code>/<code class="docutils literal notranslate"><span class="pre">inout</span></code>特性定义一个三态信号。这些特性的添加基于以下原因：</p>
<ul class="simple">
<li><p>能够将本原三状态信号添加到顶层(避免需要用一些手写的VHDL/Verilog手工封装它们)。</p></li>
<li><p>允许定义中包含inout引脚的黑盒子(Blackbox)</p></li>
<li><p>能够通过层次结构将黑盒子的输入引脚连接到顶层输入引脚</p></li>
</ul>
<p>由于这些特性都只是为了方便而添加, 所以目前为止请不要尝试关于三态逻辑的其他花里胡哨的东西。</p>
<p>如果用户想建模一个类似于内存映射GPIO外设的组件, 请使用来自Spinal标准库中名为“TriState/TriStateArray”的<code class="docutils literal notranslate"><span class="pre">Bundle</span></code>组件, 该组件抽象了三态驱动的真实特性。</p>
</section>
<section id="analog">
<h3>二、Analog(模拟)<a class="headerlink" href="#analog" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Analog</span></code>是可以将某个信号定义为模拟性质的关键词, 在数字领域可以表示<code class="docutils literal notranslate"><span class="pre">0</span></code>、<code class="docutils literal notranslate"><span class="pre">1</span></code>或<code class="docutils literal notranslate"><span class="pre">Z</span></code>(未连接、高阻态)等。例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">SdramInterface</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">SdramLayout</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">DQ</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="nc">Analog</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="c1">// 双向数据总线</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">DQM</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">bytePerWord</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">ADDR</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">chipAddressWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">BA</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">bankWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">CKE</span><span class="p">,</span><span class="w"> </span><span class="nc">CSn</span><span class="p">,</span><span class="w"> </span><span class="nc">CASn</span><span class="p">,</span><span class="w"> </span><span class="nc">RASn</span><span class="p">,</span><span class="w"> </span><span class="nc">WEn</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="inout-io">
<h3>三、Inout(IO口)<a class="headerlink" href="#inout-io" title="Permalink to this heading"></a></h3>
<p>inout是允许用户将<code class="docutils literal notranslate"><span class="pre">Analog</span></code>信号设置为双向(输入和输出)信号的关键字。例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">SdramInterface</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">SdramLayout</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">DQ</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="nc">Analog</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="c1">// 双向数据总线</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">DQM</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">bytePerWord</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">ADDR</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">chipAddressWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">BA</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">bankWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">CKE</span><span class="p">,</span><span class="w"> </span><span class="nc">CSn</span><span class="p">,</span><span class="w"> </span><span class="nc">CASn</span><span class="p">,</span><span class="w"> </span><span class="nc">RASn</span><span class="p">,</span><span class="w"> </span><span class="nc">WEn</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">()</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">out</span><span class="p">(</span><span class="nc">ADDR</span><span class="p">,</span><span class="w"> </span><span class="nc">BA</span><span class="p">,</span><span class="w"> </span><span class="nc">CASn</span><span class="p">,</span><span class="w"> </span><span class="nc">CKE</span><span class="p">,</span><span class="w"> </span><span class="nc">CSn</span><span class="p">,</span><span class="w"> </span><span class="nc">DQM</span><span class="p">,</span><span class="w"> </span><span class="nc">RASn</span><span class="p">,</span><span class="w"> </span><span class="nc">WEn</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">inout</span><span class="p">(</span><span class="nc">DQ</span><span class="p">)</span><span class="w"> </span><span class="c1">// 设置DQ为组件的一个IO信号</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="inoutwrapper-io">
<h3>四、InOutWrapper(IO口封装)<a class="headerlink" href="#inoutwrapper-io" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">InOutWrapper</span></code>是一个允许用户将组件中的所有<code class="docutils literal notranslate"><span class="pre">master</span> <span class="pre">TriState/TriStateArray/ReadableOpenDrain</span></code>包(<code class="docutils literal notranslate"><span class="pre">Bundle</span></code>)转换为<code class="docutils literal notranslate"><span class="pre">inout(Analog(...))</span></code>信号的工具。该工具允许用户的硬件代码无<code class="docutils literal notranslate"><span class="pre">Analog/inout</span></code>描述并且通过转换顶层使得其可以综合。例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Apb3Gpio</span><span class="p">(</span><span class="n">gpioWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">gpio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">TriStateArray</span><span class="p">(</span><span class="n">gpioWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">apb</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">Apb3</span><span class="p">(</span><span class="nc">Apb3Gpio</span><span class="p">.</span><span class="n">getApb3Config</span><span class="p">()))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="nc">SpinalVhdl</span><span class="p">(</span><span class="nc">InOutWrapper</span><span class="p">(</span><span class="nc">Apb3Gpio</span><span class="p">(</span><span class="mi">32</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div>
<p>会生成如下代码：</p>
<div class="highlight-Vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">entity</span><span class="w"> </span><span class="nc">Apb3Gpio</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="w">  </span><span class="k">port</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">io_gpio</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">inout</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">31</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">-- 该 io_gpio最初是一个`TriStateArray Bundle`</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PADDR</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PSEL</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PENABLE</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PREADY</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PWRITE</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PWDATA</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">31</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PRDATA</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">31</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PSLVERROR</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">clk</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">reset</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="w"></span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="nc">Apb3Gpio</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>而不是生成如下代码：</p>
<div class="highlight-Vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">entity</span><span class="w"> </span><span class="nc">Apb3Gpio</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="w">  </span><span class="k">port</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">io_gpio_read</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">31</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_gpio_write</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">31</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_gpio_writeEnable</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">31</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PADDR</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PSEL</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PENABLE</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PREADY</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PWRITE</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PWDATA</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">31</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PRDATA</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">31</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_apb_PSLVERROR</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">clk</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">reset</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="w"></span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="nc">Apb3Gpio</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="manually-driving-analog-bundles">
<h3>五、Manually driving Analog bundles(手动驱动模拟束)<a class="headerlink" href="#manually-driving-analog-bundles" title="Permalink to this heading"></a></h3>
<p>如果一个<code class="docutils literal notranslate"><span class="pre">Analog</span></code>包没有被驱动, 则其会被默认设置为高阻态Z。因此为了手动实现一个三态驱动器(在<code class="docutils literal notranslate"><span class="pre">InOutWrapper</span></code>类型可能有时无法使用的情况下), 用户不得不选择性地驱动信号。</p>
<p>手动连接一个<code class="docutils literal notranslate"><span class="pre">TriState</span></code>信号到一个<code class="docutils literal notranslate"><span class="pre">Analog</span></code>包的代码例子如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Example</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">tri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">TriState</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">analog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inout</span><span class="p">(</span><span class="nc">Analog</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">tri</span><span class="p">.</span><span class="n">read</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">analog</span><span class="w"></span>
<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">tri</span><span class="p">.</span><span class="n">writeEnable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">analog</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">tri</span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="vhdlverilog-vhdl-and-verilog-generation">
<h2>VHDL和Verilog生成(VHDL and Verilog generation)<a class="headerlink" href="#vhdlverilog-vhdl-and-verilog-generation" title="Permalink to this heading"></a></h2>
<section id="spinalhdlvhdlverilog-generate-vhdl-and-verilog-from-a-spinalhdl-component">
<h3>一、从一个SpinalHDL组件生成VHDL或Verilog代码(Generate VHDL and Verilog from a SpinalHDL Component)<a class="headerlink" href="#spinalhdlvhdlverilog-generate-vhdl-and-verilog-from-a-spinalhdl-component" title="Permalink to this heading"></a></h3>
<p>为了从一个SpinalHDL组件生成VHDL, 用户需要在Scala的<code class="docutils literal notranslate"><span class="pre">main</span></code>函数中调用<code class="docutils literal notranslate"><span class="pre">SpinalVhdl(new</span> <span class="pre">YourComponent)</span></code>。 生成Verilog代码的声明是一致的, 只是需要将上述声明中的<code class="docutils literal notranslate"><span class="pre">SpinalVHD</span></code>转换为<code class="docutils literal notranslate"><span class="pre">SpinalVerilog</span></code>。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>import spinal.core._

// 一个简单的组件定义.
class MyTopLevel extends Component {
  // 定义一些IO信号。
  val io = new Bundle {
    val a = in  Bool()
    val b = in  Bool()
    val c = out Bool()
  }

  // 定义一些异步逻辑
  io.c := io.a &amp; io.b
}

// 这是生成VHDL或是Verilog的主函数
object MyMain {
  def main(args: Array[String]) {
    SpinalVhdl(new MyTopLevel)
    SpinalVerilog(new MyTopLevel)
  }
}
</pre></div>
</div>
<blockquote>
<div><p><strong>重要：<code class="docutils literal notranslate"><span class="pre">SpinalVhdl</span></code>和<code class="docutils literal notranslate"><span class="pre">SpinalVerilog</span></code>可能需要创建组件类的多个实例, 因此第一个参数不是<code class="docutils literal notranslate"><span class="pre">component</span></code>引用, 而是返回新组件的函数。</strong></p>
</div></blockquote>
<blockquote>
<div><p><strong>重要：<code class="docutils literal notranslate"><span class="pre">SpinalVerilog</span></code>于2016年6月5日开始实施。在后端成功地通过了与VHDL相同的回归测试(RISCV CPU, 多核和流水线mandelbrot, UART RX/TX, 单时钟fifo, 双时钟fifo, 灰色计数器, …)。如果您对这个新的后端有任何问题, 请在Github上发表问题描述。</strong></p>
</div></blockquote>
<ol class="simple">
<li><p>Scala中的参数化配置(Parametrization from Scala)</p></li>
</ol>
<pre><code>|             声明命名             |         类型          |                                         默认值                                         |                           描述                           |
| :------------------------------: | :-------------------: | :------------------------------------------------------------------------------------: | :------------------------------------------------------: |
|              `mode`              |      SpinalMode       |                                          null                                          | 设置SpinalHDL的生成模式。可以设置为`VHDL`或者`Verilog`。 |
|  `defaultConfigForClockDomains`  |   ClockDomainConfig   | RisingEdgeClock &lt;br&gt; AsynchronousReset &lt;br&gt; ResetActiveHigh &lt;br&gt; ClockEnableActiveHigh |            设置所有新时钟域使用的默认时钟配置            |
| `onlyStdLogicVectorAtTopLevelIo` |        Boolean        |                                         false                                          |             改变所有顶层为`std_logic_vector`             |
|  `defaultClockDomainFrequency`   | IClockDomainFrequency |                                    UnknownFrequency                                    |                       默认时钟频率                       |
|        `targetDirectory`         |        String         |                                   Current directory                                    |                    生成文件的存放目录                    |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>指定上述配置的语法如下：
```Scala
SpinalConfig(mode=VHDL, targetDirectory=&quot;temp/myDesign&quot;).generate(new UartCtrl)

// 或对于Verilog可以用拓展性更好的格式
SpinalConfig(
mode=Verilog,
targetDirectory=&quot;temp/myDesign&quot;
).generate(new UartCtrl)
```
</pre></div>
</div>
<ol>
<li><p>利用Shell进行参数配置(Parametrization from shell)</p>
<p>用户同样可以使用命令行进行参数配置：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="nc">SpinalConfig</span><span class="p">.</span><span class="n">shell</span><span class="p">(</span><span class="n">args</span><span class="p">)(</span><span class="k">new</span><span class="w"> </span><span class="nc">UartCtrl</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>命令行示例如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Usage</span><span class="p">:</span> <span class="n">SpinalCore</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span>

<span class="o">--</span><span class="n">vhdl</span>
        <span class="n">Select</span> <span class="n">the</span> <span class="n">VHDL</span> <span class="n">mode</span>
<span class="o">--</span><span class="n">verilog</span>
        <span class="n">Select</span> <span class="n">the</span> <span class="n">Verilog</span> <span class="n">mode</span>
<span class="o">-</span><span class="n">d</span> <span class="o">|</span> <span class="o">--</span><span class="n">debug</span>
        <span class="n">Enter</span> <span class="ow">in</span> <span class="n">debug</span> <span class="n">mode</span> <span class="n">directly</span>
<span class="o">-</span><span class="n">o</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">--</span><span class="n">targetDirectory</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span>
        <span class="n">Set</span> <span class="n">the</span> <span class="n">target</span> <span class="n">directory</span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="vhdlverilog-generated-vhdl-and-verilog">
<h3>二、已生成的VHDL或Verilog(Generated VHDL and Verilog)<a class="headerlink" href="#vhdlverilog-generated-vhdl-and-verilog" title="Permalink to this heading"></a></h3>
<p>最重要的是理解SpinalHDL的RTL描述是如何转换成Verilog/VHDL的：</p>
<ul class="simple">
<li><p>在Scala中的命名会保存在VHDL/Verilog中</p></li>
<li><p>Scala中<code class="docutils literal notranslate"><span class="pre">Component</span></code>的结构会保存在VHDL/Verilog中</p></li>
<li><p>Scala中<code class="docutils literal notranslate"><span class="pre">When</span></code>语句会映射为VHDL/Verilog中的if语句</p></li>
<li><p>Scala中<code class="docutils literal notranslate"><span class="pre">switch</span></code>语句会映射为VHDL/Verilog中的在所有标准情况下的Case语句</p></li>
</ul>
<ol>
<li><p>组织结构(Organization)</p>
<p>当用户使用VHDL生成器, 所有模块会被生成为包含三个部分的单个文件：</p>
<ul class="simple">
<li><p>包含对所有Enums定义的集合</p></li>
<li><p>包含被结构中的单元所使用的函数的集合</p></li>
<li><p>包含用户设计中所需的所有组件
当用户使用VHDL生成器, 所有模块会被生成为包含两个部分的单个文件：</p></li>
<li><p>所有使用的数字定义</p></li>
<li><p>用户设计中所需的所有模块</p></li>
</ul>
</li>
<li><p>组合逻辑(Combinational logic)</p>
<p>Scala：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">cond</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w">  </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w">  </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">withoutProcess</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">withProcess</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">withoutProcess</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">value</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">withProcess</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">switch</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">is</span><span class="p">(</span><span class="nc">U</span><span class="s">&quot;0000&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">io</span><span class="p">.</span><span class="n">withProcess</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">8</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">is</span><span class="p">(</span><span class="nc">U</span><span class="s">&quot;0001&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">io</span><span class="p">.</span><span class="n">withProcess</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">9</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">default</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">io</span><span class="p">.</span><span class="n">withProcess</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">value</span><span class="o">+</span><span class="mi">1</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>VHDL：</p>
<div class="highlight-Vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">entity</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="w">    </span><span class="k">port</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">io_cond</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">io_value</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">io_withoutProcess</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">io_withProcess</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="nc">TopLevel</span><span class="p">;</span><span class="w"></span>

<span class="k">architecture</span><span class="w"> </span><span class="nc">arch</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_withoutProcess</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">process</span><span class="p">(</span><span class="n">io_cond</span><span class="p">,</span><span class="n">io_value</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_withProcess</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pkg_unsigned</span><span class="p">(</span><span class="s">&quot;0000&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">io_cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="n">io_value</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="w">            </span><span class="k">when</span><span class="w"> </span><span class="n">pkg_unsigned</span><span class="p">(</span><span class="s">&quot;0000&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">                </span><span class="n">io_withProcess</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pkg_unsigned</span><span class="p">(</span><span class="s">&quot;1000&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">when</span><span class="w"> </span><span class="n">pkg_unsigned</span><span class="p">(</span><span class="s">&quot;0001&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">                </span><span class="n">io_withProcess</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pkg_unsigned</span><span class="p">(</span><span class="s">&quot;1001&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">when</span><span class="w"> </span><span class="k">others</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">                </span><span class="n">io_withProcess</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">io_value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pkg_unsigned</span><span class="p">(</span><span class="s">&quot;0001&quot;</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span><span class="k">case</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="nc">arch</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<ol class="simple">
<li><p>时序逻辑</p></li>
</ol>
<p>Scala：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">cond</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">resultA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">resultB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">regWithReset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">regWithoutReset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>

<span class="w">    </span><span class="n">regWithReset</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">value</span><span class="w"></span>
<span class="w">    </span><span class="n">regWithoutReset</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">regWithoutReset</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">value</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">resultA</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">regWithReset</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">resultB</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">regWithoutReset</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>VHDL：</p>
<div class="highlight-Vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">entity</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="w">    </span><span class="k">port</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">io_cond</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">io_value</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">io_resultA</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">io_resultB</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">clk</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">reset</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">std_logic</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="nc">TopLevel</span><span class="p">;</span><span class="w"></span>

<span class="k">architecture</span><span class="w"> </span><span class="nc">arch</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">is</span><span class="w"></span>

<span class="w">    </span><span class="k">signal</span><span class="w"> </span><span class="n">regWithReset</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">signal</span><span class="w"> </span><span class="n">regWithoutReset</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_resultA</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">regWithReset</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">io_resultB</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">regWithoutReset</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">process</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span><span class="n">reset</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">        </span><span class="n">regWithReset</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pkg_unsigned</span><span class="p">(</span><span class="s">&quot;0000&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">elsif</span><span class="w"> </span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">        </span><span class="n">regWithReset</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">process</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">        </span><span class="n">regWithoutReset</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pkg_unsigned</span><span class="p">(</span><span class="s">&quot;0000&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">io_cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">            </span><span class="n">regWithoutReset</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_value</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="nc">arch</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="vhdlverilog-vhdl-and-verilog-attributes">
<h3>三、VHDL与Verilog属性(VHDL and Verilog attributes)<a class="headerlink" href="#vhdlverilog-vhdl-and-verilog-attributes" title="Permalink to this heading"></a></h3>
<p>在某些情况下, 对设计中的某些信号设置一些属性来修正他们最终的综合结果是很有用的。</p>
<p>为了实现上述效果, 用户可以对设计中的信号或者存储调用如下函数：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">句式</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>addAttribute(name)</code></td>
<td style="text-align: center;">添加一个Boolean属性并对给定的<code>name</code>设定为true</td>
</tr>
<tr>
<td style="text-align: center;"><code>addAttribute(name, value)</code></td>
<td style="text-align: center;">添加一个String属性并对给定的<code>name</code>集合设置为<code>value</code></td>
</tr>
</tbody>
</table><p>例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">pcPlus4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="n">pcPlus4</span><span class="p">.</span><span class="n">addAttribute</span><span class="p">(</span><span class="s">&quot;keep&quot;</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>生成的VHDL解释：</p>
<div class="highlight-Vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">attribute</span><span class="w"> </span><span class="n">keep</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">boolean</span><span class="p">;</span><span class="w"></span>
<span class="k">signal</span><span class="w"> </span><span class="n">pcPlus4</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">31</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="k">attribute</span><span class="w"> </span><span class="n">keep</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">pcPlus4</span><span class="o">:</span><span class="w"> </span><span class="k">signal</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">true</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>生成的Verilog解释：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="n">keep</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">pcPlus4</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div STYLE="page-break-after: always;"></div></section>
</section>
</section>
<section id="libraries">
<h1>Libraries(库)<a class="headerlink" href="#libraries" title="Permalink to this heading"></a></h1>
<section id="id76">
<h2>简介<a class="headerlink" href="#id76" title="Permalink to this heading"></a></h2>
<p>spinal.lib包的目标是：</p>
<ul class="simple">
<li><p>提供在硬件设计中常用的模块(FIFO, 跨时钟桥, 其他有用函数)</p></li>
<li><p>提供简单的外设(UART, JTAG, VGA, ..)</p></li>
<li><p>提供总线定义(Avalon, AMBA, ..)</p></li>
<li><p>提供一些方法学(Stream, Flow, Fragment)</p></li>
<li><p>提供一些例子来体现Spinal的核心</p></li>
<li><p>提供一些实用工具(延迟分析器, QSys converter, …)</p></li>
</ul>
<p>为了使用本章所介绍的特性, 在大多数情况下, 需要使用<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">spinal.lib._</span></code>在自己的代码中。</p>
<blockquote>
<div><p><strong>重要：该包目前正在建设中。文档化的特性可以认为是稳定的。请使用github提供建议/错误/修复/增强等意见</strong></p>
</div></blockquote>
</section>
<section id="id77">
<h2>Utils(实用工具)<a class="headerlink" href="#id77" title="Permalink to this heading"></a></h2>
<p>有一些实用工具已在Spinal.core(请见<strong>其他语言特征</strong>章节中的Utils部分)。</p>
<section id="state-less-utilities">
<h3>一、State less utilities(免状态工具)<a class="headerlink" href="#state-less-utilities" title="Permalink to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">句式</th>
<th style="text-align: center;">返回类型</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>toGray(x : UInt)</code></td>
<td style="text-align: center;">Bits</td>
<td style="text-align: center;">返回X的格雷码</td>
</tr>
<tr>
<td style="text-align: center;"><code>fromGray(x : Bits)</code></td>
<td style="text-align: center;">UInt</td>
<td style="text-align: center;">返回格雷码X转换后的UInt值</td>
</tr>
<tr>
<td style="text-align: center;"><code>Reverse(x : T)</code></td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">翻转所有比特 (lsb + n -&gt; msb - n)</td>
</tr>
<tr>
<td style="text-align: center;"><code>OHToUInt(x : Seq[Bool])</code><br><code>OHToUInt(x : BitVector)</code></td>
<td style="text-align: center;">UInt</td>
<td style="text-align: center;">返回独热编码<code>x</code>中1的坐标</td>
</tr>
<tr>
<td style="text-align: center;"><code>CountOne(x : Seq[Bool])</code><br><code>CountOne(x : BitVector)</code></td>
<td style="text-align: center;">UInt</td>
<td style="text-align: center;">返回<code>x</code>中1的个数</td>
</tr>
<tr>
<td style="text-align: center;"><code>MajorityVote(x : Seq[Bool])</code><br><code>MajorityVote(x : BitVector)</code></td>
<td style="text-align: center;">Bool</td>
<td style="text-align: center;">当1的数量&gt;(x.size/2)时, 返回true</td>
</tr>
<tr>
<td style="text-align: center;"><code>EndiannessSwap(that: T[, base:BitCount])</code></td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">Big-Endian &lt;-&gt; Little-Endian 大头端与小头端互换</td>
</tr>
<tr>
<td style="text-align: center;"><code>OHMasking.first(x : Bits)</code></td>
<td style="text-align: center;">Bits</td>
<td style="text-align: center;">保持x中的第一个比特1不变</td>
</tr>
<tr>
<td style="text-align: center;"><code>OHMasking.last(x : Bits)</code></td>
<td style="text-align: center;">Bits</td>
<td style="text-align: center;">保持x中的最后一个比特1不变</td>
</tr>
<tr>
<td style="text-align: center;"><code>OHMasking.roundRobin(</code><br><code>requests : Bits,</code><br><code>ohPriority : Bits</code><br><code>)</code></td>
<td style="text-align: center;">Bits</td>
<td style="text-align: center;">根据<code>ohPriority</code>给出的优先级使得<code>requests</code>中的某个比特1保持不变。例如, 假设<code>requests</code>等于"1001", <code>ohPriority</code>等于"0010", 则<code>roundRobin</code>函数会根据<code>ohPriority</code>提供的优先级对<code>requests</code>进行轮询仲裁, 并且返回"1000"</td>
</tr>
<tr>
<td style="text-align: center;"><code>MuxOH (</code><br><code>oneHot : IndexedSeq[Bool],</code><br><code>inputs : Iterable[T]</code><br><code>)</code></td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">根据<code>oneHot</code>向量提供的信息, 对输入<code>inputs</code>进行选通并返回选通后的<code>T</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>PriorityMux (</code><br><code>sel: Seq[Bool],</code><br><code>in: Seq[T]</code><br><code>)</code></td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">返回<code>in</code>中第一个对应<code>sel</code>位为<code>True</code>的元素</td>
</tr>
<tr>
<td style="text-align: center;"><code>PriorityMux (</code><br><code>in: Seq[(Bool, T)]</code><br><code>)</code></td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">返回<code>in</code>中第一个对应<code>sel</code>位为<code>True</code>的元素</td>
</tr>
</tbody>
</table></section>
<section id="state-full-utilities">
<h3>二、State full utilities(全状态工具)<a class="headerlink" href="#state-full-utilities" title="Permalink to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">句式</th>
<th style="text-align: center;">返回类型</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>Delay(that: T, cycleCount: Int)</code></td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">延迟<code>cycleCount</code>个周期后返回<code>that</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>History(that: T, length: Int[,when : Bool])</code></td>
<td style="text-align: center;">List[T]</td>
<td style="text-align: center;">返回一个长度为<code>length</code>的向量。其中第一个元素是<code>that</code>, 最后一个是延迟(<code>length</code>-1)后的<code>that</code>。内部的移位寄存器会在<code>when</code>有效时进行采样</td>
</tr>
<tr>
<td style="text-align: center;"><code>BufferCC(input : T)</code></td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">返回利用两个触发器同步到当前时钟域的同步输入信号</td>
</tr>
</tbody>
</table><ol>
<li><p>计数器</p>
<p>Counter工具可以用来实例化一个硬件计数器。
|                        句式                         |                  描述                   |
| :————————————————-: | :————————————-: |
| <code class="docutils literal notranslate"><span class="pre">Counter(start:</span> <span class="pre">BigInt,</span> <span class="pre">end:</span> <span class="pre">BigInt[,</span> <span class="pre">inc</span> <span class="pre">:</span> <span class="pre">Bool])</span></code> |                   无                    |
|       <code class="docutils literal notranslate"><span class="pre">Counter(range</span> <span class="pre">:</span> <span class="pre">Range[,</span> <span class="pre">inc</span> <span class="pre">:</span> <span class="pre">Bool])</span></code>        |      与<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">to</span> <span class="pre">y``x</span> <span class="pre">until</span> <span class="pre">y</span></code>语句匹配      |
|     <code class="docutils literal notranslate"><span class="pre">Counter(stateCount:</span> <span class="pre">BigInt[,</span> <span class="pre">inc</span> <span class="pre">:</span> <span class="pre">Bool])</span></code>     |  从0开始计数, 到<code class="docutils literal notranslate"><span class="pre">statecCount</span> <span class="pre">-</span> <span class="pre">1</span></code>结束   |
|     <code class="docutils literal notranslate"><span class="pre">Counter(bitCount:</span> <span class="pre">BitCount[,</span> <span class="pre">inc</span> <span class="pre">:</span> <span class="pre">Bool])</span></code>     | 从0开始计数, 到<code class="docutils literal notranslate"><span class="pre">(1</span> <span class="pre">&lt;&lt;</span> <span class="pre">bitCoun)</span> <span class="pre">-</span> <span class="pre">1</span></code>结束 |</p>
<p>一个计数器可以被方法所控制, 并且导线可以被读取：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Counter</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="c1">// 建立一个八状态计数器 (2 to 9)</span>
<span class="c1">// 方法</span>
<span class="n">counter</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span><span class="w">               </span><span class="c1">// 复位计数器</span>
<span class="n">counter</span><span class="p">.</span><span class="n">increment</span><span class="p">()</span><span class="w">           </span><span class="c1">// 计数增加</span>
<span class="c1">// Wires</span>
<span class="n">counter</span><span class="p">.</span><span class="n">value</span><span class="w">                 </span><span class="c1">// 当前值</span>
<span class="n">counter</span><span class="p">.</span><span class="n">valueNext</span><span class="w">             </span><span class="c1">// 下一个值</span>
<span class="n">counter</span><span class="p">.</span><span class="n">willOverflow</span><span class="w">          </span><span class="c1">// 若当前循环计数器溢出, 则返回true</span>
<span class="n">counter</span><span class="p">.</span><span class="n">willOverflowIfInc</span><span class="w">     </span><span class="c1">// 若当前循环增加一会导致计数器溢出, 则返回true</span>
<span class="c1">// Cast搜寻</span>
<span class="n">when</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">5</span><span class="p">){</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">    </span><span class="c1">// 计数器会隐式地投射搜寻到当前值</span>
</pre></div>
</div>
<p>当一个是计数器溢出(达到最终值), 它会在下一个周期重启并设置为初始值。<code class="docutils literal notranslate"><span class="pre">CounterFreeRun</span></code>构建一个始终运行的计数器:<code class="docutils literal notranslate"><span class="pre">CounterFreeRun(stateCount:</span> <span class="pre">BigInt)</span></code>。</p>
</li>
<li><p>超时(Timeout)</p>
<p>Timeout工具可以用来方便地例化一个硬件Timeout。
|              例化句式              |              描述               |
| :——————————–: | :—————————–: |
|     <code class="docutils literal notranslate"><span class="pre">Timeout(cycles</span> <span class="pre">:</span> <span class="pre">BigInt)</span></code>     |    <code class="docutils literal notranslate"><span class="pre">cycles</span></code>个时钟后进行标记     |
| <code class="docutils literal notranslate"><span class="pre">Delay(that:</span> <span class="pre">T,</span> <span class="pre">cycleCount:</span> <span class="pre">Int)</span></code>  |    持续<code class="docutils literal notranslate"><span class="pre">time</span></code>时间后进行标记     |
| <code class="docutils literal notranslate"><span class="pre">Timeout(frequency</span> <span class="pre">:</span> <span class="pre">HertzNumber)</span></code> | 以<code class="docutils literal notranslate"><span class="pre">frequency</span></code>的速率进行计时标记 |
下方代码举例了可以和Counter工具一起使用的不同语法句式的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Timeout</span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="n">ms</span><span class="p">)</span><span class="w">  </span><span class="c1">//计时10ms后的对象会被记为超时</span>
<span class="n">when</span><span class="p">(</span><span class="n">timeout</span><span class="p">){</span><span class="w">                </span><span class="c1">//检查是否被判断为超时</span>
<span class="w">    </span><span class="n">timeout</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span><span class="w">           </span><span class="c1">//请求timeout工具清空他的标志位</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p><strong>备注：如果使用时间或频率设置实例化<code class="docutils literal notranslate"><span class="pre">Timeout</span></code>, 则隐含的<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>应该具有频率设置。</strong></p>
</div></blockquote>
</li>
<li><p>复位控制(ResetControl)</p>
<p>复位控制提供了一些工具以管理复位。</p>
<ul>
<li><p>asyncAssertSyncDeassert</p>
<p>用户可以利用一个异步有效同步无效(asynchronously asserted synchronously de-asserted)逻辑来筛选异步复位。可以使用<code class="docutils literal notranslate"><span class="pre">ResetCtrl.asyncAssertSyncDeassert</span></code>函数来筛选并返回相应的值。
|    声明命名    |  返回类型   |                          描述                          |
| :————: | :———: | :—————————————————-: |
|     input      |    Bool     |                       筛选的信号                       |
|  clockDomain   | ClockDomain |              返回将要使用所筛选值的时钟域              |
| inputPolarity  |  Polarity   |                HIGH/LOW (default=HIGH)                 |
| outputPolarity |  Polarity   | HIGH/LOW (default=clockDomain.config.resetActiveLevel) |
|  bufferDepth   |     Int     |         防止亚稳态所需的寄存器级数（默认为2）          |</p>
<p>另外有一个ResetCtrl.asyncAssertSyncDeassertDrive版本的工具, 它直接分配clockDomain以重置的值。</p>
</li>
</ul>
</li>
</ol>
</section>
<section id="special-utilities">
<h3>三、特殊工具(Special utilities)<a class="headerlink" href="#special-utilities" title="Permalink to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">句式</th>
<th style="text-align: center;">返回类型</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>LatencyAnalysis(paths : Node*)</code></td>
<td style="text-align: center;">Int</td>
<td style="text-align: center;">以周期为单位返回从第一个节点到最后一个节点的最短路径</td>
</tr>
</tbody>
</table></section>
</section>
<section id="stream">
<h2>流(Stream)<a class="headerlink" href="#stream" title="Permalink to this heading"></a></h2>
<section id="specification">
<h3>一、规范(Specification)<a class="headerlink" href="#specification" title="Permalink to this heading"></a></h3>
<p>Stream接口是一个用来承载负载(payload)的简单握手协议。例如, 它可以用来对FIFO压入或弹出数据、发送请求给UART控制器等等。
|  信号   | 类型  |  驱动  |                      描述                      |    Don’t care 条件     |
| :—–: | :—: | :—-: | :——————————————–: | :——————–: |
|  valid  | Bool  | Master |          当置高时, 说明负载通过该接口          |                        |
|  ready  | Bool  | Slave  | 当置低时, 表明该slave口不接收传输(transaction) | valid为低时, dont care |
| payload |   T   | Master |                 负载任务的内容                 | valid为低时, dont care |</p>
<p><img alt="_images/Lib-Stream-Spec.png" src="_images/Lib-Stream-Spec.png" /></p>
<p>在SpinalHDL中有如下应用例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">StreamFifo</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">dataType</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">push</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="w"> </span><span class="p">(</span><span class="n">dataType</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">pop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Stream</span><span class="w"> </span><span class="p">(</span><span class="n">dataType</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">StreamArbiter</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">dataType</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="n">portCount</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">inputs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="w"> </span><span class="p">(</span><span class="n">dataType</span><span class="p">),</span><span class="n">portCount</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Stream</span><span class="w"> </span><span class="p">(</span><span class="n">dataType</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p><strong>备注：当<code class="docutils literal notranslate"><span class="pre">valid</span></code>高而<code class="docutils literal notranslate"><span class="pre">ready</span></code>低时, 每个slave可以又或不可以允许有效负载发生变化(视情况而定)。例如:</strong></p>
</div></blockquote>
<ul class="simple">
<li><p>没有锁逻辑的优先级仲裁器可以从一个输入切换到另一个输入(这将改变负载)</p></li>
<li><p>UART控制器可以直接使用写端口来驱动UART引脚, 并且只在传输结束时完成数据交换(consume the transaction)。需要注意。</p></li>
</ul>
</section>
<section id="semantics">
<h3>二、语义(Semantics)<a class="headerlink" href="#semantics" title="Permalink to this heading"></a></h3>
<p>当手动读取或驱动一个流中的信号时需要牢记：</p>
<ul class="simple">
<li><p>当<code class="docutils literal notranslate"><span class="pre">valid</span></code>被置为有效后, 它只有当目前的负载已经被使用后才可以被置为无效。这意味着<code class="docutils literal notranslate"><span class="pre">valid</span></code>只有在slave口通过置高<code class="docutils literal notranslate"><span class="pre">ready</span></code>来完成一次读操作后的下一个周期, 才可以被置为0。</p></li>
<li><p>与<code class="docutils literal notranslate"><span class="pre">valid</span></code>相反的是, <code class="docutils literal notranslate"><span class="pre">ready</span></code>是可以随时改变的</p></li>
<li><p>数据的传输只有当<code class="docutils literal notranslate"><span class="pre">valid</span></code>和<code class="docutils literal notranslate"><span class="pre">ready</span></code>同时置高时才会发生</p></li>
<li><p>一个流的<code class="docutils literal notranslate"><span class="pre">valid</span></code>一定不能和<code class="docutils literal notranslate"><span class="pre">ready</span></code>以组合的方式连接, 它们之间的任何路径都应该是通过寄存器的。</p></li>
<li><p>推荐在<code class="docutils literal notranslate"><span class="pre">valid</span></code>和<code class="docutils literal notranslate"><span class="pre">ready</span></code>之间没有任何依赖(连接路径)</p></li>
</ul>
</section>
<section id="functions">
<h3>三、函数(Functions)<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">句式</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">返回值</th>
<th style="text-align: center;">延迟</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Stream(type : Data)</td>
<td style="text-align: center;">建立一个给定类型的流</td>
<td style="text-align: center;">Stream[T]</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">master/slave Stream(type : Data)</td>
<td style="text-align: center;">建立一个给定类型的流, 并根据给定的IO设置初始化</td>
<td style="text-align: center;">Stream[T]</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">x.fire</td>
<td style="text-align: center;">当消息在总线上完成了传递或者说握手完成(valid &amp;&amp; ready)则返回true</td>
<td style="text-align: center;">Bool</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">x.isStall</td>
<td style="text-align: center;">当消息堵塞在总线上或者说握手未完成(valid &amp;&amp; !ready)则返回true</td>
<td style="text-align: center;">Bool</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">x.queue(size:Int)</td>
<td style="text-align: center;">返回一个通过FIFO与x相连的流</td>
<td style="text-align: center;">Stream[T]</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">x.m2sPipe()<br>x.stage()</td>
<td style="text-align: center;">返回一个由x通过寄存器驱动的流 <br>Cost = (payload width + 1) flop flop</td>
<td style="text-align: center;">Stream[T]</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">x.s2mPipe()</td>
<td style="text-align: center;">返回一个由x驱动的流。<br>ready路径通过寄存器阶段分割。 <br>Cost = (payload width + 1) flop flop</td>
<td style="text-align: center;">Stream[T]</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">x.halfPipe()</td>
<td style="text-align: center;">返回一个由x驱动的流。<br>valid/ready/payload路径通过一些寄存器分割。 <br>Cost = (payload width + 2) flip flop, bandwidth divided by two</td>
<td style="text-align: center;">Stream[T]</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">x &lt;&lt; y<br>y &gt;&gt; x</td>
<td style="text-align: center;">把y连接到x</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">x &lt;-&lt; y<br>y &gt;-&gt; x</td>
<td style="text-align: center;">通过m2sPipe把y连接到x</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">x <!--< y<br-->y &gt;/&gt; x</td>
<td style="text-align: center;">通过s2mPipe把y连接到x</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">x &lt;-/&lt; y <br> &gt;/-&gt; x</td>
<td style="text-align: center;">通过s2mPipe().m2sPipe()把y连接到x, 意味着x和y之间无组合路径</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">x.haltWhen(cond : Bool)</td>
<td style="text-align: center;">返回一个连接到x的流, 并且当cond为true时停顿</td>
<td style="text-align: center;">Stream[T]</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">x.throwWhen(cond : Bool)</td>
<td style="text-align: center;">返回一个连接到x的流, 并且当cond为true时抛弃需要交换的数据</td>
<td style="text-align: center;">Stream[T]</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table><p>下方的代码将会产生如下图所示的逻辑电路：
<img alt="stream_throw_m2spipe" src="_images/stream_throw_m2spipe.svg" /></p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">RGB</span><span class="p">(</span><span class="n">channelWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">red</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">channelWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">green</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">channelWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">blue</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">channelWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">isBlack</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">red</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">green</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">blue</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">RGB</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">sink</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">RGB</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span><span class="w"></span>
<span class="n">sink</span><span class="w"> </span><span class="o">&lt;-&lt;</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">throwWhen</span><span class="p">(</span><span class="n">source</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">isBlack</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>上述Scala代码生成的Verilog电路如下：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// Generator : SpinalHDL v1.6.0    git head : 73c8d8e2b86b45646e9d0b2e729291f2b65e6be3</span>
<span class="c1">// Component : RGBStream</span>

<span class="k">module</span><span class="w"> </span><span class="n">RGBStream</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">source_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">source_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_payload_red</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_payload_green</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_payload_blue</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">sink_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">sink_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">sink_payload_red</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">sink_payload_green</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">sink_payload_blue</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_Stream_l408</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">source_thrown_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">source_thrown_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_thrown_payload_red</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_thrown_payload_green</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_thrown_payload_blue</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">source_thrown_m2sPipe_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">source_thrown_m2sPipe_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_thrown_m2sPipe_payload_red</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_thrown_m2sPipe_payload_green</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_thrown_m2sPipe_payload_blue</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">source_thrown_rValid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_thrown_rData_red</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_thrown_rData_green</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">source_thrown_rData_blue</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_Stream_l342</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_Stream_l408</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">source_payload_red</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">source_payload_green</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">source_payload_blue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">source_thrown_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_Stream_l408</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">source_thrown_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">source_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_thrown_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_Stream_l408</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">source_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">source_thrown_payload_red</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_payload_red</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">source_thrown_payload_green</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_payload_green</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">source_thrown_payload_blue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_payload_blue</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">source_thrown_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_thrown_m2sPipe_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_Stream_l342</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">source_thrown_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_Stream_l342</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">source_thrown_m2sPipe_valid</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">source_thrown_m2sPipe_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_thrown_rValid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">source_thrown_m2sPipe_payload_red</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_thrown_rData_red</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">source_thrown_m2sPipe_payload_green</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_thrown_rData_green</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">source_thrown_m2sPipe_payload_blue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_thrown_rData_blue</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">sink_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_thrown_m2sPipe_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">source_thrown_m2sPipe_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sink_ready</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">sink_payload_red</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_thrown_m2sPipe_payload_red</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">sink_payload_green</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_thrown_m2sPipe_payload_green</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">sink_payload_blue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_thrown_m2sPipe_payload_blue</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">source_thrown_rValid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">source_thrown_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">source_thrown_rValid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">source_thrown_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">source_thrown_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">source_thrown_rData_red</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">source_thrown_payload_red</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">source_thrown_rData_green</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">source_thrown_payload_green</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">source_thrown_rData_blue</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">source_thrown_payload_blue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>


<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id78">
<h3>四、工具(Utils)<a class="headerlink" href="#id78" title="Permalink to this heading"></a></h3>
<p>Stream中有许多工具可以与用户设计中的流总线(Stream bus)结合, 本章将会介绍他们。</p>
<ol>
<li><p>流式FIFO(StreamFifo)</p>
<p>用户可以在每个流上调用.queue(size)来获得一个缓冲流(buffered stream)。但是也可以实例化FIFO组件本身：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">streamA</span><span class="p">,</span><span class="n">streamB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="c1">//...</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myFifo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StreamFifo</span><span class="p">(</span><span class="w"></span>
<span class="n">dataType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"></span>
<span class="n">depth</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="n">myFifo</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">streamA</span><span class="w"></span>
<span class="n">myFifo</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="w">  </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">streamB</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">StreamFifo</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_push_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">io_push_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_push_payload</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">io_pop_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_pop_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_pop_payload</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_flush</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_occupancy</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_availability</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_logic_ram_port0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">6</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_logic_pushPtr_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_logic_pushPtr_valueNext_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">6</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_logic_popPtr_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_logic_popPtr_valueNext_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_logic_ram_port</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_io_pop_payload</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">6</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_io_availability</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">_zz_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">logic_pushPtr_willIncrement</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">logic_pushPtr_willClear</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">6</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">logic_pushPtr_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">6</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">logic_pushPtr_value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">logic_pushPtr_willOverflowIfInc</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">logic_pushPtr_willOverflow</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">logic_popPtr_willIncrement</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">logic_popPtr_willClear</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">6</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">logic_popPtr_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">6</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">logic_popPtr_value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">logic_popPtr_willOverflowIfInc</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">logic_popPtr_willOverflow</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">logic_ptrMatch</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">logic_risingOccupancy</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">logic_pushing</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">logic_popping</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">logic_empty</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">logic_full</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">_zz_io_pop_valid</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_Stream_l1078</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">6</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">logic_ptrDif</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">logic_ram</span><span class="w"> </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">127</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_logic_pushPtr_valueNext_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">logic_pushPtr_willIncrement</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_logic_pushPtr_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">6</span><span class="mi">&#39;d0</span><span class="p">,</span><span class="w"> </span><span class="n">_zz_logic_pushPtr_valueNext_1</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_logic_popPtr_valueNext_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">logic_popPtr_willIncrement</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_logic_popPtr_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">6</span><span class="mi">&#39;d0</span><span class="p">,</span><span class="w"> </span><span class="n">_zz_logic_popPtr_valueNext_1</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_io_availability</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">logic_popPtr_value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">logic_pushPtr_value</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_io_pop_payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">_zz_io_pop_payload</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">_zz_logic_ram_port0</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">logic_ram</span><span class="p">[</span><span class="n">logic_popPtr_valueNext</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">_zz_1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">logic_ram</span><span class="p">[</span><span class="n">logic_pushPtr_value</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_push_payload</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">logic_pushing</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">_zz_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">logic_pushPtr_willIncrement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">logic_pushing</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">logic_pushPtr_willIncrement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">logic_pushPtr_willClear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_flush</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">logic_pushPtr_willClear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">logic_pushPtr_willOverflowIfInc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">logic_pushPtr_value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">7&#39;h7f</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">logic_pushPtr_willOverflow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">logic_pushPtr_willOverflowIfInc</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">logic_pushPtr_willIncrement</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">logic_pushPtr_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">logic_pushPtr_value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_zz_logic_pushPtr_valueNext</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">logic_pushPtr_willClear</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">logic_pushPtr_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">7&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">logic_popPtr_willIncrement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">logic_popping</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">logic_popPtr_willIncrement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">logic_popPtr_willClear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_flush</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">logic_popPtr_willClear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">logic_popPtr_willOverflowIfInc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">logic_popPtr_value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">7&#39;h7f</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">logic_popPtr_willOverflow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">logic_popPtr_willOverflowIfInc</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">logic_popPtr_willIncrement</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">logic_popPtr_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">logic_popPtr_value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_zz_logic_popPtr_valueNext</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">logic_popPtr_willClear</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">logic_popPtr_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">7&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">logic_ptrMatch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">logic_pushPtr_value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">logic_popPtr_value</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">logic_pushing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_push_valid</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">io_push_ready</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">logic_popping</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_pop_valid</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">io_pop_ready</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">logic_empty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">logic_ptrMatch</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">logic_risingOccupancy</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">logic_full</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">logic_ptrMatch</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">logic_risingOccupancy</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_push_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">logic_full</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_pop_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="o">!</span><span class="w"> </span><span class="n">logic_empty</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_io_pop_valid</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">logic_full</span><span class="p">))));</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_pop_payload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_logic_ram_port0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_Stream_l1078</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">logic_pushing</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">logic_popping</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">logic_ptrDif</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">logic_pushPtr_value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">logic_popPtr_value</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_occupancy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{(</span><span class="n">logic_risingOccupancy</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">logic_ptrMatch</span><span class="p">),</span><span class="n">logic_ptrDif</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_availability</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{((</span><span class="o">!</span><span class="w"> </span><span class="n">logic_risingOccupancy</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">logic_ptrMatch</span><span class="p">),</span><span class="n">_zz_io_availability</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">logic_pushPtr_value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">7&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">logic_popPtr_value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">7&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">logic_risingOccupancy</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">_zz_io_pop_valid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">logic_pushPtr_value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">logic_pushPtr_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">logic_popPtr_value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">logic_popPtr_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">_zz_io_pop_valid</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">logic_popPtr_valueNext</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">logic_pushPtr_value</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">when_Stream_l1078</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">logic_risingOccupancy</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">logic_pushing</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">io_flush</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">logic_risingOccupancy</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>


<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
<pre><code>|  参数名  | 类型  |           描述           |
| :------: | :---: | :----------------------: |
| dataType |   T   | 流式FIFO上负载数据的类型 |
|  depth   |  Int  |    存储数据的存储大小    |
</code></pre><pre><code>|  IO口名   |              类型              |             描述             |
| :-------: | :----------------------------: | :--------------------------: |
|   push    |           Stream[T]            |   用来向流式FIFO中压入数据   |
|    pop    |           Stream[T]            |   用来从流式FIFO中弹出数据   |
|   flush   |              Bool              | 用来清空流式FIFO中的所有数据 |
| occupancy | UInt of log2Up(depth + 1) bits |     反映内部存储占用情况     |
</code></pre><ol>
<li><p>流式FIFOCC(StreamFifoCC)</p>
<p>用户可以通过如下方式定义一个双时钟域FIFO：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">clockA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">(</span><span class="o">???</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">clockB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">(</span><span class="o">???</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">streamA</span><span class="p">,</span><span class="n">streamB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="c1">//...</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myFifo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StreamFifoCC</span><span class="p">(</span><span class="w"></span>
<span class="n">dataType</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"></span>
<span class="n">depth</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"></span>
<span class="n">pushClock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clockA</span><span class="p">,</span><span class="w"></span>
<span class="n">popClock</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">clockB</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="n">myFifo</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">streamA</span><span class="w"></span>
<span class="n">myFifo</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="w">  </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">streamB</span><span class="w"></span>
</pre></div>
</div>
<p>|  参数名   |    类型     |           描述           |
| :——-: | :———: | :———————-: |
| dataType  |      T      | 流式FIFO上负载数据的类型 |
|   depth   |     Int     |    存储数据的存储大小    |
| pushClock | ClockDomain |  存入数据端使用的时钟域  |
| popClock  | ClockDomain |  取出数据端使用的时钟域  |</p>
</li>
</ol>
<pre><code>|    IO口名     |              类型              |                 描述                 |
| :-----------: | :----------------------------: | :----------------------------------: |
|     push      |           Stream[T]            |       用来向流式FIFO中压入数据       |
|      pop      |           Stream[T]            |       用来从流式FIFO中弹出数据       |
| pushOccupancy | UInt of log2Up(depth + 1) bits | 反映内部存储占用情况(从存入数据角度) |
| popOccupancy  | UInt of log2Up(depth + 1) bits | 反映内部存储占用情况(从取出数据角度) |
</code></pre><ol>
<li><p>StreamCCByToggle</p>
<p>该方法基于信号切换来生成连接跨时钟域的流的组件。这种方法生成的跨时钟域桥占用较小的面积, 但同时其带宽较低。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">clockA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">(</span><span class="o">???</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">clockB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">(</span><span class="o">???</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">streamA</span><span class="p">,</span><span class="n">streamB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="c1">//...</span>
<span class="kd">val</span><span class="w"> </span><span class="n">bridge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StreamCCByToggle</span><span class="p">(</span><span class="w"></span>
<span class="n">dataType</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"></span>
<span class="n">inputClock</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">clockA</span><span class="p">,</span><span class="w"></span>
<span class="n">outputClock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clockB</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="n">bridge</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">input</span><span class="w">  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">streamA</span><span class="w"></span>
<span class="n">bridge</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">output</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">streamB</span><span class="w"></span>
</pre></div>
</div>
<p>|   参数名    |    类型     |           描述           |
| :———: | :———: | :———————-: |
|  dataType   |      T      | 流式FIFO上负载数据的类型 |
| inputClock  | ClockDomain |  存入数据端使用的时钟域  |
| outputClock | ClockDomain |  取出数据端使用的时钟域  |</p>
</li>
</ol>
<pre><code>| IO口名 |   类型    |           描述           |
| :----: | :-------: | :----------------------: |
| input  | Stream[T] | 用来向流式FIFO中压入数据 |
| output | Stream[T] | 用来从流式FIFO中弹出数据 |

另外用户也可使用更简短的语句来直接生成所需的跨时钟流：
```Scala
val clockA = ClockDomain(???)
val clockB = ClockDomain(???)
val streamA = Stream(Bits(8 bits))
val streamB = StreamCCByToggle(
input       = streamA,
inputClock  = clockA,
outputClock = clockB
)
```
</code></pre><ol>
<li>流位宽适应器(StreamWidthAdapter)</li>
</ol><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>该组件会使得输入流与输出流的位宽相匹配。当输出流`outStream`的负载的位宽比`inStream`的位宽更大时, 会通过将多个输入传输任务结合成一个的操作来匹配输出的大位宽；相反, 如果输出位宽大于输入位宽, 则一个输入的传输任务会被分割成多个输出传输任务以匹配输出的小位宽。

在最好的情况下, 输入`inStream`负载的位宽应该是输出`outStream`负载的整数倍, 如下方代码所示：
```Scala
val inStream = Stream(Bits(8 bits))
val outStream = Stream(Bits(16 bits))
val adapter = StreamWidthAdapter(inStream, outStream)
```

Verilog:

```Verilog
module MyTopLevel (
  input               io_cond0,
  input               io_cond1,
  output              io_flag,
  output     [7:0]    io_state,
  input               clk,
  input               reset
);

  wire       [15:0]   _zz_outStream_payload_1;
  wire                inStream_valid;
  wire                inStream_ready;
  wire       [7:0]    inStream_payload;
  wire                outStream_valid;
  wire                outStream_ready;
  wire       [15:0]   outStream_payload;
  wire                inStream_fire;
  reg                 _zz_inStream_ready;
  reg        [0:0]    _zz_inStream_ready_1;
  reg        [0:0]    _zz_inStream_ready_2;
  wire                _zz_inStream_ready_3;
  reg        [7:0]    _zz_outStream_payload;
  wire                inStream_fire_1;

  assign _zz_outStream_payload_1 = {inStream_payload,_zz_outStream_payload};
  assign inStream_fire = (inStream_valid &amp;&amp; inStream_ready);
  always @(*) begin
    _zz_inStream_ready = 1&#39;b0;
    if(inStream_fire) begin
      _zz_inStream_ready = 1&#39;b1;
    end
  end

  assign _zz_inStream_ready_3 = (_zz_inStream_ready_2 == 1&#39;b1);
  always @(*) begin
    _zz_inStream_ready_1 = (_zz_inStream_ready_2 + _zz_inStream_ready);
    if(1&#39;b0) begin
      _zz_inStream_ready_1 = 1&#39;b0;
    end
  end

  assign inStream_fire_1 = (inStream_valid &amp;&amp; inStream_ready);
  assign outStream_valid = (inStream_valid &amp;&amp; _zz_inStream_ready_3);
  assign outStream_payload = _zz_outStream_payload_1;
  assign inStream_ready = (! ((! outStream_ready) &amp;&amp; _zz_inStream_ready_3));
  always @(posedge clk or posedge reset) begin
    if(reset) begin
      _zz_inStream_ready_2 &lt;= 1&#39;b0;
    end else begin
      _zz_inStream_ready_2 &lt;= _zz_inStream_ready_1;
    end
  end

  always @(posedge clk) begin
    if(inStream_fire_1) begin
      _zz_outStream_payload &lt;= inStream_payload;
    end
  end


endmodule
```
如上方例子所示, 两个`inStream`的传输将会被结合成一个`outStream`传输, 并且第一个`inStream`的传输会被默认放置在输出负载的低比特。

如果输入传输任务负载的期望顺序和默认设置不同, 这里有一个例子：
```Scala
val inStream = Stream(Bits(8 bits))
val outStream = Stream(Bits(16 bits))
val adapter = StreamWidthAdapter(inStream, outStream, order = SlicesOrder.HIGHER_FIRST)
```
同时还有一个与`ORDER`具有相同效果的名为`endianness`的传统参数。当`endianness`的值为`LITTLE`时, 它和`order`的`LOWER_FIRST`值等同。同理其`BIG`值和`HIGHER_FIRST`等同。`padding`参数是一个可选择的布尔逻辑值, 其可以决定该适应器能否接受输入与输出负载位宽之间的非整数倍数关系。
</pre></div>
</div>
<ol>
<li><p>流仲裁器(StreamArbiter)</p>
<p>当用户有多个流而且希望能够仲裁它们并驱动单个流, 这时可以使用StreamArbiterFactory。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">streamA</span><span class="p">,</span><span class="w"> </span><span class="n">streamB</span><span class="p">,</span><span class="w"> </span><span class="n">streamC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">arbitredABC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StreamArbiterFactory</span><span class="p">.</span><span class="n">roundRobin</span><span class="p">.</span><span class="n">onArgs</span><span class="p">(</span><span class="n">streamA</span><span class="p">,</span><span class="w"> </span><span class="n">streamB</span><span class="p">,</span><span class="w"> </span><span class="n">streamC</span><span class="p">)</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">streamD</span><span class="p">,</span><span class="w"> </span><span class="n">streamE</span><span class="p">,</span><span class="w"> </span><span class="n">streamF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">arbitredDEF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StreamArbiterFactory</span><span class="p">.</span><span class="n">lowerFirst</span><span class="p">.</span><span class="n">noLock</span><span class="p">.</span><span class="n">onArgs</span><span class="p">(</span><span class="n">streamD</span><span class="p">,</span><span class="w"> </span><span class="n">streamE</span><span class="p">,</span><span class="w"> </span><span class="n">streamF</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>|    仲裁函数     |                             描述                              |
| :————-: | :———————————————————–: |
|   lowerFirst    |                   低端口的优先级大于高端口                    |
|   roundRobin    |                         公平轮询仲裁                          |
| sequentialOrder | 按照顺序次序遍历任务。第一个传输来自于端口零, 然后依次执行… |</p>
<p>|     锁函数      |                                                 描述                                                  |
| :————-: | :—————————————————————————————————: |
|     noLock      |                     端口选择在每个周期都可以改变, 即使被选择的端口的传输没有执行                      |
| transactionLock |                                 端口选择被锁定直到端口的数据交换完成                                  |
|  fragmentLock   | 可用来仲裁Stream[Flow[T]]。在这个模式下, 端口选择被锁定直到被选择的端口完成信号突发(burst)(last=True) |</p>
</li>
</ol>
<pre><code>|          生成函数           |  返回值   |
| :-------------------------: | :-------: |
| on(inputs : Seq[Stream[T]]) | Stream[T] |
| onArgs(inputs : Stream[T]*) | Stream[T] |
</code></pre><ol>
<li>StreamJoin</li>
</ol><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>该工具接受多个输入流, 并等待它们全部触发, 随后全部通过所有输入流。
```Scala
val cmdJoin = Stream(Cmd())
cmdJoin.arbitrationFrom(StreamJoin.arg(cmdABuffer, cmdBBuffer))
```
</pre></div>
</div>
<ol>
<li><p>流式叉(StreamFork)</p>
<p>StreamFork将会对每个输入数据进行克隆并分配到所有的输出流中。如果同步为true, 则所有的输出流会同时激活, 意味着流会停滞直到所有的输出流准备就绪。如果同步信号为false, 则在额外的一个触发器的开销下, 每次只有一个输出流准备就绪。输入的流将会被堵塞直到所有的输出流已经处理过每个项目。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">inputStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="p">(</span><span class="n">outputstream1</span><span class="p">,</span><span class="w"> </span><span class="n">outputstream2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StreamFork2</span><span class="p">(</span><span class="n">inputStream</span><span class="p">,</span><span class="w"> </span><span class="n">synchronous</span><span class="o">=</span><span class="kc">false</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>或者是：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">inputStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">outputStreams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StreamFork</span><span class="p">(</span><span class="n">inputStream</span><span class="p">,</span><span class="n">portCount</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">synchronous</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>流顺序调度器(StreamDispatcherSequencial)</p>
<p>该工具会将其输入流以顺序次序路由(route)给<code class="docutils literal notranslate"><span class="pre">outputCount</span></code>流。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">inputStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">dispatchedStreams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">StreamDispatcherSequencial</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputStream</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">outputCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="flow">
<h2>Flow<a class="headerlink" href="#flow" title="Permalink to this heading"></a></h2>
<section id="id79">
<h3>一、规范(Specification)<a class="headerlink" href="#id79" title="Permalink to this heading"></a></h3>
<p>Flow接口是一个简单的有效(valid)/负载(payload)协议, 意味着从端口(slave)无法中断总线。</p>
<p>例如, 它可以用来表示来自UART控制器的数据或者向一个片上存储写数据的请求等。</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">信号</th>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">驱动</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">Don't care 条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">valid</td>
<td style="text-align: center;">Bool</td>
<td style="text-align: center;">Master</td>
<td style="text-align: center;">当置高时, 说明负载通过该接口</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">payload</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">Master</td>
<td style="text-align: center;">负载任务的内容</td>
<td style="text-align: center;">valid为低时, dont care</td>
</tr>
</tbody>
</table></section>
<section id="id80">
<h3>二、函数(Functions)<a class="headerlink" href="#id80" title="Permalink to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">句式</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">返回值</th>
<th style="text-align: center;">延迟</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Flow(type : Data)</td>
<td style="text-align: center;">建立一个给定类型的Flow</td>
<td style="text-align: center;">Flow[T]</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">master/slave Stream(type : Data)</td>
<td style="text-align: center;">建立一个给定类型的Flow, 并根据给定的IO设置初始化</td>
<td style="text-align: center;">Flow[T]</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">x.m2sPipe()</td>
<td style="text-align: center;">返回一个由x通过寄存器驱动的流 <br>valid/ready/payload路径通过一些寄存器分割。</td>
<td style="text-align: center;">Flow[T]</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">x &lt;&lt; y<br>y &gt;&gt; x</td>
<td style="text-align: center;">把y连接到x</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">x &lt;-&lt; y<br>y &gt;-&gt; x</td>
<td style="text-align: center;">通过m2sPipe把y连接到x</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">x.throwWhen(cond : Bool)</td>
<td style="text-align: center;">返回一个连接到x的Flow, 并且当cond为true时抛弃交换任务(Transaction)</td>
<td style="text-align: center;">Flow[T]</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">x.toReg()</td>
<td style="text-align: center;">返回一个当valid置高时加在<code>payload</code>的寄存器</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">x.setIdle()</td>
<td style="text-align: center;">将Flow置为空闲状态：<code>valid</code>为<code>False</code>并且不关心负载<code>payload</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">x.push(newPayload: T)</td>
<td style="text-align: center;">给予当前Flow一个新的有效负载。<code>valid</code>被设置为<code>True</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table></section>
<section id="code-example">
<h3>三、代码实例(code example)<a class="headerlink" href="#code-example" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Flow</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">answer</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">Flow</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">fsm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StateMachine</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">answer</span><span class="p">.</span><span class="n">setIdle</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">idle</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">EntryPoint</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">whenIsActive</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">valid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">storage</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">request</span><span class="p">.</span><span class="n">payload</span><span class="w"></span>
<span class="w">        </span><span class="n">goto</span><span class="p">(</span><span class="n">sendEcho</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">sendEcho</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">whenIsActive</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">answer</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">storage</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">goto</span><span class="p">(</span><span class="n">idle</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 等价地</span>

<span class="n">answer</span><span class="w"> </span><span class="o">&lt;-&lt;</span><span class="w"> </span><span class="n">request</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="fragment">
<h2>片段(Fragment)<a class="headerlink" href="#fragment" title="Permalink to this heading"></a></h2>
<section id="id81">
<h3>一、规范(Specification)<a class="headerlink" href="#id81" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Fragment</span></code>包(Bundle)是利用多个小片段传输一个大集合的概念。例如：</p>
<ul class="simple">
<li><p>一张利用<code class="docutils literal notranslate"><span class="pre">Stream[Fragment[Pixel]]</span></code>传输的尺寸为width*height的图片。</p></li>
<li><p>一个接收来自控制器信号的无流控制协议的UART包可以在<code class="docutils literal notranslate"><span class="pre">Stream[Fragment[Bits]]</span></code>上传输</p></li>
<li><p>一个AXI突发读模式可以被<code class="docutils literal notranslate"><span class="pre">Stream[Fragment[AxiReadResponse]]</span></code>承载</p></li>
</ul>
<p>由<code class="docutils literal notranslate"><span class="pre">Fragment</span></code>包定义的信号是：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">信号</th>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">驱动</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">fragment</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">Master</td>
<td style="text-align: center;">当前传输的负载</td>
</tr>
<tr>
<td style="text-align: center;">last</td>
<td style="text-align: center;">Bool</td>
<td style="text-align: center;">Master</td>
<td style="text-align: center;">当该片段是当前包的最后一个片段时则置高</td>
</tr>
</tbody>
</table><p>可以发现根据规范和上述例子, <code class="docutils literal notranslate"><span class="pre">Fragment</span></code>不会指明传输任务是如何被传输的(用户可以使用Stream, Flow或其他任何协议)。它只会增加足够的信息<code class="docutils literal notranslate"><span class="pre">last</span></code>来告知当前传输是否为给定数据包的第一个, 最后一个还是中间的某一个。</p>
<blockquote>
<div><p><strong>注意：协议没有携带’first’比特是因为它可以通过执行’RegNextWhen(bus.last, bus.fire) init(True)’被生成在任何位置</strong></p>
</div></blockquote>
</section>
<section id="id82">
<h3>二、函数(Functions)<a class="headerlink" href="#id82" title="Permalink to this heading"></a></h3>
<p>对于<code class="docutils literal notranslate"><span class="pre">Stream[Fragment[T]]</span></code>和<code class="docutils literal notranslate"><span class="pre">Flow[Fragment[T]]</span></code>, 给出了以下函数:
|   句式    | 返回类型 |                         描述                         |
| :——-: | :——: | :————————————————–: |
|  x.first  |   Bool   |  当下一个或当前传输任务是包的第一个子片段时返回True  |
|  x.tail   |   Bool   | 当下一个或当前传输任务不是包的第一个子片段时返回True |
| x.isFirst |   Bool   |  当传输任务被提交且是数据包的第一个子片段时返回True  |
| x.isTail  |   Bool   | 当传输任务被提交且不是数据包的第一个子片段时返回True |
| x.isLast  |   Bool   | 当传输任务被提交且是数据包的最后一个子片段时返回True |</p>
<p>对于<code class="docutils literal notranslate"><span class="pre">Stream[Fragment[T]]</span></code>, 下面的函数也是可使用的:
|            句式            |      返回类型       |                    描述                     |
| :————————: | :—————–: | :—————————————–: |
| x.insertHeader(header : T) | Stream[Fragment[T]] | 对每一个<code class="docutils literal notranslate"><span class="pre">x</span></code>的包添加<code class="docutils literal notranslate"><span class="pre">header</span></code>并且返回结果总线 |</p>
</section>
</section>
<section id="state-machine">
<h2>状态机(State machine)<a class="headerlink" href="#state-machine" title="Permalink to this heading"></a></h2>
<section id="id83">
<h3>一、简介(Introduction)<a class="headerlink" href="#id83" title="Permalink to this heading"></a></h3>
<p>在SpinalHDL中用户可以像在VHDL/Verilog中一样定义状态机, 通过使用计数和Swith/Case语句。但是在SpinalHDL中也可以使用专用的语法。</p>
<p>下方的状态机可以被如下代码实现：</p>
<p><img alt="fsm_simple" src="_images/fsm_simple.svg" /></p>
<p>格式A:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">fsm</span><span class="p">.</span><span class="n">_</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">fsm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StateMachine</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">stateA</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">EntryPoint</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">whenIsActive</span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="n">stateB</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">stateB</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">onEntry</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">whenIsActive</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">goto</span><span class="p">(</span><span class="n">stateC</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">onExit</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">stateC</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">whenIsActive</span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="n">stateA</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>格式B：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">fsm</span><span class="p">.</span><span class="n">_</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">fsm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StateMachine</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">stateA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">EntryPoint</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">stateB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">stateC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>

<span class="w">    </span><span class="n">stateA</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="n">whenIsActive</span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="n">stateB</span><span class="p">))</span><span class="w"></span>

<span class="w">    </span><span class="n">stateB</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="n">onEntry</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="n">whenIsActive</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">goto</span><span class="p">(</span><span class="n">stateC</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="n">onExit</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">stateC</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="n">whenIsActive</span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="n">stateA</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Verilog:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="n">MyTopLevel</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_cond0</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_cond1</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">io_flag</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_state</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w">          </span><span class="n">io_result</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">localparam</span><span class="w"> </span><span class="n">fsm_enumDef_BOOT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="mi">&#39;d0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">localparam</span><span class="w"> </span><span class="n">fsm_enumDef_stateA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="mi">&#39;d1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">localparam</span><span class="w"> </span><span class="n">fsm_enumDef_stateB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="mi">&#39;d2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">localparam</span><span class="w"> </span><span class="n">fsm_enumDef_stateC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="mi">&#39;d3</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">fsm_wantExit</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">fsm_wantStart</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">fsm_wantKill</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">fsm_counter</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">counter</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">fsm_stateReg</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">fsm_stateNext</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_when_StateMachine_l233</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_when_StateMachine_l233_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_MyTopLevel_l54</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_StateMachine_l233</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_StateMachine_l249</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="no">`ifndef</span><span class="w"> </span><span class="n">SYNTHESIS</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="mh">47</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">fsm_stateReg_string</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="mh">47</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">fsm_stateNext_string</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="no">`endif</span><span class="w"></span>


<span class="w">  </span><span class="no">`ifndef</span><span class="w"> </span><span class="n">SYNTHESIS</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="p">(</span><span class="n">fsm_stateReg</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_enumDef_BOOT</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fsm_stateReg_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;BOOT  &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_enumDef_stateA</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fsm_stateReg_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;stateA&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_enumDef_stateB</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fsm_stateReg_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;stateB&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_enumDef_stateC</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fsm_stateReg_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;stateC&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">default</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fsm_stateReg_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;??????&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">endcase</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="p">(</span><span class="n">fsm_stateNext</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_enumDef_BOOT</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fsm_stateNext_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;BOOT  &quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_enumDef_stateA</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fsm_stateNext_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;stateA&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_enumDef_stateB</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fsm_stateNext_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;stateB&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_enumDef_stateC</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fsm_stateNext_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;stateC&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">default</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fsm_stateNext_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;??????&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">endcase</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="no">`endif</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">fsm_wantExit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">fsm_wantStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="p">(</span><span class="n">fsm_stateReg</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_enumDef_stateA</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_enumDef_stateB</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_enumDef_stateC</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">      </span><span class="k">default</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">fsm_wantStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">endcase</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">fsm_wantKill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">when_StateMachine_l233</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">io_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_when_StateMachine_l233</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">fsm_stateReg</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">fsm_enumDef_stateB</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_when_StateMachine_l233_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">fsm_stateNext</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">fsm_enumDef_stateB</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">fsm_stateNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsm_stateReg</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="p">(</span><span class="n">fsm_stateReg</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_enumDef_stateA</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">fsm_stateNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsm_enumDef_stateB</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_enumDef_stateB</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">when_MyTopLevel_l54</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">          </span><span class="n">fsm_stateNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsm_enumDef_stateC</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_enumDef_stateC</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">fsm_stateNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsm_enumDef_stateA</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">      </span><span class="k">default</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">endcase</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">fsm_wantStart</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_stateNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsm_enumDef_stateA</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">fsm_wantKill</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_stateNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsm_enumDef_BOOT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_MyTopLevel_l54</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">fsm_counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">8&#39;h04</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_StateMachine_l233</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_when_StateMachine_l233</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">_zz_when_StateMachine_l233_1</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_StateMachine_l249</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="o">!</span><span class="w"> </span><span class="n">_zz_when_StateMachine_l233</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">_zz_when_StateMachine_l233_1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_stateReg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">fsm_enumDef_BOOT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">fsm_stateReg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">fsm_stateNext</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">case</span><span class="p">(</span><span class="n">fsm_stateReg</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">fsm_enumDef_stateA</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">        </span><span class="n">fsm_enumDef_stateB</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">          </span><span class="n">fsm_counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">fsm_counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">8&#39;h01</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">        </span><span class="n">fsm_enumDef_stateC</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">        </span><span class="k">default</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">      </span><span class="k">endcase</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">when_StateMachine_l249</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">fsm_counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w">            </span><span class="c1">//这会产生有优先级的选择器，该情况优先级更高</span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>


<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="statemachine">
<h3>二、状态机(StateMachine)<a class="headerlink" href="#statemachine" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">StateMachine</span></code>是基本类(class), 它管理FSM的逻辑。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">myFsm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StateMachine</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 定义状态</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">StateMachine</span></code>还提供了一些访问器(accessors):
|       命名        | 返回类型 |                 描述                 |
| :—————: | :——: | :———————————-: |
|  isActive(state)  |   Bool   |  当状态机处于所给定的状态时返回true  |
| isEntering(state) |   Bool   | 当状态机要进入所给定的状态时返回true |</p>
<ol>
<li><p>入口点(Entry point)</p>
<p>通过扩展EntryPoint特征, 可以将状态定义为状态机的入口点:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">stateA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">EntryPoint</span><span class="w"></span>
</pre></div>
</div>
<p>或者通过使用<code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">stateA</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">State</span> <span class="pre">with</span> <span class="pre">EntryPoint</span></code>：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">stateA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"></span>
<span class="n">setEntry</span><span class="p">(</span><span class="n">stateA</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>转换(Transitions)</p>
<ul class="simple">
<li><p>转换由<code class="docutils literal notranslate"><span class="pre">goto(nextState)</span></code>表示, 它使得状态机在下一个周期转换到<code class="docutils literal notranslate"><span class="pre">nextState</span></code>。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exit()</span></code>将状态机在下一个周期转换为boot状态(boot state)(或者, 在<code class="docutils literal notranslate"><span class="pre">StateFsm</span></code>中, 退出当前嵌套状态机)。</p></li>
</ul>
</li>
</ol>
</section>
<section id="states">
<h3>三、状态(States)<a class="headerlink" href="#states" title="Permalink to this heading"></a></h3>
<p>多种状态可以被使用：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">State</span></code> (最基本的)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">StateDelay</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">StateFsm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">StateParallelFsm</span></code></p></li>
</ul>
<p>它们每个都提供以下函数来定义与它们相关的逻辑：
|                       命名                        |                                      描述                                      |
| :———————————————–: | :—————————————————————————-: |
|   state.onEntry {<br><code class="docutils literal notranslate">&#160; <span class="pre">yourStatements</span></code><br>}    |    <code class="docutils literal notranslate"><span class="pre">yourStatements</span></code>在状态机未处于<code class="docutils literal notranslate"><span class="pre">state</span></code>时应用, 并将在下一个周期处于<code class="docutils literal notranslate"><span class="pre">state</span></code>    |
|    state.onExit {<br><code class="docutils literal notranslate">&#160; <span class="pre">yourStatements</span></code><br>}    |    <code class="docutils literal notranslate"><span class="pre">yourStatements</span></code>在状态机处于<code class="docutils literal notranslate"><span class="pre">state</span></code>时应用, 并将在下一个周期处于其他状态     |
| state.whenIsActive {<br><code class="docutils literal notranslate">&#160; <span class="pre">yourStatements</span></code><br>} |                   <code class="docutils literal notranslate"><span class="pre">yourStatements</span></code>在状态机处于<code class="docutils literal notranslate"><span class="pre">state</span></code>时应用                    |
|  state.whenIsNext {<br><code class="docutils literal notranslate">&#160; <span class="pre">yourStatements</span></code><br>}  | <code class="docutils literal notranslate"><span class="pre">yourStatements</span></code>在状态机将在下一个周期处于<code class="docutils literal notranslate"><span class="pre">state</span></code>时执行(即使已经是<code class="docutils literal notranslate"><span class="pre">state</span></code>状态) |</p>
<p>``state.<code class="docutils literal notranslate"><span class="pre">隐含在一个</span></code>new State`块中：</p>
<p><img alt="fsm_stateb" src="_images/fsm_stateb.svg" /></p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">stateB</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">onEntry</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">whenIsActive</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">goto</span><span class="p">(</span><span class="n">stateC</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">onExit</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ol>
<li><p>状态延迟(StateDelay)</p>
<p><code class="docutils literal notranslate"><span class="pre">StateDelay</span></code>允许创建一个状态, 该状态在<code class="docutils literal notranslate"><span class="pre">whenCompleted{…}</span></code>语句执行之前等待固定数量的周期。首选的使用方法是:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">stateG</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StateDelay</span><span class="p">(</span><span class="n">cyclesCount</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">whenCompleted</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">goto</span><span class="p">(</span><span class="n">stateH</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w">   </span>
</pre></div>
</div>
<p>同样可以用一行代码来写：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">stateG</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StateDelay</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">whenCompleted</span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="n">stateH</span><span class="p">))</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>状态中的有限状态机(StateFsm)</p>
<p><code class="docutils literal notranslate"><span class="pre">StateFsm</span></code>允许描述包含嵌套状态机的状态。当嵌套状态机完成(退出)时, <code class="docutils literal notranslate"><span class="pre">whenCompleted{…}</span></code>执行。</p>
<p>例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// 内部的FSM按如下定义</span>
<span class="kd">val</span><span class="w"> </span><span class="n">stateC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StateFsm</span><span class="p">(</span><span class="n">fsm</span><span class="o">=</span><span class="n">internalFsm</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">whenCompleted</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">goto</span><span class="p">(</span><span class="n">stateD</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">def</span><span class="w"> </span><span class="nf">internalFsm</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StateMachine</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">stateA</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">EntryPoint</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">whenIsActive</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">goto</span><span class="p">(</span><span class="n">stateB</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">stateB</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">onEntry</span><span class="w"> </span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">whenIsActive</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">when</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">exit</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>在上面的示例中, <code class="docutils literal notranslate"><span class="pre">exit()</span></code>使状态机跳转到boot状态(内部隐藏状态)。这将通知<code class="docutils literal notranslate"><span class="pre">StateFsm</span></code>其内部状态机已完成。</p>
</li>
<li><p>状态中的并行有限状态机(StateParallelFsm)</p>
<p><code class="docutils literal notranslate"><span class="pre">StateParallelFsm</span></code>允许处理多个嵌套状态机。当所有嵌套状态机完成时, <code class="docutils literal notranslate"><span class="pre">whenCompleted{…}</span></code>执行。</p>
<p>例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">stateD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StateParallelFsm</span><span class="w"> </span><span class="p">(</span><span class="n">internalFsmA</span><span class="p">(),</span><span class="w"> </span><span class="n">internalFsmB</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">whenCompleted</span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">goto</span><span class="p">(</span><span class="n">stateE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>关于入口状态的注释(Notes about the entry state)</p>
<p>上面定义的进入状态的方式使得在重置复位和第一个时钟采样之间, 状态机处于启动状态。只有在第一次时钟采样之后, 定义的进入状态才有效。这允许正确地进入entry状态(应用<code class="docutils literal notranslate"><span class="pre">onEntry</span></code>中的语句), 并允许嵌套状态机。</p>
<p>虽然它很有用, 但也可以绕过该特性, 直接让状态机引导(boot)到用户状态。</p>
<p>为此, 使用<code class="docutils literal notranslate"><span class="pre">makeInstantEntry()</span></code>而不是定义一个<code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">State</span></code>。这个函数返回boot状态, 在复位后直接激活。</p>
<blockquote>
<div><p><strong>注意：该状态的<code class="docutils literal notranslate"><span class="pre">onEntry</span></code>只会在它从另一个状态转换到这个状态时调用, 而不会在启动期间调用。</strong></p>
</div></blockquote>
<blockquote>
<div><p><strong>注意：在仿真过程中, boot状态总是命名为<code class="docutils literal notranslate"><span class="pre">Boot</span></code>.</strong></p>
</div></blockquote>
<p>例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// 状态序列: IDLE, STATE_A, STATE_B, ...</span>
<span class="kd">val</span><span class="w"> </span><span class="n">fsm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StateMachine</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="c1">// IDLE在仿真中被命名为BOOT</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">IDLE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">makeInstantEntry</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">STATE_A</span><span class="p">,</span><span class="w"> </span><span class="nc">STATE_B</span><span class="p">,</span><span class="w"> </span><span class="nc">STATE_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"></span>

<span class="w">    </span><span class="nc">IDLE</span><span class="p">.</span><span class="n">whenIsActive</span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="nc">STATE_A</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="nc">STATE_A</span><span class="p">.</span><span class="n">whenIsActive</span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="nc">STATE_B</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="nc">STATE_B</span><span class="p">.</span><span class="n">whenIsActive</span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="nc">STATE_C</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="nc">STATE_C</span><span class="p">.</span><span class="n">whenIsActive</span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="nc">STATE_B</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">//  状态序列 : BOOT, IDLE, STATE_A, STATE_B, ...</span>
<span class="kd">val</span><span class="w"> </span><span class="n">fsm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StateMachine</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">IDLE</span><span class="p">,</span><span class="w"> </span><span class="nc">STATE_A</span><span class="p">,</span><span class="w"> </span><span class="nc">STATE_B</span><span class="p">,</span><span class="w"> </span><span class="nc">STATE_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">State</span><span class="w"></span>
<span class="w">    </span><span class="n">setEntry</span><span class="p">(</span><span class="nc">IDLE</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="nc">IDLE</span><span class="p">.</span><span class="n">whenIsActive</span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="nc">STATE_A</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="nc">STATE_A</span><span class="p">.</span><span class="n">whenIsActive</span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="nc">STATE_B</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="nc">STATE_B</span><span class="p">.</span><span class="n">whenIsActive</span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="nc">STATE_C</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="nc">STATE_C</span><span class="p">.</span><span class="n">whenIsActive</span><span class="p">(</span><span class="n">goto</span><span class="p">(</span><span class="nc">STATE_B</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="vexriscv-rv32im-cpu">
<h2>VexRiscv(RV32IM CPU)<a class="headerlink" href="#vexriscv-rv32im-cpu" title="Permalink to this heading"></a></h2>
<p>VexRiscv是一个适配fpga的RISC-V ISA CPU实现, 具有以下特性:</p>
<ul class="simple">
<li><p>RV32IM指令集</p></li>
<li><p>五级流水(Fetch, Decode, Execute, Memory, WriteBack)</p></li>
<li><p>当所有功能都启用时达到1.44 DMIPS/Mhz,</p></li>
<li><p>针对FPGA进行了优化</p></li>
<li><p>可选MUL / DIV扩展</p></li>
<li><p>可选的指令和数据缓存</p></li>
<li><p>可选的MMU</p></li>
<li><p>可选的调试扩展, 允许eclipse通过GDB &gt;&gt; openOCD &gt;&gt; JTAG连接进行调试</p></li>
<li><p>使用riscv-privileged-v1.9.1规范中的Machine和User模式可选的中断以及异常处理。</p></li>
<li><p>两个移位指令的实现, 单周期/移数(shiftNumber)循环</p></li>
<li><p>每个阶段可能有旁路或联锁的冒险(hazard)逻辑</p></li>
<li><p>FreeRTOS端口, 请见https://github.com/Dolu1990/FreeRTOS-RISCV</p></li>
</ul>
<p>更多信息请见：https://github.com/SpinalHDL/VexRiscv</p>
</section>
<section id="bus-slave-factory">
<h2>从端总线库(Bus Slave Factory)<a class="headerlink" href="#bus-slave-factory" title="Permalink to this heading"></a></h2>
<section id="id84">
<h3>一、简介<a class="headerlink" href="#id84" title="Permalink to this heading"></a></h3>
<p>在许多情况下, 需要实现一个总线寄存器行。<code class="docutils literal notranslate"><span class="pre">BusSlaveFactory</span></code>是一个工具, 它提供了一种抽象而流畅的方式来定义它们。</p>
<p>为了体现该工具的功能, 有一个简单的示例, 其使用Apb3SlaveFactory的变体来实现内存映射的UART(请见examples)。还有一个包含一个内存映射函数的Timer的例子(请见examples)。</p>
<p>您可以在(Developers area &gt;&gt; Bus Slave Factory Implementation)找到更多关于<code class="docutils literal notranslate"><span class="pre">BusSlaveFactory</span></code>工具内部实现的文档</p>
</section>
<section id="functionality">
<h3>二、功能性(Functionality)<a class="headerlink" href="#functionality" title="Permalink to this heading"></a></h3>
<p>目前<code class="docutils literal notranslate"><span class="pre">BusSlaveFactory</span></code>工具有三个实现方式:APB3、AXI-lite 3和Avalon。</p>
<p>该工具的每个实现都以一个对应总线的实例作为参数, 然后提供以下函数来映射用户的硬件到内存映射:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">命名</th>
<th style="text-align: center;">返回类型</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">busDataWidth</td>
<td style="text-align: center;">Int</td>
<td style="text-align: center;">返回总线的数据位宽</td>
</tr>
<tr>
<td style="text-align: center;">read(that,address,bitOffset)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">在<code>bitOffset</code>下的对<code>that</code>的回应</td>
</tr>
<tr>
<td style="text-align: center;">write(that,address,bitOffset)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">当总线对地址<code>address</code>写, 则将来自<code>bitOffset</code>的总线数据赋值给<code>that</code></td>
</tr>
<tr>
<td style="text-align: center;">onWrite(address)(doThat)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">当写操作发生在<code>address</code>地址时调用<code>doThat</code></td>
</tr>
<tr>
<td style="text-align: center;">onRead(address)(doThat)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">当读操作发生在<code>address</code>地址时调用<code>doThat</code></td>
</tr>
<tr>
<td style="text-align: center;">nonStopWrite(that,bitOffset)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">通过总线从<code>bitOffset</code>写数据并永久赋值给<code>that</code></td>
</tr>
<tr>
<td style="text-align: center;">readAndWrite(that,address,bitOffset)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">令<code>that</code>在<code>address</code>地址可读并可写, 并将其防止在字的<code>bitOffset</code>位置</td>
</tr>
<tr>
<td style="text-align: center;">readMultiWord(that,address)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">为从<code>address</code>读<code>that</code>创建内存映射。如果<code>that</code>大于一个字, 则它会扩大相应位置的寄存器</td>
</tr>
<tr>
<td style="text-align: center;">writeMultiWord(that,address)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">为向<code>address</code>写<code>that</code>创建内存映射。如果<code>that</code>大于一个字, 则它会扩大相应位置的寄存器</td>
</tr>
<tr>
<td style="text-align: center;">createWriteOnly(dataType,address,bitOffset)</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">创建一个<code>dataType</code>类型的只读寄存器并且放置于字的<code>bitOffset</code>位置</td>
</tr>
<tr>
<td style="text-align: center;">createReadWrite(dataType,address,bitOffset)</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">创建一个<code>dataType</code>类型的读写寄存器并且放置于字的<code>bitOffset</code>位置</td>
</tr>
<tr>
<td style="text-align: center;">createAndDriveFlow(dataType,address,bitOffset)</td>
<td style="text-align: center;">Flow[T]</td>
<td style="text-align: center;">创建一个<code>dataType</code>类型的可写流寄存器并且放置于字的<code>bitOffset</code>位置</td>
</tr>
<tr>
<td style="text-align: center;">drive(that,address,bitOffset)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">通过一个地址为<code>address</code>的可写寄存器驱动<code>that</code>并且放置于字的<code>bitOffset</code>位置</td>
</tr>
<tr>
<td style="text-align: center;">driveAndRead(that,address,bitOffset)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">通过一个地址为<code>address</code>的可读可写寄存器驱动<code>that</code>并且放置于字的<code>bitOffset</code>位置</td>
</tr>
<tr>
<td style="text-align: center;">driveFlow(that,address,bitOffset)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">当对地址<code>address</code>写时, 使用放置在字的<code>bitOffset</code>位置的数据发送<code>that</code>进行传输</td>
</tr>
<tr>
<td style="text-align: center;">readStreamNonBlocking(that,<br>address,<br>validBitOffset,<br>payloadBitOffset)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">当对<code>address</code>地址读时, 读取<code>that</code>并完成传输<br>valid &lt;= validBitOffset bit <br> payload &lt;= payloadBitOffset+widthOf(payload) downto <code>payloadBitOffset</code></td>
</tr>
<tr>
<td style="text-align: center;">doBitsAccumulationAndClearOnRead(that,<br>address,<br>bitOffset)</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">实例化一个内部寄存器, 其每周期会进行：reg := reg</td>
</tr>
</tbody>
</table></section>
</section>
<section id="fiber-framework">
<h2>纤程框架(Fiber Framework)<a class="headerlink" href="#fiber-framework" title="Permalink to this heading"></a></h2>
<p>目前还在发展中。</p>
<p>纤程(Fiber)可以以乱序行为运行硬件生成, 其与Makefile类似, 用户可以定义运行命令时所需的规则和依赖。这和Scala Future的特性很像。</p>
<p>这样的框架将一些简单的事物复杂化但也为复杂情况提供了一些强特性：</p>
<ul class="simple">
<li><p>用户可以在知道需求前定义某些事物, 例如：可以在知道需要多少行中断前例化一个中断控制器。</p></li>
<li><p>抽象/懒惰化(lazy)/部分化 SoC架构定义可以允许SoC模板未来的特定化。</p></li>
<li><p>以去中心化方式对多个任务进行自动需求仲裁, 例如：在一个内存总线的主端口和从端口之间。</p></li>
</ul>
<p>该框架主要组成为：</p>
<ul class="simple">
<li><p>Handle[T], 可用于存储T类型的值。</p></li>
<li><p>handle.load允许设置句柄(handle)值的加载(将重新调度所有等待它的任务)。</p></li>
<li><p>handle.get, 返回给定句柄的值。如果该句柄尚未加载, 则会阻塞任务执行。</p></li>
<li><p>Handle{ code }, 分支出将执行给定代码的新任务。该代码的结果将加载到句柄中</p></li>
<li><p>soon(handle), 允许当前任务宣布, 其将加载一个值的句柄(用于跟踪句柄)</p></li>
</ul>
<p>警告, 这不是通常的RTL描述, 并针对大型系统生成。它目前被用作SaxonSoC中的顶层集成工具。</p>
<section id="simple-dummy-example">
<h3>一、简单的样例(Simple dummy example)<a class="headerlink" href="#simple-dummy-example" title="Permalink to this heading"></a></h3>
<p>这里有一个简单的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">fiber</span><span class="p">.</span><span class="n">_</span>

<span class="c1">// 创建两个空句柄</span>
<span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Handle</span><span class="p">[</span><span class="nc">Int</span><span class="p">]</span><span class="w"></span>

<span class="c1">// 创建一个异步加载所给定值的句柄</span>
<span class="kd">val</span><span class="w"> </span><span class="n">calculator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Handle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">get</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">get</span><span class="w"> </span><span class="c1">// .get 将会锁定他们直到它们被加载</span>

<span class="c1">// Same as above</span>
<span class="kd">val</span><span class="w"> </span><span class="n">printer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Handle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="s">s&quot;a + b = </span><span class="si">${</span><span class="n">calculator</span><span class="p">.</span><span class="n">get</span><span class="si">}</span><span class="s">&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">// .get 将会锁定直到计算主体被完成</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// 同步加载a和b, 这将锁定a.get和b.get</span>
<span class="n">a</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"></span>
<span class="n">b</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>它的运行步骤将会是：</p>
<ul class="simple">
<li><p>创建a和b</p></li>
<li><p>创建计算器任务分支, 但在执行a.get时被阻塞</p></li>
<li><p>创建打印任务分支, 但在执行calculator.get时被阻塞</p></li>
<li><p>加载a和b, 重新调度计算器任务(因为它正在等待a)</p></li>
<li><p>计算器完成a+b操作, 并将结果载入它的句柄, 这将重新调度打印任务</p></li>
<li><p>打印任务打印其结果</p></li>
<li><p>完成所有</p></li>
</ul>
<p>所以, 这个例子主要是为了展示SpinalHDL可以克服顺序执行等, 因为a和b可以在计算器的定义后被加载。</p>
</section>
<section id="handle-t">
<h3>二、Handle[T]<a class="headerlink" href="#handle-t" title="Permalink to this heading"></a></h3>
<p>Handle[T]类似于scala的Future[T], 它们允许在某个对象存在之前就调用它, 并等待它。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Handle</span><span class="p">[</span><span class="nc">Int</span><span class="p">]</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">xPlus2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Handle</span><span class="p">[</span><span class="nc">Int</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">produce</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">get</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">//x.produce 可以被用来当x加载时创建一个新句柄</span>
<span class="kd">val</span><span class="w"> </span><span class="n">xPlus3</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Handle</span><span class="p">[</span><span class="nc">Int</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">derivate</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">    </span><span class="c1">//x.derivate 和 x.produce类似, 但也要提供x.get作为lambda函数的参数</span>
<span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="c1">//x 将会包含值为3</span>
</pre></div>
</div>
<ol>
<li><p>soon(handle)</p>
<p>为了维护一个正确的任务和句柄之间的依赖关系图, 任务可以预先指明它将加载一个给定的句柄。这在生成程序发生饥饿(Starvation)/死锁(deadlock)的情况下非常有用, 以便SpinalHDL准确地报告问题所在。</p>
</li>
</ol>
</section>
</section>
<section id="binary-system">
<h2>二进制系统(Binary System)<a class="headerlink" href="#binary-system" title="Permalink to this heading"></a></h2>
<section id="id85">
<h3>一、规范(Specification)<a class="headerlink" href="#id85" title="Permalink to this heading"></a></h3>
<p>这里的某些对象和HDL没有关系, 但是他们在数字系统中很常见。尤其是算法参考模型经常被使用。另外, 它们也用在测试实例(testbench)的编写中。</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">命名</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">返回类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">String.asHex</td>
<td style="text-align: center;">十六进制字符串转为BigInt == BigInt(string, 16)</td>
<td style="text-align: center;">BigInt</td>
</tr>
<tr>
<td style="text-align: center;">String.asDec</td>
<td style="text-align: center;">十进制字符串转为BigInt == BigInt(string, 10)</td>
<td style="text-align: center;">BigInt</td>
</tr>
<tr>
<td style="text-align: center;">String.asOct</td>
<td style="text-align: center;">八进制字符串转为BigInt == BigInt(string, 8)</td>
<td style="text-align: center;">BigInt</td>
</tr>
<tr>
<td style="text-align: center;">String.asBin</td>
<td style="text-align: center;">二进制字符串转为BigInt == BigInt(string, 2)</td>
<td style="text-align: center;">BigInt</td>
</tr>
<tr>
<td style="text-align: center;">Byte​&#x7C;​Int​&#x7C;​Long​&#x7C;​BigInt.hexString()</td>
<td style="text-align: center;">转为HEX String</td>
<td style="text-align: center;">String</td>
</tr>
<tr>
<td style="text-align: center;">Byte​&#x7C;​Int​&#x7C;​Long​&#x7C;​BigInt.octString()</td>
<td style="text-align: center;">转为Oct String</td>
<td style="text-align: center;">String</td>
</tr>
<tr>
<td style="text-align: center;">Byte​&#x7C;Int​&#x7C;Long​&#x7C;BigInt.binString()</td>
<td style="text-align: center;">转为Bin String</td>
<td style="text-align: center;">String</td>
</tr>
<tr>
<td style="text-align: center;">Byte​&#x7C;Int​&#x7C;Long​&#x7C;BigInt.hexString(bitSize)</td>
<td style="text-align: center;">首先对齐位大小, 然后转为十六进制字符串</td>
<td style="text-align: center;">String</td>
</tr>
<tr>
<td style="text-align: center;">Byte​&#x7C;Int​&#x7C;Long​&#x7C;BigInt.octString(bitSize)</td>
<td style="text-align: center;">首先对齐位大小, 然后转为八进制字符串</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">Byte​&#x7C;Int​&#x7C;Long​&#x7C;BigInt.binString(bitSize)</td>
<td style="text-align: center;">首先对齐位大小, 然后转为二进制字符串</td>
<td style="text-align: center;">String</td>
</tr>
<tr>
<td style="text-align: center;">Byte​&#x7C;Int​&#x7C;Long​&#x7C;BigInt.toBinInts()</td>
<td style="text-align: center;">转为二进制列表(BinaryList)</td>
<td style="text-align: center;">List[Int]</td>
</tr>
<tr>
<td style="text-align: center;">Byte​&#x7C;Int​&#x7C;Long​&#x7C;BigInt.toDecInts()</td>
<td style="text-align: center;">转为十进制列表(DecimalList)</td>
<td style="text-align: center;">List[Int]</td>
</tr>
<tr>
<td style="text-align: center;">Byte​&#x7C;Int​&#x7C;Long​&#x7C;BigInt.toOctInts()</td>
<td style="text-align: center;">转为八进制列表(OctalList)</td>
<td style="text-align: center;">List[Int]</td>
</tr>
<tr>
<td style="text-align: center;">Byte​&#x7C;Int​&#x7C;Long​&#x7C;BigInt.toBinInts(num)</td>
<td style="text-align: center;">转到BinaryList, 对齐到num参数大小并填充0</td>
<td style="text-align: center;">List[Int]</td>
</tr>
<tr>
<td style="text-align: center;">Byte​&#x7C;Int​&#x7C;Long​&#x7C;BigInt.toDecInts(num)</td>
<td style="text-align: center;">转到DecimalList, 对齐到num参数大小并填充0</td>
<td style="text-align: center;">List[Int]</td>
</tr>
<tr>
<td style="text-align: center;">Byte​&#x7C;Int​&#x7C;Long​&#x7C;BigInt.toOctInts(num)</td>
<td style="text-align: center;">专到OctalList, 对齐到num参数大小并填充0</td>
<td style="text-align: center;">List[Int]</td>
</tr>
<tr>
<td style="text-align: center;">“3F2A”.hexToBinInts</td>
<td style="text-align: center;">十六进制字符串转为二进制列表</td>
<td style="text-align: center;">List[Int]</td>
</tr>
<tr>
<td style="text-align: center;">“3F2A”.hexToBinIntsAlign</td>
<td style="text-align: center;">十六进制字符串转为二进制列表并对齐到4倍大小</td>
<td style="text-align: center;">List[Int]</td>
</tr>
<tr>
<td style="text-align: center;">List(1,0,1,0,…).binIntsToHex</td>
<td style="text-align: center;">二进制列表转为十六进制字符串</td>
<td style="text-align: center;">String</td>
</tr>
<tr>
<td style="text-align: center;">List(1,0,1,0,…).binIntsToOct</td>
<td style="text-align: center;">二进制列表转为八进制字符串</td>
<td style="text-align: center;">String</td>
</tr>
<tr>
<td style="text-align: center;">List(1,0,1,0,…).binIntsToHexAlignHigh</td>
<td style="text-align: center;">二进制列表的大小对齐到4倍大小(填充0)然后转为十六进制字符串</td>
<td style="text-align: center;">String</td>
</tr>
<tr>
<td style="text-align: center;">List(1,0,1,0,…).binIntsToOctAlignHigh</td>
<td style="text-align: center;">二进制列表的大小对齐到3倍大小(填充0)然后转为八进制字符串</td>
<td style="text-align: center;">String</td>
</tr>
<tr>
<td style="text-align: center;">List(1,0,1,0,…).binIntsToInt</td>
<td style="text-align: center;">二进制列表(最大尺寸为32)转为Int</td>
<td style="text-align: center;">Int</td>
</tr>
<tr>
<td style="text-align: center;">List(1,0,1,0,…).binIntsToLong</td>
<td style="text-align: center;">二进制列表(最大尺寸为64)转为Long</td>
<td style="text-align: center;">Long</td>
</tr>
<tr>
<td style="text-align: center;">List(1,0,1,0,…).binIntsToBigInt</td>
<td style="text-align: center;">二进制列表(最大尺寸无限制)转为BigInt</td>
<td style="text-align: center;">BigInt</td>
</tr>
<tr>
<td style="text-align: center;">Int.toBigInt</td>
<td style="text-align: center;">32.toBigInt == BigInt(32)</td>
<td style="text-align: center;">BigInt</td>
</tr>
<tr>
<td style="text-align: center;">Long.toBigInt</td>
<td style="text-align: center;">3233113232L.toBigInt == BigInt(3233113232L)</td>
<td style="text-align: center;">BigInt</td>
</tr>
<tr>
<td style="text-align: center;">Byte.toBigInt</td>
<td style="text-align: center;">8.toByte.toBigInt == BigInt(8.toByte)</td>
<td style="text-align: center;">BigInt</td>
</tr>
</tbody>
</table></section>
<section id="int-long-bigint-string-to-int-long-bigint">
<h3>二、字符串转Int/Long/BigInt(String to Int/Long/BigInt)<a class="headerlink" href="#int-long-bigint-string-to-int-long-bigint" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="n">_</span>

<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;32FF190&quot;</span><span class="p">.</span><span class="n">asHex</span><span class="w"></span>

<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;12384798999999&quot;</span><span class="p">.</span><span class="n">asDec</span><span class="w"></span>

<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;123456777777700&quot;</span><span class="p">.</span><span class="n">asOct</span><span class="w"></span>

<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;10100011100111111&quot;</span><span class="p">.</span><span class="n">asBin</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="int-long-bigint-string">
<h3>三、Int/Long/BigInt 转为 String<a class="headerlink" href="#int-long-bigint-string" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="n">_</span>

<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;32FF190&quot;</span><span class="p">.</span><span class="n">asHex</span><span class="p">.</span><span class="n">hexString</span><span class="p">()</span><span class="w"></span>
<span class="s">&quot;32FF190&quot;</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;123456777777700&quot;</span><span class="p">.</span><span class="n">asOct</span><span class="p">.</span><span class="n">octString</span><span class="p">()</span><span class="w"></span>
<span class="s">&quot;123456777777700&quot;</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;10100011100111111&quot;</span><span class="p">.</span><span class="n">asBin</span><span class="p">.</span><span class="n">binString</span><span class="p">()</span><span class="w"></span>
<span class="s">&quot;10100011100111111&quot;</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="il">32323239988L</span><span class="p">.</span><span class="n">hexString</span><span class="p">()</span><span class="w"></span>
<span class="mf">7869d</span><span class="mi">8034</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="il">3239988L</span><span class="p">.</span><span class="n">octString</span><span class="p">()</span><span class="w"></span>
<span class="mi">14270064</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="mi">34</span><span class="p">.</span><span class="n">binString</span><span class="p">()</span><span class="w"></span>
<span class="mi">100010</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="int-long-bigint-binary-list">
<h3>四、Int/Long/BigInt 转为 Binary-List<a class="headerlink" href="#int-long-bigint-binary-list" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="n">_</span>

<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="mi">32</span><span class="p">.</span><span class="n">toBinInts</span><span class="w"></span>
<span class="nc">List</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="il">1302309988L</span><span class="p">.</span><span class="n">toBinInts</span><span class="w"></span>
<span class="nc">List</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="s">&quot;100101110&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">toBinInts</span><span class="w"></span>
<span class="nc">List</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="s">&quot;123456789abcdef0&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">).</span><span class="n">toBinInts</span><span class="w"></span>
<span class="nc">List</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="s">&quot;1234567&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">).</span><span class="n">toBinInts</span><span class="w"></span>
<span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="s">&quot;123451118&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">).</span><span class="n">toBinInts</span><span class="w"></span>
<span class="nc">List</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>对齐到固定位宽：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="n">_</span>

<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="mi">39</span><span class="p">.</span><span class="n">toBinInts</span><span class="p">()</span><span class="w"></span>
<span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="mi">39</span><span class="p">.</span><span class="n">toBinInts</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w">    </span><span class="c1">// 对齐到填充0的8比特</span>
<span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="binary-list-int-long-bigint">
<h3>五、Binary-List 转为 Int/Long/BigInt<a class="headerlink" href="#binary-list-int-long-bigint" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="n">_</span>

<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">binIntsToInt</span><span class="w"></span>
<span class="mi">39</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">:,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">binIntsToLong</span><span class="w"></span>
<span class="mi">39</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">binIntsToBigInt</span><span class="w"></span>
<span class="mi">1302309988</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">binIntsToHex</span><span class="w"></span>
<span class="mi">27</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">binIntsToHexAlignHigh</span><span class="w"></span>
<span class="mi">9</span><span class="n">c</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">binIntsToOct</span><span class="w"></span>
<span class="mi">47</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">binIntsToHexAlignHigh</span><span class="w"></span>
<span class="mi">47</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="bigint-bigint-enricher">
<h3>六、BigInt放大器(BigInt enricher)<a class="headerlink" href="#bigint-bigint-enricher" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="mi">32</span><span class="p">.</span><span class="n">toBigInt</span><span class="w"></span>
<span class="mi">32</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="il">3211323244L</span><span class="p">.</span><span class="n">toBigInt</span><span class="w"></span>
<span class="mi">3211323244</span><span class="w"></span>
<span class="n">$</span><span class="p">:</span><span class="w"> </span><span class="mi">8</span><span class="p">.</span><span class="n">toByte</span><span class="p">.</span><span class="n">toBigInt</span><span class="w"></span>
<span class="mi">8</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="regif">
<h2>寄存器接口(RegIf)<a class="headerlink" href="#regif" title="Permalink to this heading"></a></h2>
<p>寄存器接口搭建器：</p>
<ul class="simple">
<li><p>自动寻址, 字段分配和冲突检测</p></li>
<li><p>28个寄存器类型(涵盖UVM标准定义的25种类型)</p></li>
<li><p>自动文献生成</p></li>
</ul>
<section id="automatic-allocation">
<h3>一、自动分配(Automatic allocation)<a class="headerlink" href="#automatic-allocation" title="Permalink to this heading"></a></h3>
<p>自动地址分配：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RegBankExample</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">apb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3</span><span class="p">(</span><span class="nc">Apb3Config</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">busif</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3BusInterface</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="p">,(</span><span class="mh">0x0000</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="nc">Byte</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">M_REG0</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">newReg</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;REG0&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">M_REG1</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">newReg</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;REG1&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">M_REG2</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">newReg</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;REG2&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">M_REGn</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">newRegAt</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="mh">0x40</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;REGn&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">M_REGn1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">newReg</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;REGn1&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">HtmlGenerator</span><span class="p">(</span><span class="s">&quot;regif.html&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;AP&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="c1">// busif.accept(CHeaderGenerator(&quot;header.h&quot;, &quot;AP&quot;))</span>
<span class="w">  </span><span class="c1">// busif.accept(JsonGenerator(&quot;regif.json&quot;))</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><img alt="_images/reg-auto-allocate.jpg" src="_images/reg-auto-allocate.jpg" /></p>
<p>自动字段分配：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="nc">M_REG0</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">newReg</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;REG1&quot;</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">fd0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">M_REG0</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">bit</span><span class="p">),</span><span class="w"> </span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="w"> </span><span class="s">&quot;fields 0&quot;</span><span class="p">)</span><span class="w"></span>
<span class="nc">M_REG0</span><span class="p">.</span><span class="n">reserved</span><span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">fd1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">M_REG0</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="n">bit</span><span class="p">),</span><span class="w"> </span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="w"> </span><span class="s">&quot;fields 0&quot;</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">fd2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">M_REG0</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="n">bit</span><span class="p">),</span><span class="w"> </span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="w"> </span><span class="s">&quot;fields 0&quot;</span><span class="p">)</span><span class="w"></span>
<span class="c1">//自动保存2 bits</span>
<span class="kd">val</span><span class="w"> </span><span class="n">fd3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">M_REG0</span><span class="p">.</span><span class="n">fieldAt</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bit</span><span class="p">),</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="w"> </span><span class="s">&quot;fields 3&quot;</span><span class="p">)</span><span class="w"></span>
<span class="c1">//自动保存12 bits</span>
</pre></div>
</div>
<p><img alt="field-auto-allocate" src="_images/field-auto-allocate.gif" /></p>
<p>冲突检测：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="nc">M_REG1</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">newReg</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;REG1&quot;</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">r1fd0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">M_REG1</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;fields 1&quot;</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">r1fd2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">M_REG1</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">18</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;fields 1&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="n">cause</span><span class="w"> </span><span class="nc">Exception</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="nc">M_REG1</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">newReg</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;REG1&quot;</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">r1fd0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">M_REG1</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;fields 1&quot;</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">r1fd2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">M_REG1</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;fields 1&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="n">cause</span><span class="w"> </span><span class="nc">Exception</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="access-types">
<h3>二、28种可支持类型(28 Access Types)<a class="headerlink" href="#access-types" title="Permalink to this heading"></a></h3>
<p>大多数这些类型来自于UVM定义：
| 接入类型 |                          描述                           | 来源  |
| :——: | :—————————————————–: | :—: |
|    RO    |                  w: 无影响, r: 无影响                   |  UVM  |
|    RW    |                   w: as-is, r: 无影响                   |  UVM  |
|    RC    |               w: 无影响, r: 清空所有比特                |  UVM  |
|    RS    |               w: 无影响, r: 设置所有比特                |  UVM  |
|   WRC    |                w: as-is, r: 清空所有比特                |  UVM  |
|   WRS    |                w: as-is, r: 设置所有比特                |  UVM  |
|    WC    |               w: 清空所有比特, r: 无影响                |  UVM  |
|    WS    |               w: 设置所有比特, r: 无影响                |  UVM  |
|   WSRC   |            w: 设置所有比特, r: 清空所有比特             |  UVM  |
|   WCRC   |            w: 清空所有比特, r: 设置所有比特             |  UVM  |
|   W1C    |       w: 1/0 清空/对于匹配的比特无影响, r: 无影响       |  UVM  |
|   W1S    |       w: 1/0 设置/对于匹配的比特无影响, r: 无影响       |  UVM  |
|   W1T    |       w: 1/0 切换/对于匹配的比特无影响, r: 无影响       |  UVM  |
|   W0C    |          w: 1/0 无影响/清空匹配比特, r: 无影响          |  UVM  |
|   W0S    |          w: 1/0 无影响/设置匹配比特, r: 无影响          |  UVM  |
|   W0T    |          w: 1/0 无影响/切换匹配比特, r: 无影响          |  UVM  |
|  W1SRC   |    w: 1/0 设置/对于匹配的比特无影响, r: 清空所有比特    |  UVM  |
|  W1CRS   |    w: 1/0 清空/对于匹配的比特无影响, r: 设置所有比特    |  UVM  |
|  W0SRC   |       w: 1/0 无影响/设置匹配比特, r: 清空所有比特       |  UVM  |
|  W0CRS   |       w: 1/0 无影响/清空匹配比特, r: 设置所有比特       |  UVM  |
|    WO    |                   w: as-is, r: error                    |  UVM  |
|   WOC    |                w: 清空所有比特, r: error                |  UVM  |
|   WOS    |                w: 设置所有比特, r: error                |  UVM  |
|    W1    | w: 第一个进行硬复位的是as-is, 其他w对s无影响, r: 无影响 |  UVM  |
|   WO1    |  w: 第一个进行硬复位的是as-is,其他w对s无影响, r: 错误   |  UVM  |
|    NA    |                w: reserved, r: reserved                 |  New  |
|   W1P    |      w: 1/0 pulse/对于匹配的比特无影响, r: 无影响       |  New  |
|   W0P    |      w: 0/1 pulse/对于匹配的比特无影响, r: 无影响       |  New  |</p>
</section>
<section id="automatic-documentation-generation">
<h3>三、自动文献生成(Automatic documentation generation)<a class="headerlink" href="#automatic-documentation-generation" title="Permalink to this heading"></a></h3>
<p>文献类型：
|  文献类型  |                                使用                                 | 状态  |
| :——–: | :—————————————————————–: | :—: |
|    HTML    | <code class="docutils literal notranslate"><span class="pre">busif.accept(HtmlGenerator(&quot;regif&quot;,</span> <span class="pre">title</span> <span class="pre">=</span> <span class="pre">&quot;XXX</span> <span class="pre">register</span> <span class="pre">file&quot;))</span></code> |   Y   |
|  CHeader   |          <code class="docutils literal notranslate"><span class="pre">busif.accept(CHeaderGenerator(&quot;header&quot;,</span> <span class="pre">&quot;AP&quot;))</span></code>           |   Y   |
|    JSON    |               <code class="docutils literal notranslate"><span class="pre">busif.accept(JsonGenerator(&quot;regif&quot;))</span></code>                |   Y   |
| RALF(UVM)  |               <code class="docutils literal notranslate"><span class="pre">busif.accept(RalfGenerator(&quot;header&quot;))</span></code>               |   Y   |
| Latex(pdf) |                                                                     |   N   |
|    docx    |                                                                     |   N   |</p>
<p>HTML自动文档目前完成了, 生成的HTML文档如下：</p>
<p><img alt="regif-html" src="_images/regif-html.png" /></p>
</section>
<section id="id86">
<h3>四、例子<a class="headerlink" href="#id86" title="Permalink to this heading"></a></h3>
<p>批量创建REG-Address和字段寄存器：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">bus</span><span class="p">.</span><span class="nn">regif</span><span class="p">.</span><span class="n">_</span>

<span class="k">class</span><span class="w"> </span><span class="nc">RegBank</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">apb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">Apb3</span><span class="p">(</span><span class="nc">Apb3Config</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">stats</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bit</span><span class="p">),</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">IQ</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bit</span><span class="p">),</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">busif</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3BusInterface</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mh">0x000</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="nc">Byte</span><span class="p">),</span><span class="w"> </span><span class="n">regPre</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;AP&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">9</span><span class="p">).</span><span class="n">map</span><span class="p">{</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//这里使用setName对REG命名特殊名字以方便文档使用</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">REG</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">newReg</span><span class="p">(</span><span class="n">doc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">s&quot;Register</span><span class="si">${</span><span class="n">i</span><span class="si">}</span><span class="s">&quot;</span><span class="p">).</span><span class="n">setName</span><span class="p">(</span><span class="s">s&quot;REG</span><span class="si">${</span><span class="n">i</span><span class="si">}</span><span class="s">&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">REG</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">SInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bit</span><span class="p">),</span><span class="w"> </span><span class="nc">AccessType</span><span class="p">.</span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Complex real&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">imag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">REG</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">SInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bit</span><span class="p">),</span><span class="w"> </span><span class="nc">AccessType</span><span class="p">.</span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Complex imag&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">stat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">REG</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bit</span><span class="p">),</span><span class="w"> </span><span class="nc">AccessType</span><span class="p">.</span><span class="nc">RO</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Accelerator status&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="nc">IQ</span><span class="p">(</span><span class="n">i</span><span class="p">)(</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="n">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">real</span><span class="p">.</span><span class="n">asBits</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="nc">IQ</span><span class="p">(</span><span class="n">i</span><span class="p">)(</span><span class="mi">15</span><span class="w"> </span><span class="n">downto</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">imag</span><span class="p">.</span><span class="n">asBits</span><span class="w"></span>
<span class="w">    </span><span class="n">stat</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">stats</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">genDocs</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">CHeaderGenerator</span><span class="p">(</span><span class="s">&quot;regbank&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;AP&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">HtmlGenerator</span><span class="p">(</span><span class="s">&quot;regbank&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Interupt Example&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">JsonGenerator</span><span class="p">(</span><span class="s">&quot;regbank&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">RalfGenerator</span><span class="p">(</span><span class="s">&quot;regbank&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="bp">this</span><span class="p">.</span><span class="n">genDocs</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="nc">SpinalVerilog</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">RegBank</span><span class="p">())</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="interrupt-factory">
<h3>五、中断库(Interrupt Factory)<a class="headerlink" href="#interrupt-factory" title="Permalink to this heading"></a></h3>
<p>手动书写中断：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">cpInterruptExample</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="kd">val</span><span class="w"> </span><span class="n">tx_done</span><span class="p">,</span><span class="w"> </span><span class="n">rx_done</span><span class="p">,</span><span class="w"> </span><span class="n">frame_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">     </span><span class="kd">val</span><span class="w"> </span><span class="n">interrupt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">     </span><span class="kd">val</span><span class="w"> </span><span class="n">apb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">Apb3</span><span class="p">(</span><span class="nc">Apb3Config</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">)))</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">busif</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3BusInterface</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mh">0x000</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="nc">Byte</span><span class="p">),</span><span class="w"> </span><span class="n">regPre</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;AP&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="nc">M_CP_INT_RAW</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">newReg</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;cp int raw register&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">tx_int_raw</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="nc">M_CP_INT_RAW</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bool</span><span class="p">(),</span><span class="w"> </span><span class="nc">W1C</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;tx interrupt enable register&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">rx_int_raw</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="nc">M_CP_INT_RAW</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bool</span><span class="p">(),</span><span class="w"> </span><span class="nc">W1C</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;rx interrupt enable register&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">frame_int_raw</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">M_CP_INT_RAW</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bool</span><span class="p">(),</span><span class="w"> </span><span class="nc">W1C</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;frame interrupt enable register&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="nc">M_CP_INT_FORCE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">newReg</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;cp int force register\n for debug use&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">tx_int_force</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">M_CP_INT_FORCE</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bool</span><span class="p">(),</span><span class="w"> </span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;tx interrupt enable register&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">rx_int_force</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">M_CP_INT_FORCE</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bool</span><span class="p">(),</span><span class="w"> </span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;rx interrupt enable register&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">frame_int_force</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">M_CP_INT_FORCE</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bool</span><span class="p">(),</span><span class="w"> </span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;frame interrupt enable register&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="nc">M_CP_INT_MASK</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">newReg</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;cp int mask register&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">tx_int_mask</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="nc">M_CP_INT_MASK</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bool</span><span class="p">(),</span><span class="w"> </span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;tx interrupt mask register&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">rx_int_mask</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="nc">M_CP_INT_MASK</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bool</span><span class="p">(),</span><span class="w"> </span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;rx interrupt mask register&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">frame_int_mask</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">M_CP_INT_MASK</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bool</span><span class="p">(),</span><span class="w"> </span><span class="nc">RW</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;frame interrupt mask register&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="nc">M_CP_INT_STATUS</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">newReg</span><span class="p">(</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;cp int state register&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">tx_int_status</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="nc">M_CP_INT_STATUS</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bool</span><span class="p">(),</span><span class="w"> </span><span class="nc">RO</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;tx interrupt state register&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">rx_int_status</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="nc">M_CP_INT_STATUS</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bool</span><span class="p">(),</span><span class="w"> </span><span class="nc">RO</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;rx interrupt state register&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">frame_int_status</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">M_CP_INT_STATUS</span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="nc">Bool</span><span class="p">(),</span><span class="w"> </span><span class="nc">RO</span><span class="p">,</span><span class="w"> </span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;frame interrupt state register&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="n">rx_int_raw</span><span class="p">.</span><span class="n">setWhen</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">rx_done</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">tx_int_raw</span><span class="p">.</span><span class="n">setWhen</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">tx_done</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">frame_int_raw</span><span class="p">.</span><span class="n">setWhen</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">frame_end</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="n">rx_int_status</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">rx_int_raw</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">rx_int_force</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">rx_int_mask</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">tx_int_status</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">tx_int_raw</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">rx_int_force</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">rx_int_mask</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">frame_int_status</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">frame_int_raw</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">frame_int_force</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">frame_int_mask</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="n">io</span><span class="p">.</span><span class="n">interrupt</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rx_int_status</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">tx_int_status</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">frame_int_status</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这是一项非常乏味和重复的工作, 更好的方法是使用factory范式为每个信号自动生成文档。</p>
<p>现在中断库可以做到这一点。写中断的简单方法:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">EasyInterrupt</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">apb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">Apb3</span><span class="p">(</span><span class="nc">Apb3Config</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">busif</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BusInterface</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="p">,(</span><span class="mh">0x000</span><span class="p">,</span><span class="mi">1</span><span class="w"> </span><span class="nc">KiB</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">regPre</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;AP&quot;</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">busif</span><span class="p">.</span><span class="n">interruptFactory</span><span class="p">(</span><span class="s">&quot;T&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">e</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">CHeaderGenerator</span><span class="p">(</span><span class="s">&quot;intrreg&quot;</span><span class="p">,</span><span class="s">&quot;AP&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">HtmlGenerator</span><span class="p">(</span><span class="s">&quot;intrreg&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Interupt Example&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">JsonGenerator</span><span class="p">(</span><span class="s">&quot;intrreg&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">RalfGenerator</span><span class="p">(</span><span class="s">&quot;intrreg&quot;</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><img alt="easy-intr" src="_images/easy-intr.png" /></p>
</section>
</section>
<section id="interrupt-design-spec">
<h2>中断设计规范(Interrupt Design Spec)<a class="headerlink" href="#interrupt-design-spec" title="Permalink to this heading"></a></h2>
<section id="ip-ip-level-interrupt-factory">
<h3>一、IP级中断库(IP level interrupt Factory)<a class="headerlink" href="#ip-ip-level-interrupt-factory" title="Permalink to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">寄存器</th>
<th style="text-align: center;">接入类型</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">RAW</td>
<td style="text-align: center;">W1C</td>
<td style="text-align: center;">整形原始(raw)寄存器, 通过int设置并且当总线写1时清空</td>
</tr>
<tr>
<td style="text-align: center;">FORCE</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">整形force寄存器, 用于SW类型的debug</td>
</tr>
<tr>
<td style="text-align: center;">MASK</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">整形mask寄存器, 1:关闭, 0：打开；默认为1</td>
</tr>
<tr>
<td style="text-align: center;">STATUS</td>
<td style="text-align: center;">RO</td>
<td style="text-align: center;">整形状态, 只读。<code>status = (raw            |  | force) &amp;&amp; ! mask</code></td>
</tr>
</tbody>
</table><p><img alt="RFMS" src="_images/RFMS.svg" /></p>
<p>Spinal使用:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">busif</span><span class="p">.</span><span class="n">interruptFactory</span><span class="p">(</span><span class="s">&quot;T&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">e</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="sys-level-interrupt-merge">
<h3>二、系统级中断合并(SYS level interrupt merge)<a class="headerlink" href="#sys-level-interrupt-merge" title="Permalink to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">寄存器</th>
<th style="text-align: center;">接入类型</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">MASK</td>
<td style="text-align: center;">RW</td>
<td style="text-align: center;">整形mask寄存器, 1:关闭; 0: 打开；默认1关闭</td>
</tr>
<tr>
<td style="text-align: center;">STATUS</td>
<td style="text-align: center;">RO</td>
<td style="text-align: center;">整形状态, RO, <code>status = int_level &amp;&amp; ! mask</code></td>
</tr>
</tbody>
</table><p><img alt="MS" src="_images/MS.svg" /></p>
<p>Spinal使用：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">busif</span><span class="p">.</span><span class="n">interruptLevelFactory</span><span class="p">(</span><span class="s">&quot;T&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sys_int0</span><span class="p">,</span><span class="w"> </span><span class="n">sys_int1</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="spinal-spinal-factory">
<h3>三、Spinal库(Spinal Factory)<a class="headerlink" href="#spinal-spinal-factory" title="Permalink to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">总线接口方法</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>InterruptFactory(regNamePre: String, triggers: Bool*)</code></td>
<td style="text-align: center;">为脉冲事例创造RAW/FORCE/MASK/STATUS</td>
</tr>
<tr>
<td style="text-align: center;"><code>InterruptFactoryNoForce(regNamePre: String, triggers: Bool*)</code></td>
<td style="text-align: center;">为脉冲事例创造RAW/MASK/STATUS</td>
</tr>
<tr>
<td style="text-align: center;"><code>InterruptFactory(regNamePre: String, triggers: Bool*)</code></td>
<td style="text-align: center;">为level_int合并创建MASK/STATUS</td>
</tr>
<tr>
<td style="text-align: center;"><code>InterruptFactoryAt(addrOffset: Int, regNamePre: String, triggers: Bool*)</code></td>
<td style="text-align: center;">为在<code>adderOffset</code>的脉冲事例创建RAW/FORCE/MASK/STATUS</td>
</tr>
<tr>
<td style="text-align: center;"><code>InterruptFactoryNoForceAt(addrOffset: Int, regNamePre: String, triggers: Bool*)</code></td>
<td style="text-align: center;">为在<code>adderOffset</code>的脉冲事例创建RAW/MASK/STATUS</td>
</tr>
<tr>
<td style="text-align: center;"><code>InterruptFactoryAt(addrOffset: Int, regNamePre: String, triggers: Bool*)</code></td>
<td style="text-align: center;">为在<code>adderOffset</code>的level_int合并MASK/STATUS</td>
</tr>
</tbody>
</table></section>
<section id="example">
<h3>四、例子(Example)<a class="headerlink" href="#example" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RegFileIntrExample</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="kd">val</span><span class="w"> </span><span class="n">apb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">Apb3</span><span class="p">(</span><span class="nc">Apb3Config</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">)))</span><span class="w"></span>
<span class="w">     </span><span class="kd">val</span><span class="w"> </span><span class="n">int_pulse0</span><span class="p">,</span><span class="w"> </span><span class="n">int_pulse1</span><span class="p">,</span><span class="w"> </span><span class="n">int_pulse2</span><span class="p">,</span><span class="w"> </span><span class="n">int_pulse3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">     </span><span class="kd">val</span><span class="w"> </span><span class="n">int_level0</span><span class="p">,</span><span class="w"> </span><span class="n">int_level1</span><span class="p">,</span><span class="w"> </span><span class="n">int_level2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">     </span><span class="kd">val</span><span class="w"> </span><span class="n">sys_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">     </span><span class="kd">val</span><span class="w"> </span><span class="n">gpio_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">busif</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BusInterface</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="p">,</span><span class="w">  </span><span class="p">(</span><span class="mh">0x000</span><span class="p">,</span><span class="mi">1</span><span class="w"> </span><span class="nc">KiB</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">regPre</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;AP&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">io</span><span class="p">.</span><span class="n">sys_int</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">interruptFactory</span><span class="p">(</span><span class="s">&quot;SYS&quot;</span><span class="p">,</span><span class="n">io</span><span class="p">.</span><span class="n">int_pulse0</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">int_pulse1</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">int_pulse2</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">int_pulse3</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">io</span><span class="p">.</span><span class="n">gpio_int</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">interruptLevelFactory</span><span class="p">(</span><span class="s">&quot;GPIO&quot;</span><span class="p">,</span><span class="n">io</span><span class="p">.</span><span class="n">int_level0</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">int_level1</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">int_level2</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">sys_int</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="k">def</span><span class="w"> </span><span class="nf">genDoc</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">CHeaderGenerator</span><span class="p">(</span><span class="s">&quot;intrreg&quot;</span><span class="p">,</span><span class="s">&quot;Intr&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">     </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">HtmlGenerator</span><span class="p">(</span><span class="s">&quot;intrreg&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Interupt Example&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">     </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">JsonGenerator</span><span class="p">(</span><span class="s">&quot;intrreg&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">     </span><span class="bp">this</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="bp">this</span><span class="p">.</span><span class="n">genDoc</span><span class="p">()</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><img alt="intc" src="_images/intc.jpeg" /></p>
</section>
<section id="developers-area">
<h3>五、开发区域(Developers Area)<a class="headerlink" href="#developers-area" title="Permalink to this heading"></a></h3>
<p>用户可以通过扩展BusIfVistor Trait来添加用户的文档类型。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Latex</span><span class="p">(</span><span class="n">fileName</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">BusIfVisitor</span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>BusIfVistor提供对BusIf.RegInsts的访问来实现用户所需的：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// lib/src/main/scala/lib/bus/regif/BusIfVistor.scala</span>

<span class="k">trait</span><span class="w">  </span><span class="nc">BusIfVisitor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">begin</span><span class="p">(</span><span class="n">busDataWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">visit</span><span class="p">(</span><span class="n">descr</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">FifoDescr</span><span class="p">)</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">visit</span><span class="p">(</span><span class="n">descr</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">RegDescr</span><span class="p">)</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">end</span><span class="p">()</span><span class="w">                     </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="bus">
<h2>总线(bus)<a class="headerlink" href="#bus" title="Permalink to this heading"></a></h2>
<section id="ahb-lite3">
<h3>一、AHB-Lite3<a class="headerlink" href="#ahb-lite3" title="Permalink to this heading"></a></h3>
<ol>
<li><p>配置与实例化(Configuration and instanciation)</p>
<p>首先, 每次创建AHB-Lite3总线时, 都需要一个配置对象。这个配置对象是一个<code class="docutils literal notranslate"><span class="pre">AhbLite3Config</span></code>, 有以下参数:
|    参数名    | 类型  | 默认值 |         描述          |
| :———-: | :—: | :—-: | :——————-: |
| addressWidth |  Int  |        | HADDR的位宽(字节粒度) |
|  dataWidth   |  Int  |        | HWDATA和HRDATA的位宽  |</p>
<p>简而言之, 在SpinalHDL库中AHB-Lite3总线是如下定义的:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">AhbLite3</span><span class="p">(</span><span class="n">config</span><span class="p">:</span><span class="w"> </span><span class="nc">AhbLite3Config</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//  地址和控制</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HADDR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">addressWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HSEL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HREADY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HWRITE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HSIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HBURST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HPROT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HTRANS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HMASTLOCK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="c1">//  数据</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HWDATA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HRDATA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//  传输回答</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HREADYOUT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HRESP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="p">(</span><span class="nc">HADDR</span><span class="p">,</span><span class="nc">HWRITE</span><span class="p">,</span><span class="nc">HSIZE</span><span class="p">,</span><span class="nc">HBURST</span><span class="p">,</span><span class="nc">HPROT</span><span class="p">,</span><span class="nc">HTRANS</span><span class="p">,</span><span class="nc">HMASTLOCK</span><span class="p">,</span><span class="nc">HWDATA</span><span class="p">,</span><span class="nc">HREADY</span><span class="p">,</span><span class="nc">HSEL</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">in</span><span class="p">(</span><span class="nc">HREADYOUT</span><span class="p">,</span><span class="nc">HRESP</span><span class="p">,</span><span class="nc">HRDATA</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>简单的使用样例：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">ahbConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">AhbLite3Config</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">addressWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">dataWidth</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ahbX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">AhbLite3</span><span class="p">(</span><span class="n">ahbConfig</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ahbY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">AhbLite3</span><span class="p">(</span><span class="n">ahbConfig</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">ahbY</span><span class="p">.</span><span class="nc">HSEL</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="c1">//...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>变式(Variations)</p>
<p>有一个AhbLite3Master变体。唯一的区别是没有<code class="docutils literal notranslate"><span class="pre">HREADYOUT</span></code>信号。当互连线和从端口使用<code class="docutils literal notranslate"><span class="pre">AhbLite3</span></code>时, 这个变式应该只被master使用。</p>
</li>
</ol>
</section>
<section id="apb3">
<h3>二、Apb3<a class="headerlink" href="#apb3" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>AMBA3-APB总线通常用于连接低带宽外设。</p>
</li>
<li><p>配置和实例化</p>
<p>首先, 每次创建APB3总线时, 都需要一个配置对象。这个配置对象是<code class="docutils literal notranslate"><span class="pre">Apb3Config</span></code>, 有以下参数:
|    参数名     |  类型   | 默认值 |         描述          |
| :———–: | :—–: | :—-: | :——————-: |
| addressWidth  |   Int   |        | HADDR的位宽(字节粒度) |
|   dataWidth   |   Int   |        | PWDATA和PRDATA的位宽  |
|   selWidth    |   Int   |   1    |      PSEL的位宽       |
| useSlaveError | Boolean | false  |     指定PSLVERROR     |</p>
<p>简而言之, APB3总线在SpinalHDL库中定义的方式如下:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Apb3</span><span class="p">(</span><span class="n">config</span><span class="p">:</span><span class="w"> </span><span class="nc">Apb3Config</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PADDR</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">addressWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PSEL</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">selWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PENABLE</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PREADY</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PWRITE</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PWDATA</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PRDATA</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PSLVERROR</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">useSlaveError</span><span class="p">)</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="kc">null</span><span class="w"></span>
<span class="w">    </span><span class="c1">//...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>简单的使用样例：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">apbConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3Config</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">addressWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">dataWidth</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">apbX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3</span><span class="p">(</span><span class="n">apbConfig</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">apbY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3</span><span class="p">(</span><span class="n">apbConfig</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">apbY</span><span class="p">.</span><span class="nc">PENABLE</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="c1">//...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>函数和运算(Functions and operators)</p></li>
</ol>
<pre><code>| 参数名 | 返回  |            描述            |
| :----: | :---: | :------------------------: |
| X &gt;&gt; Y |       | 连接X到Y。Y的地址可以小于X |
| X &lt;&lt; Y |       |      做与&gt;&gt;相反的操作      |
</code></pre><p><h3>三、Axi4</h3></p>
<ol>
<li><p>简介</p>
<p>AXI4是ARM定义的高带宽总线</p>
</li>
<li><p>配置和实例化</p>
<p>首先, 每次创建AXI4总线时, 都需要一个配置对象。这个配置对象是一个<code class="docutils literal notranslate"><span class="pre">Axi4Config</span></code>, 它有以下参数:
注意:useXXX 指定总线是否有 XXX 信号。</p>
</li>
</ol>
<pre><code>|    参数名    |  类型   | 默认值 |
| :----------: | :-----: | :----: |
| addressWidth |   Int   |        |
|  dataWidth   |   Int   |        |
|   idWidth    |   Int   |        |
|  userWidth   |   Int   |        |
|    useld     | Boolean |  true  |
|  useRegion   | Boolean |  true  |
|   useBurst   | Boolean |  true  |
|   useLock    | Boolean |  true  |
|   useCache   | Boolean |  true  |
|   useSize    | Boolean |  true  |
|    useQos    | Boolean |  true  |
|    useLen    | Boolean |  true  |
|   useLast    | Boolean |  true  |
|   useResp    | Boolean |  true  |
|   useProt    | Boolean |  true  |
|   useStrb    | Boolean |  true  |
|   useUser    | Boolean | false  |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>简而言之, SpinalHDL库中定义AXI4总线的方式如下:
```Scala
case class Axi4(config: Axi4Config) extends Bundle with IMasterSlave{
    val aw = Stream(Axi4Aw(config))
    val w  = Stream(Axi4W(config))
    val b  = Stream(Axi4B(config))
    val ar = Stream(Axi4Ar(config))
    val r  = Stream(Axi4R(config))

    override def asMaster(): Unit = {
        master(ar,aw,w)
        slave(r,b)
    }
}
```
简单的使用样例：
```Scala
val axiConfig = Axi4Config(
    addressWidth = 32,
    dataWidth    = 32,
    idWidth      = 4
)
    val axiX = Axi4(axiConfig)
    val axiY = Axi4(axiConfig)

    when(axiY.aw.valid){
    //...
}
```
</pre></div>
</div>
<ol>
<li><p>变式</p>
<p>Axi4总线有三个变式：</p>
</li>
</ol>
<pre><code>|     类型      |                                                                                                      描述                                                                                                      |
| :-----------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| Axi4ReadOnly  |                                                                                               只有AR和R通道存在                                                                                                |
| Axi4WriteOnly |                                                                                              只有AW、W和B通道存在                                                                                              |
|  Axi4Shared   | 这种变式是该库的首创。&lt;br&gt;它使用4个通道, W, B,R, 还有一个名为AWR的新通道。&lt;br&gt;AWR通道可以用来传输AR和AW事务。要分离它们, 需要一个信号`write`。&lt;br&gt;这种Axi4Shared变体的优点是使用更少的面积, 尤其是在互连方面。 |
</code></pre><ol class="simple">
<li><p>函数与操作</p></li>
</ol>
<pre><code>|    参数名     |     返回      |                                     描述                                     |
| :-----------: | :-----------: | :--------------------------------------------------------------------------: |
|    X &gt;&gt; Y     |               | 连接X到Y。能够像AXI4规范中指定的那样推断默认值, 并以安全的方式调整一些宽度。 |
|    X &lt;&lt; Y     |               |                               做与&gt;&gt;相反的操作                               |
| X.toWriteOnly | Axi4WriteOnly |                      返回一个由X驱动的Axi4WriteOnly总线                      |
| X.toReadOnly  | Axi4ReadOnly  |                      返回一个由X驱动的Axi4ReadOnly总线                       |
</code></pre></section>
<section id="avalonmm">
<h3>四、AvalonMM<a class="headerlink" href="#avalonmm" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>AvalonMM总线非常适合FPGA。它非常灵活:</p>
<ul class="simple">
<li><p>与APB一样简单</p></li>
<li><p>在许多需要带宽的应用程序中, 比AHB表现更好, 因为AvalonMM有一种模式, 可以从命令中解耦读响应(减少延迟读延迟的影响)。</p></li>
<li><p>性能不如AXI, 但使用的面积少得多(读写命令使用相同的握手通道。主端口不需要存储挂起请求的地址以避免读/写风险)</p></li>
</ul>
</li>
<li><p>配置和实例化</p>
<p>AvalonMM Bundle有一个构造参数<code class="docutils literal notranslate"><span class="pre">AvalonMMConfig</span></code>。由于Avalon总线的灵活性, <code class="docutils literal notranslate"><span class="pre">AvalonMMConfig</span></code>可以作为许多配置元素。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">AvalonMMConfig</span><span class="p">(</span><span class="w"> </span><span class="n">addressWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">dataWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">burstCountWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useByteEnable</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useDebugAccess</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useRead</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useWrite</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useResponse</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useLock</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useWaitRequestn</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useReadDataValid</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useBurstCount</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="c1">//useEndOfPacket : Boolean,</span>

<span class="w">                       </span><span class="n">addressUnits</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">AddressUnits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">symbols</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">burstCountUnits</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">AddressUnits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">words</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">burstOnBurstBoundariesOnly</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">constantBurstBehavior</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">holdTime</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">linewrapBursts</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">maximumPendingReadTransactions</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">maximumPendingWriteTransactions</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// unlimited</span>
<span class="w">                       </span><span class="n">readLatency</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">readWaitTime</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">setupTime</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">writeWaitTime</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">                       </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>这样的配置类也有一些函数：
|       函数名       |      返回      |                   描述                   |
| :—————-: | :————: | :————————————–: |
| getReadOnlyConfig  | AvalonMMConfig | 返回一个类似的配置, 但禁用所有写入属性。 |
| getWriteOnlyConfig | AvalonMMConfig |   返回一个类似的配置, 但禁用所有读属性   |</p>
<p>这个配置对象也有一些函数来提供一些AvalonMMConfig模板:
|                     函数名                      |      返回      |                   描述                   |
| :———————————————: | :————: | :————————————–: |
|    fixed(addressWidth,dataWidth,readLatency)    | AvalonMMConfig |   返回一个具有固定读取时间的简单配置。   |
|        pipelined(addressWidth,dataWidth)        | AvalonMMConfig |        返回一个配置, 读取延迟可变        |
| bursted(addressWidth,dataWidth,burstCountWidth) | AvalonMMConfig | 返回一个具有可变延迟读取和突发功能的配置 |</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// 创建一个只写的AvalonMM配置, 具有突发能力和字节使能</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myAvalonConfig</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="nc">AvalonMMConfig</span><span class="p">.</span><span class="n">bursted</span><span class="p">(</span><span class="w"></span>
<span class="w">                    </span><span class="n">addressWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addressWidth</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">dataWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memDataWidth</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">burstCountWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">log2Up</span><span class="p">(</span><span class="n">burstSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="p">).</span><span class="n">copy</span><span class="p">(</span><span class="w"></span>
<span class="w">                    </span><span class="n">useByteEnable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">constantBurstBehavior</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">burstOnBurstBoundariesOnly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">                  </span><span class="p">).</span><span class="n">getWriteOnlyConfig</span><span class="w"></span>

<span class="c1">// 创建一个利用该配置的总线实例</span>
<span class="kd">val</span><span class="w"> </span><span class="n">bus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">AvalonMM</span><span class="p">(</span><span class="n">myAvalonConfig</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="com">
<h2>Com<a class="headerlink" href="#com" title="Permalink to this heading"></a></h2>
<section id="uart">
<h3>一、UART<a class="headerlink" href="#uart" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>可以使用UART协议来发出和接收RS232 / RS485帧。</p>
<p>有一个没有奇偶校验并拥有一个停止位的8位帧的例子:</p>
<p><img alt="uart" src="_images/uart.png" /></p>
</li>
<li><p>总线定义</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Uart</span><span class="p">()</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">txd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"> </span><span class="c1">// Used to emit frames</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">rxd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"> </span><span class="c1">// Used to receive frames</span>

<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="p">(</span><span class="n">txd</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">in</span><span class="p">(</span><span class="n">rxd</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>UartCtrl</p>
<p>库中实现了一个Uart控制器。这个控制器的特性是使用一个采样窗口来读取<code class="docutils literal notranslate"><span class="pre">rxd</span></code>引脚, 然后使用多数投票制来过滤它的值。
| IO口名 |  方向  |      类型      |                       描述                        |
| :—-: | :—-: | :————: | :———————————————–: |
| config |   in   | UartCtrlConfig | 用于设置控制器的时钟分频器/奇偶校验/停止/数据长度 |
| write  | slave  |  Stream[Bits]  |          用于请求进行帧交换传输的流端口           |
|  read  | master |   Flow[Bits]   |              用于接收解码帧的流端口               |
| write  | master |      Uart      |               与实际实现的连接接口                |</p>
<p>控制器可以通过一个<code class="docutils literal notranslate"><span class="pre">UartCtrlGenerics</span></code>配置对象实例化:
|       属性        | 类型  |                         描述                         |
| :—————: | :—: | :————————————————–: |
|   dataWidthMax    |  Int  |                    帧内的最大位数                    |
| clockDividerWidth |  Int  |                 内部时钟分频器的位宽                 |
|  preSamplingSize  |  Int  |   指定有多少samplingTick在一个UART波特的起始处下降   |
|   samplingSize    |  Int  | 指定有多少samplingTick用于采样UART波特中段的<code class="docutils literal notranslate"><span class="pre">rxd</span></code>值  |
| postSamplingSize  |  Int  | 指定在一个UART波特值的末尾有多少个samplingTick被丢弃 |</p>
</li>
</ol>
</section>
<section id="usb">
<h3>二、USB设备<a class="headerlink" href="#usb" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>SpinalHDL库中有一个USB设备控制器。在以下几个要点中, 它可以设置为:</p>
<ul class="simple">
<li><p>它允许CPU配置和管理端点</p></li>
<li><p>存储端点状态和事务描述符的内部RAM</p></li>
<li><p>多达16个端点(几乎没有额外开销)</p></li>
<li><p>支持USB主机全速运行(12Mbps)</p></li>
<li><p>在linux上使用自己的驱动程序进行测试(https://github.com/SpinalHDL/linux/blob/dev/drivers/usb/gadget/udc/spinal_udc.c)</p></li>
<li><p>用于配置的Bmb内存接口</p></li>
<li><p>内部需要一个频率是12Mhz的倍数的时钟, 至少为48Mhz</p></li>
<li><p>控制器频率不受限制</p></li>
<li><p>不需要外部phy</p></li>
</ul>
<p>Linux小工具测试和功能:</p>
<ul class="simple">
<li><p>串行连接</p></li>
<li><p>以太网连接</p></li>
<li><p>大容量存储(在ArtyA7 linux上达到8mbps)</p></li>
</ul>
<p>部署：</p>
<ul class="simple">
<li><p>https://github.com/SpinalHDL/SaxonSoc/tree/dev-0.3/bsp/digilent/ArtyA7SmpLinux</p></li>
<li><p>https://github.com/SpinalHDL/SaxonSoc/tree/dev-0.3/bsp/radiona/ulx3s/smp</p></li>
</ul>
</li>
<li><p>架构(Architecture)</p>
<p>控制器由以下部分组成：</p>
<ul class="simple">
<li><p>少数控制寄存器</p></li>
<li><p>一个用来存储端点状态的内部RAM, 一个传输描述符合端点0配置数据。</p></li>
</ul>
<p>每个端点的描述符链表是为了处理USB的出入任务和数据。</p>
<p>端点0也会像其他端点一样处理出入USB的交换任务但也会有一些额外的硬件来处理SETUP(设置)任务：</p>
<ul class="simple">
<li><p>它的链表在每个设置任务上被清除</p></li>
<li><p>设置任务的数据存储在一个固定的位置(SETUP_DATA)</p></li>
<li><p>它对设置任务有一个特定的中断标志</p></li>
</ul>
</li>
<li><p>寄存器(Registers)</p>
<p>注意, 控制器的所有寄存器和内存只能以32位的字访问, 不支持字节访问。</p>
<ul class="simple">
<li><p>帧FRAME (0xFF00)</p></li>
</ul>
</li>
</ol>
<pre><code>    |    名称    | 类型  | 比特  |      描述       |
    | :--------: | :---: | :---: | :-------------: |
    | usbFrameId |  RO   | 31-0  | 目前的usb帧的id |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">地址ADDRESS</span> <span class="p">(</span><span class="mh">0xFF04</span><span class="p">)</span>
</pre></div>
</div>
<pre><code>    |  名称   | 类型  | 比特  |                                   描述                                    |
    | :-----: | :---: | :---: | :-----------------------------------------------------------------------: |
    | address |  WO   |  6-0  | 该USB设备只会被特定地址的令牌(token)所控制。其字段会被usb重置任务自动清除 |
    | enable  |  WO   |   8   |                         如果设置, 启用USB地址过滤                         |
    | trigger |  WO   |   9   |        设置下一个EP0 IN令牌使能(见上文)。在任何EP0完成后由硬件清除        |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    这里的想法是保持整个寄存器清空, 直到EP0上接收到USB SET_ADDRESS设置包。此时, 用户可以设置地址和触发器字段, 然后向EP0提供IN零长度描述符, 以结束SET_ADDRESS序列。然后, 控制器将在描述符完成时自动打开地址过滤。

- 中断INTERRUPT (0xFF08)

    这个寄存器的所有位都可以通过写入“1”来清除。
    |    名称    | 类型  | 比特  |           描述            |
    | :--------: | :---: | :---: | :-----------------------: |
    | endpoints  |  RC   | 15-0  |   当端点产生中断时拉高    |
    |   reset    |  RC   |  16   |    当USB复位发生时拉高    |
    |  ep0Setup  |  RC   |  17   | 当端点0收到配置请求时拉高 |
    |  suspend   |  RC   |  18   |     当端点悬挂时拉高      |
    |   resume   |  RC   |  19   |     当端点恢复时拉高      |
    | disconnect |  RC   |  20   |   当端点连接中断时拉高    |

- Halt (0xFF0C)

    这个寄存器允许在休眠状态下放置一个端点, 以确保CPU操作的原子性, 允许对端点寄存器和描述符进行读/修改/写操作。如果给定的端点是由usb主机寻址的, 外围设备将返回NAK。
</pre></div>
</div>
<pre><code>    |       名称       | 类型  | 比特  |                          描述                          |
    | :--------------: | :---: | :---: | :----------------------------------------------------: |
    |    endpointId    |  WO   |  3-0  |                 用户想要休眠的目标端点                 |
    |      enable      |  WO   |   4   |                                                        |
    | effective enable |  RO   |   5   | 在设置了使能后, 需要等待硬件本身设置该位, 以确保原子性 |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">配置CONFIG</span> <span class="p">(</span><span class="mh">0xFF10</span><span class="p">)</span>
</pre></div>
</div>
<pre><code>    |         名称         | 类型  | 比特  |                 描述                 |
    | :------------------: | :---: | :---: | :----------------------------------: |
    |      pullupSet       |  SO   |   0   | 写入' 1 '来启用dp引脚上的USB设备上拉 |
    |     pullupClear      |  SO   |   1   |                                      |
    |  interruptEnableSet  |  SO   |   2   |    写“1”, 让现在和未来的中断发生     |
    | interruptEnableClear |  SO   |   3   |                                      |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">INFO</span> <span class="p">(</span><span class="mh">0xFF20</span><span class="p">)</span>
</pre></div>
</div>
<pre><code>    |  名称   | 类型  | 比特  |            描述            |
    | :-----: | :---: | :---: | :------------------------: |
    | ramSize |  RO   |  3-0  | 内部ram将有(1 &lt;&lt; this)字节 |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>- 端点 ENDPOINTS (0x0000 - 0x003F)

    端点状态存储在内部ram的开头, 每个有32位字。
    |     名称      | 类型  | 比特  |                               描述                                |
    | :-----------: | :---: | :---: | :---------------------------------------------------------------: |
    |    enable     |  RW   |   0   |             若不设置, 则该端点忽略所有的流量(traffic)             |
    |     stall     |  RW   |   1   |                 若设置了, 端点将始终返回STALL状态                 |
    |     nack      |  RW   |   2   |                 若设置了, 端点将始终返回NACK状态                  |
    |   dataPhase   |  RW   |   3   |  指定使用的IO数据PID。&#39; 0 &#39; = &gt; DATA0。这个字段也由控制器更新。   |
    |     head      |  RW   | 15-4  | 指定当前描述符头部(链表)0 =&gt; empty list, byte address = this &lt;&lt; 4 |
    |  isochronous  |  RW   |  16   | 指定当前描述符头部(链表)0 =&gt; empty list, byte address = this &lt;&lt; 4 |
    | maxPacketSize |  RW   | 31-22 |                                                                   |

    为了获得一个端点响应需要：设置其使能标志位为1.

    还有其他一些例子:要么用户有停滞或纳标记集,因此,控制器总是有相应的响应；要么EP0设置请求,控制器不会使用描述符,但将数据写入SETUP_DATA寄存器和ACK；要么用户有一个空链表(head==0)并响应NACK；要么用户至少有一个描述符由头部指出,在这种情况下将执行和ACK。

- SETUP_DATA (0x0040 - 0x0047)

    当端点0接收SETUP任务时, 该任务的数据将存储在该位置
</pre></div>
</div>
<ol>
<li><p>描述符(Descriptors)</p>
<p>描述符允许指定端点需要如何处理IO传输任务的数据阶段。它们存储在内部ram中, 可以通过它们的链表链接在一起, 并且需要在16字节的边界上对齐.</p>
</li>
</ol>
<pre><code>|       名称        |  字   | 比特  |                                                               描述                                                                |
| :---------------: | :---: | :---: | :-------------------------------------------------------------------------------------------------------------------------------: |
|      offset       |   0   | 15-0  |                                                  指定当前传输进度(以字节为单位)                                                   |
|       code        |   0   | 19-16 |                                                0xF =&gt; in progress, 0x0 =&gt; success                                                 |
|       next        |   1   | 15-4  |                                      指定下一个传输符 0 =&gt; nothing, byte address = this &lt;&lt; 4                                      |
|      length       |   1   | 31-16 |                                                      为数据字段分配的字节数                                                       |
|     direction     |   2   |  16   |                                                       ‘0’ =&gt; OUT, ‘1’ =&gt; IN                                                       |
|     interrupt     |   2   |  17   |                                            如果设置了, 则描述符的完成将生成一个中断。                                             |
| completionOnFull  |   2   |  18   | 通常, 描述符补全只发生在USB传输小于maxPacketSize时。但是如果设置了这个字段, 那么当描述符被填满时也被认为事件已完成。(抵消= =长度) |
| data1OnCompletion |   2   |  19   |                                                     强制端点dataphase为DATA1                                                      |
|       data        |  ...  |  ...  |                                                                                                                                   |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>注意, 如果控制器接收到一个帧, 其中IO不匹配描述符IO, 该帧将被忽略。

另外, 要初始化描述符, CPU应该将代码字段设置为0xF.
</pre></div>
</div>
<ol>
<li><p>使用(usage)</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">bus</span><span class="p">.</span><span class="nn">bmb</span><span class="p">.</span><span class="nc">BmbParameter</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">com</span><span class="p">.</span><span class="nn">usb</span><span class="p">.</span><span class="nn">phy</span><span class="p">.</span><span class="nc">UsbDevicePhyNative</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">com</span><span class="p">.</span><span class="nn">usb</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="nc">UsbLsFsPhyAbstractIoAgent</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">com</span><span class="p">.</span><span class="nn">usb</span><span class="p">.</span><span class="nn">udc</span><span class="p">.{</span><span class="nc">UsbDeviceCtrl</span><span class="p">,</span><span class="w"> </span><span class="nc">UsbDeviceCtrlParameter</span><span class="p">}</span>


<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">UsbDeviceTop</span><span class="p">()</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ctrlCd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">external</span><span class="p">(</span><span class="s">&quot;ctrlCd&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">frequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">FixedFrequency</span><span class="p">(</span><span class="mi">100</span><span class="w"> </span><span class="nc">MHz</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">phyCd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">external</span><span class="p">(</span><span class="s">&quot;phyCd&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">frequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">FixedFrequency</span><span class="p">(</span><span class="mi">48</span><span class="w"> </span><span class="nc">MHz</span><span class="p">))</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ctrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctrlCd</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">UsbDeviceCtrl</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UsbDeviceCtrlParameter</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">addressWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">14</span><span class="w"></span>
<span class="w">        </span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">bmbParameter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BmbParameter</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">addressWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UsbDeviceCtrl</span><span class="p">.</span><span class="n">ctrlAddressWidth</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">dataWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">sourceWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">contextWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">lengthWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">phy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">phyCd</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">UsbDevicePhyNative</span><span class="p">(</span><span class="n">sim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"></span>
<span class="n">ctrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">cc</span><span class="p">(</span><span class="n">ctrlCd</span><span class="p">,</span><span class="w"> </span><span class="n">phyCd</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">phy</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">ctrl</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">bmb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">toIo</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">usb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">phy</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">usb</span><span class="p">.</span><span class="n">toIo</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">power</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">phy</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">toIo</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">pullup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">phy</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pullup</span><span class="p">.</span><span class="n">toIo</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">interrupts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">toIo</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">object</span><span class="w"> </span><span class="nc">UsbDeviceGen</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">App</span><span class="p">{</span><span class="w"></span>
<span class="nc">SpinalVerilog</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">UsbDeviceTop</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="id87">
<h2>IO口<a class="headerlink" href="#id87" title="Permalink to this heading"></a></h2>
<section id="readableopendrain">
<h3>一、ReadableOpenDrain<a class="headerlink" href="#readableopendrain" title="Permalink to this heading"></a></h3>
<p>ReadableOpenDrain包的定义如下:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ReadableOpenDrain</span><span class="p">[</span><span class="nc">T</span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">dataType</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">HardType</span><span class="p">[</span><span class="nc">T</span><span class="p">])</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="n">read</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dataType</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">out</span><span class="p">(</span><span class="n">write</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">in</span><span class="p">(</span><span class="n">read</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>然后, 作为主端口, 可以使用<code class="docutils literal notranslate"><span class="pre">read</span></code>信号读取外部值, 并使用<code class="docutils literal notranslate"><span class="pre">write</span></code>信号设置用户希望在输出上驱动的值。</p>
<p>这里有一个使用例子:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">dataBus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">ReadableOpenDrain</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x12345678</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">read</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">42</span><span class="p">){</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="tristate">
<h3>二、三态(Tristate)<a class="headerlink" href="#tristate" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>三态信号在很多情况下处理起来都很奇怪:</p>
<ul class="simple">
<li><p>它们不满足真正的数字性</p></li>
<li><p>除了IO, 它们不用于数字设计</p></li>
<li><p>三态概念不适合SpinalHDL内部图。</p></li>
</ul>
<p>SpinalHDL为三态信号提供了两种不同的抽象。<code class="docutils literal notranslate"><span class="pre">TriState</span></code>包和<code class="docutils literal notranslate"><span class="pre">analog</span> <span class="pre">and</span> <span class="pre">inout</span></code>信号。两者都有不同的目的:</p>
<ul class="simple">
<li><p>三态应用于大多数目的, 特别是在设计中。包包含一个额外的信号来传递当前的方向。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">analog</span> <span class="pre">and</span> <span class="pre">inout</span></code>应该用于设备边界上的驱动程序和其他一些特殊情况。请参阅参考文档页了解更多细节。</p></li>
</ul>
<p>如上所述, 推荐的方法是在设计中使用<code class="docutils literal notranslate"><span class="pre">TriState</span></code>。然后在顶层文件中, 将<code class="docutils literal notranslate"><span class="pre">TriState</span></code>包分配给一个<code class="docutils literal notranslate"><span class="pre">analog</span> <span class="pre">and</span> <span class="pre">inout</span></code>口, 以获得综合工具来推断正确的I/O驱动程序。这可以通过InOutWrapper自动完成, 也可以根据需要手动完成。</p>
</li>
<li><p>三态</p>
<p><code class="docutils literal notranslate"><span class="pre">TriState</span></code>定义如下;</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">TriState</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">dataType</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">HardType</span><span class="p">[</span><span class="nc">T</span><span class="p">])</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">read</span><span class="p">,</span><span class="n">write</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dataType</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">writeEnable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="p">(</span><span class="n">write</span><span class="p">,</span><span class="n">writeEnable</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">in</span><span class="p">(</span><span class="n">read</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>主端口可以使用<code class="docutils literal notranslate"><span class="pre">read</span></code>信号来读取外部值, <code class="docutils literal notranslate"><span class="pre">writeEnable</span></code>来启用输出, 最后使用<code class="docutils literal notranslate"><span class="pre">write</span></code>来设置输出驱动的值。</p>
<p>使用样例：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">dataBus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">TriState</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">writeEnable</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x12345678</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">read</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">42</span><span class="p">){</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>三态阵列(TriStateArray)</p>
<p>在某些情况下, 用户需要控制每个单独的引脚的输出启用(就像GPIO一样)。在这种情况下, 可以使用TriStateArray包。</p>
<p>其定义如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">TriStateArray</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">BitCount</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">read</span><span class="p">,</span><span class="n">write</span><span class="p">,</span><span class="n">writeEnable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">width</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="p">(</span><span class="n">write</span><span class="p">,</span><span class="n">writeEnable</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">in</span><span class="p">(</span><span class="n">read</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>它与TriState包相同, 不同的是<code class="docutils literal notranslate"><span class="pre">writeEnable</span></code>是一个Bits来控制每个输出缓冲区。</p>
<p>使用样例：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">dataBus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">TriStateArray</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">writeEnable</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x87654321</span><span class="w"></span>
<span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x12345678</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">read</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">42</span><span class="p">){</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="graphics">
<h2>图形(Graphics)<a class="headerlink" href="#graphics" title="Permalink to this heading"></a></h2>
<section id="id88">
<h3>一、颜色<a class="headerlink" href="#id88" title="Permalink to this heading"></a></h3>
<ol>
<li><p>RGB</p>
<p>用户可以使用Rgb包在硬件中建模颜色。这个Rgb包使用RgbConfig类作为参数并指定每个通道的比特数:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">RgbConfig</span><span class="p">(</span><span class="n">rWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="n">gWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="n">bWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">getWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rWidth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">gWidth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bWidth</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Rgb</span><span class="p">(</span><span class="n">c</span><span class="p">:</span><span class="w"> </span><span class="nc">RgbConfig</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">rWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">gWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">bWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这些类可以按如下使用：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RgbConfig</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Rgb</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="w"></span>
<span class="n">color</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">31</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="vga">
<h3>二、VGA<a class="headerlink" href="#vga" title="Permalink to this heading"></a></h3>
<ol>
<li><p>VGA总线</p>
<p>VGA总线通过VGA包定义：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Vga</span><span class="w"> </span><span class="p">(</span><span class="n">rgbConfig</span><span class="p">:</span><span class="w"> </span><span class="nc">RgbConfig</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">vSync</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">hSync</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">colorEn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w">  </span><span class="c1">//High when the frame is inside the color area</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Rgb</span><span class="p">(</span><span class="n">rgbConfig</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">asOutput</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>VGA时序(timings)</p>
<p>VGA时序可以通过使用VgaTimings包在硬件中建模:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">VgaTimingsHV</span><span class="p">(</span><span class="n">timingsWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">colorStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">timingsWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">colorEnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">timingsWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">syncStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">timingsWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">syncEnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">timingsWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">VgaTimings</span><span class="p">(</span><span class="n">timingsWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">VgaTimingsHV</span><span class="p">(</span><span class="n">timingsWidth</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">VgaTimingsHV</span><span class="p">(</span><span class="n">timingsWidth</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">setAs_h640_v480_r60</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">driveFrom</span><span class="p">(</span><span class="n">busCtrl</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">BusSlaveFactory</span><span class="p">,</span><span class="n">baseAddress</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>VGA控制器</p>
<p>VGA控制器的定义如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">VgaCtrl</span><span class="p">(</span><span class="n">rgbConfig</span><span class="p">:</span><span class="w"> </span><span class="nc">RgbConfig</span><span class="p">,</span><span class="w"> </span><span class="n">timingsWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">softReset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">timings</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nc">VgaTimings</span><span class="p">(</span><span class="n">timingsWidth</span><span class="p">))</span><span class="w"></span>

<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">frameStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">pixels</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="w"> </span><span class="p">(</span><span class="nc">Rgb</span><span class="p">(</span><span class="n">rgbConfig</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">vga</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">Vga</span><span class="p">(</span><span class="n">rgbConfig</span><span class="p">))</span><span class="w"></span>

<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">error</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">frameStart</span></code>是一个信号, 在每一帧的开始脉冲一个周期。</p>
<p><code class="docutils literal notranslate"><span class="pre">pixels</span></code>是一种色彩流, 用于在需要时提供给VGA接口。</p>
<p>当需要对像素进行传输但没有对象时, <code class="docutils literal notranslate"><span class="pre">error</span></code>会拉高。</p>
</li>
</ol>
</section>
</section>
<section id="eda">
<h2>自动设计工具(EDA)<a class="headerlink" href="#eda" title="Permalink to this heading"></a></h2>
<section id="qsysify">
<h3>一、QSysify<a class="headerlink" href="#qsysify" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>QSysify是一个可以从SpinalHDL组件通过分析其IO定义生成QSys IP (tcl脚本)的工具。目前实现了以下接口特性:</p>
<ul class="simple">
<li><p>Master/Slave AvalonMM</p></li>
<li><p>Master/Slave APB3</p></li>
<li><p>时钟域输入</p></li>
<li><p>复位输出</p></li>
<li><p>中断输入</p></li>
<li><p>导线</p></li>
</ul>
</li>
<li><p>例子</p>
<p>以UART控制器为例;</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">AvalonMMUartCtrl</span><span class="p">(...)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">bus</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">slave</span><span class="p">(</span><span class="nc">AvalonMM</span><span class="p">(</span><span class="nc">AvalonMMUartCtrl</span><span class="p">.</span><span class="n">getAvalonMMConfig</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">uart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">Uart</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">//...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>下面的<code class="docutils literal notranslate"><span class="pre">main</span></code>将使用io.bus和io.uart生成Verilog和QSys TCL脚本:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">AvalonMMUartCtrl</span><span class="p">{</span><span class="w"></span>
<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//生成verilog</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">toplevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SpinalVerilog</span><span class="p">(</span><span class="nc">AvalonMMUartCtrl</span><span class="p">(</span><span class="nc">UartCtrlMemoryMappedConfig</span><span class="p">(...))).</span><span class="n">toplevel</span><span class="w"></span>

<span class="w">    </span><span class="c1">//对avalon总线添加标志位并指明时钟域</span>
<span class="w">    </span><span class="n">toplevel</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">bus</span><span class="w"> </span><span class="n">addTag</span><span class="p">(</span><span class="nc">ClockDomainTag</span><span class="p">(</span><span class="n">toplevel</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">))</span><span class="w"></span>

<span class="w">    </span><span class="c1">//利用tcl脚本生成QSysIP</span>
<span class="w">    </span><span class="nc">QSysify</span><span class="p">(</span><span class="n">toplevel</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>标志(tags)</p>
<p>因为QSys需要SpinalHDL硬件规范中没有指定的一些信息, 所以应该向接口添加一些标记:</p>
<ul class="simple">
<li><p>AvalonMM / APB3</p></li>
</ul>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">io</span><span class="p">.</span><span class="n">bus</span><span class="w"> </span><span class="n">addTag</span><span class="p">(</span><span class="nc">ClockDomainTag</span><span class="p">(</span><span class="n">busClockDomain</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>中断输入(Interrupt input)</p></li>
</ul>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">io</span><span class="p">.</span><span class="n">interrupt</span><span class="w"> </span><span class="n">addTag</span><span class="p">(</span><span class="nc">InterruptReceiverTag</span><span class="p">(</span><span class="n">relatedMemoryInterfacei</span><span class="p">,</span><span class="w"> </span><span class="n">interruptClockDomain</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>重置输出(Reset output)</p></li>
</ul>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">io</span><span class="p">.</span><span class="n">resetOutput</span><span class="w"> </span><span class="n">addTag</span><span class="p">(</span><span class="nc">ResetEmitterTag</span><span class="p">(</span><span class="n">resetOutputClockDomain</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>添加新的接口支持(Adding new interface support)</p>
<p>基本上, QSysify工具可以通过一个接口<code class="docutils literal notranslate"><span class="pre">emitter</span></code>列表来设置。</p>
<p>用户可以通过创建一个扩展QSysifyInterfaceEmiter的新类来创建自己的发射器。</p>
</li>
</ol>
</section>
<section id="quartusflow">
<h3>二、QuartusFlow<a class="headerlink" href="#quartusflow" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>编译流是altera定义的命令序列, 它使用命令行可执行文件的组合。完整的编译流按顺序启动所有编译器模块, 以综合、匹配、分析最终的时序, 并生成编程文件。</p>
<p>这个文件中的工具可以帮助消除冗余的Quartus GUI。</p>
</li>
<li><p>对于单个rtl文件</p>
<p>对象<code class="docutils literal notranslate"><span class="pre">spinal.lib.eda.altera.QuartusFlow</span></code>可以自动报告单个rtl文件的使用面积和最大频率。</p>
<p>例如:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">report</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">QuartusFlow</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">quartusPath</span><span class="o">=</span><span class="s">&quot;/eda/intelFPGA_lite/17.0/quartus/bin/&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">workspacePath</span><span class="o">=</span><span class="s">&quot;/home/spinalvm/tmp&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">toplevelPath</span><span class="o">=</span><span class="s">&quot;TopLevel.vhd&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">family</span><span class="o">=</span><span class="s">&quot;Cyclone V&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">device</span><span class="o">=</span><span class="s">&quot;5CSEMA5F31C6&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">frequencyTarget</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nc">MHz</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="n">println</span><span class="p">(</span><span class="n">report</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>上面的代码将使用<code class="docutils literal notranslate"><span class="pre">topllevel.vhd</span></code>创建一个新的Quartus项目。</p>
<blockquote>
<div><p><strong>警告：该操作将移除<code class="docutils literal notranslate"><span class="pre">workspacePath</span></code>文件夹</strong></p>
</div></blockquote>
<blockquote>
<div><p><strong>注意：<code class="docutils literal notranslate"><span class="pre">family</span></code>和<code class="docutils literal notranslate"><span class="pre">devbice</span></code>值直接作为参数传递给Quartus CLI。请检查Quartus文档, 以确定要在项目中使用的正确值。</strong></p>
</div></blockquote>
<p>小贴士：</p>
<p>为了测试含有多个引脚的组件, 请将它们设置为<code class="docutils literal notranslate"><span class="pre">VIRTUAL_PIN</span></code>。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">miaou</span><span class="p">:</span><span class="w"> </span><span class="nc">Vec</span><span class="p">[</span><span class="nc">Flow</span><span class="p">[</span><span class="nc">Bool</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="n">master</span><span class="p">(</span><span class="nc">Flow</span><span class="p">(</span><span class="nc">Bool</span><span class="p">())),</span><span class="w"> </span><span class="mi">666</span><span class="p">)</span><span class="w"></span>
<span class="n">miaou</span><span class="p">.</span><span class="n">addAttribute</span><span class="p">(</span><span class="s">&quot;altera_attribute&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;-name VIRTUAL_PIN ON&quot;</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="for-an-existing-project">
<h3>三、对于一个已存在的项目(For an existing project)<a class="headerlink" href="#for-an-existing-project" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spinal.lib.eda.altera.QuartusProject</span></code>类可以自动查找现有项目中的配置文件。它们用于对设备进行编译和编程。</p>
<p>例如：
指定包含项目文件(如.qpf和.cdf)的路径。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">prj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">QuartusProject</span><span class="p">(</span><span class="w"></span>
<span class="w">   </span><span class="n">quartusPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;F:/intelFPGA_lite/20.1/quartus/bin64/&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">workspacePath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;G:/&quot;</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="n">prj</span><span class="p">.</span><span class="n">compile</span><span class="p">()</span><span class="w"></span>
<span class="n">prj</span><span class="p">.</span><span class="n">program</span><span class="p">()</span><span class="w">  </span><span class="c1">// 自动寻找项目的链表描述文件</span>
</pre></div>
</div>
<blockquote>
<div><p><strong>重要：请记住调用<code class="docutils literal notranslate"><span class="pre">prj.program()</span></code>前保存项目的<code class="docutils literal notranslate"><span class="pre">.cdf</span></code>文件</strong></p>
</div></blockquote>
</section>
</section>
<section id="misc">
<h2>Misc<a class="headerlink" href="#misc" title="Permalink to this heading"></a></h2>
<section id="plic">
<h3>一、Plic映射器<a class="headerlink" href="#plic" title="Permalink to this heading"></a></h3>
<p>PLIC映射器定义了PLIC(平台级中断控制器)的寄存器生成和访问。</p>
<ol>
<li><p><code class="docutils literal notranslate"><span class="pre">PlicMapper.apply</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">(bus:</span> <span class="pre">BusSlaveFactory,</span> <span class="pre">mapping:</span> <span class="pre">PlicMapping)(gateways</span> <span class="pre">:</span> <span class="pre">Seq[PlicGateway],</span> <span class="pre">targets</span> <span class="pre">:</span> <span class="pre">Seq[PlicTarget])</span></code></p>
<p>PlicMapper参数:</p>
<ul class="simple">
<li><p>总线:连接此控制的总线</p></li>
<li><p>映射:一个映射配置(参见上面)</p></li>
<li><p>网关:用于生成总线访问控制的PlicGateway(中断源)序列</p></li>
<li><p>目标: 生成总线访问控制的PlicTarget的序列(如:多核)</p></li>
</ul>
<p>它遵循由riscv给出的接口:https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic.adoc</p>
<p>到目前为止, 有两个内存映射可用:</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">PlicMapping.sifive</span></code></p>
<p>遵循SiFive PLIC映射(例如。E31核心复合手册), 基本上是一个成熟的PLIC</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">PlicMapping.light</span></code></p>
<p>这种映射以丢失一些可选特性为代价, 产生了一个更轻量级的PLIC:</p>
<ul class="simple">
<li><p>不读取中断的优先级</p></li>
<li><p>不读取中断的悬挂位(必须使用claim/complete机制)</p></li>
<li><p>不读取目标的阈值</p></li>
</ul>
<p>剩下的寄存器和逻辑被生成。</p>
</li>
</ol>
<div STYLE="page-break-after: always;"></div></section>
</section>
</section>
<section id="simulation">
<h1>仿真(Simulation)<a class="headerlink" href="#simulation" title="Permalink to this heading"></a></h1>
<section id="id89">
<h2>介绍(Introduction)<a class="headerlink" href="#id89" title="Permalink to this heading"></a></h2>
<p>和往常一样, 你可以用标准仿真工具对SpinalHDL生成的VHDL/Verilog仿真。然而, 自1.0.0版本后, SpinalHDL在Scala中集成了可以直接书写testbenches并测试硬件的API。这个API有能力读写DUT信号, 分叉和汇合仿真进程, 在条件满足之前休眠并等待。因此, 使用SpinalHDL的仿真API很容易就可以用最常见的Scala单元测试(unit-test)框架集成到testbenches里。</p>
<p>为了能对用户定义的模块仿真, SpinalHDL用外置的HDL仿真器作为后端。当前, 可以支持一下仿真器：</p>
<ul class="simple">
<li><p>Verilator</p></li>
<li><p>GHDL(测试版, SpinalHDL 1.4.1版本后支持)</p></li>
<li><p>Icarus Verilog(测试版, SpinalHDL 1.4.1版本后支持)</p></li>
<li><p>VCS(测试版, SpinalHDL 1.7.版本后支持)</p></li>
</ul>
<p>有了外置HDL仿真器就可以不用增加SpinalHDL代码库的复杂度直接测试生成的HDL源代码。</p>
<section id="spinalhdlverilator-how-spinalhdl-simulates-the-hardware-with-verilator-backend">
<h3>一、SpinalHDL如何用Verilator仿真(How SpinalHDL simulates the hardware with Verilator backend)<a class="headerlink" href="#spinalhdlverilator-how-spinalhdl-simulates-the-hardware-with-verilator-backend" title="Permalink to this heading"></a></h3>
<ol class="simple">
<li><p>SpinalHDL会产生和Verilog等价的DUT硬件模型, 并用Verilator把它转换成C++的周期精度模型。</p></li>
<li><p>C++模型会被编译成共享对象(shared object)(.so), 该共享对象通过JNR-FFI和Scala联系起来。</p></li>
<li><p>本地Verilator API通过提供多线程API来进行抽象描述。</p></li>
</ol>
<p><strong>优势</strong></p>
<ul class="simple">
<li><p>因为Verilator后端用编译生成的C++仿真模型, 仿真速度比其他商业和免费仿真器都要快。</p></li>
</ul>
<p><strong>局限</strong></p>
<ul class="simple">
<li><p>Verilator只支持对Verilog/System Verilog代码的综合, 因此在对Verilog黑盒仿真的时候要注意是不是不可综合的。</p></li>
<li><p>VHDL黑盒无法被仿真。</p></li>
<li><p>因为必须编译并链接到产生的C++模型上, 仿真启动过程有些缓慢。</p></li>
</ul>
</section>
<section id="spinalhdlghdl-icarus-how-spinalhdl-simulates-the-hardware-with-ghdl-icarus-backend">
<h3>二、SpinalHDL如何用GHDL/Icarus仿真(How SpinalHDL simulates the hardware with GHDL/Icarus backend)<a class="headerlink" href="#spinalhdlghdl-icarus-how-spinalhdl-simulates-the-hardware-with-ghdl-icarus-backend" title="Permalink to this heading"></a></h3>
<ol class="simple">
<li><p>基于选择的仿真器, SpinalHDL生成Verilog/VHDL的DUT模型</p></li>
<li><p>HDL模型会加载到仿真器中</p></li>
<li><p>JVM和仿真之间的通信通过共享存储建立。指令用VPI发射给仿真器。</p></li>
</ol>
<p><strong>优势</strong></p>
<ul class="simple">
<li><p>GHDL和Icarus Verilog都可以兼容不可综合的HDL代码；</p></li>
<li><p>相比于Verilator, 仿真启动过程非常快。</p></li>
</ul>
<p><strong>局限</strong></p>
<ul class="simple">
<li><p>GHDL只接受VHDL代码, 因此该仿真器只能用VHDL黑盒；</p></li>
<li><p>Icarus只接受Verilog代码, 因此该仿真器只能用Verilog黑盒；</p></li>
<li><p>仿真时间比Verilator慢了大概一个数量级</p></li>
</ul>
<p>最后, 因为本地Verilator API非常粗糙, SpinalHDL通过提供单和多线程的仿真API进行抽象描述, 来帮助用户建立testbench实现。</p>
</section>
<section id="spinalhdlsynopsys-vcs-how-spinalhdl-simulates-the-hardware-with-synopsys-vcs-backend">
<h3>三、SpinalHDL如何用Synopsys VCS仿真(How SpinalHDL simulates the hardware with Synopsys VCS backend)<a class="headerlink" href="#spinalhdlsynopsys-vcs-how-spinalhdl-simulates-the-hardware-with-synopsys-vcs-backend" title="Permalink to this heading"></a></h3>
<ol class="simple">
<li><p>SpinalHDL生成Verilog/VHDL(基于你的选择)硬件模型的DUT；</p></li>
<li><p>HDL模型被加载到仿真器中；</p></li>
<li><p>仿真和JVM之间的通信通过共享存储建立, 指令用VPI发给仿真器。</p></li>
</ol>
<p><strong>优势</strong></p>
<ul class="simple">
<li><p>支持所有的SystemVerilog/Verilog/VHDL语言特征；</p></li>
<li><p>支持加密IP；</p></li>
<li><p>支持FSDB波形dump；</p></li>
<li><p>编译和仿真均有很高性能。</p></li>
</ul>
<p><strong>局限</strong></p>
<ul class="simple">
<li><p>Synopsys VCS是一款商用仿真工具, 是资源是封闭的并且付费, 你需要合法地拥有自己的licenses来使用它。</p></li>
</ul>
<p>在使用VCS仿真后端之前, 确保检查系统的VCS环境。</p>
</section>
<section id="id90">
<h3>四、性能<a class="headerlink" href="#id90" title="Permalink to this heading"></a></h3>
<p>当需要进行高性能仿真, 应该用Verilator作为后端。对于像Murax一样的小型SoC, Intel® Core™ i7-4720HQ足以每秒仿真1,200,000个时钟周期。然而, 当DUT很简单并且最大也就几千个时钟周期的仿真, 用GHDL或Icarus Verilog会产生更好的结果, 因为他们有更少的仿真负载消耗。</p>
</section>
</section>
<section id="installation-instructions">
<h2>安装指南(Installation instructions)<a class="headerlink" href="#installation-instructions" title="Permalink to this heading"></a></h2>
<section id="scala">
<h3>一、Scala<a class="headerlink" href="#scala" title="Permalink to this heading"></a></h3>
<p>为了能启动SpinalSim, 以下语句需要添加到你的build.sbt文件中：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">fork</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
</pre></div>
</div>
<p>同样的以下导入也需要添加在testbench源文件中：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
</pre></div>
</div>
</section>
<section id="backend-dependent-installation-instructions">
<h3>二、后端相关的安装指南(Backend-dependent installation instructions)<a class="headerlink" href="#backend-dependent-installation-instructions" title="Permalink to this heading"></a></h3>
<ol>
<li><p>GHDL的搭建和安装(Setup and installation of GHDL)</p>
<p>尽管GHDL在linux分发包系统中广泛应用, SpinalHDL在GHDL v0.37后才支持基于GHDL的代码bug修正功能, 因此推荐从源安装GHDL。进程间boost的C++库也应该被安装, 这个库包含在像分布式debian的libboost-dev包中。需要进程间boost来生成共享存储的通信接口。</p>
<p><strong>Linux</strong></p>
<div class="highlight-Linux notranslate"><div class="highlight"><pre><span></span>sudo apt-get install build-essential libboost-dev git
sudo apt-get install gnat # Ada compiler used to buid GHDL
git clone https://github.com/ghdl/ghdl.git
cd ghdl
mkdir build
cd build
../configure
make
sudo make install
</pre></div>
</div>
<p>同样的与你的Java版本相应的openjdk包也应该被安装。</p>
<p>Windows安装与更多的配置选择, 可参考https://ghdl.github.io/ghdl/getting.html</p>
</li>
<li><p>Icarus的搭建和安装(Setup and installation of Icarus)</p>
<p>在大多数最近的分发包linux系统中, 一个最近版本的Icarus Verilog通过该系统被广泛应用。进程间boost的C++库也应该被安装, 这个库包含在像分布式debian的libboost-dev包中。需要进程间boost来生成共享存储的通信接口。</p>
<p><strong>Linux</strong></p>
<div class="highlight-Linux notranslate"><div class="highlight"><pre><span></span>sudo apt-get install build-essential libboost-dev iverilog
</pre></div>
</div>
<p>同样的与你的Java版本相应的openjdk包也应该被安装。</p>
<p>Windows安装与更多的配置选择, 可参考https://iverilog.fandom.com/wiki/Installation_Guide</p>
</li>
<li><p>VCS仿真配置(VCS Simulation Configuration)</p>
<p><strong>环境变量</strong></p>
<p>你应该先定义如下环境变量：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">VCS_HOME</span></code>：VCS的安装根目录。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VERDI_HOME</span></code>：Verdi的安装根目录。</p></li>
<li><p>把<code class="docutils literal notranslate"><span class="pre">$VCS_HOME/bin</span></code>和<code class="docutils literal notranslate"><span class="pre">$VERDI_HOME/bin</span></code>增加到你的<code class="docutils literal notranslate"><span class="pre">PATH</span></code>下。</p></li>
</ul>
<p>把以下路径添加到<code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code>前面来开启PLI特征。</p>
<div class="highlight-Linux notranslate"><div class="highlight"><pre><span></span>export LD_LIBRARY_PATH=$VERDI_HOME/share/PLI/VCS/LINUX64:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$VERDI_HOME/share/PLI/IUS/LINUX64:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$VERDI_HOME/share/PLI/lib/LINUX64:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$VERDI_HOME/share/PLI/Ius/LINUX64:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$VERDI_HOME/share/PLI/MODELSIM/LINUX64:$LD_LIBRARY_PATH
</pre></div>
</div>
<p>如果你遇到<code class="docutils literal notranslate"><span class="pre">Compilation</span> <span class="pre">of</span> <span class="pre">SharedMemIface.cpp</span> <span class="pre">failed</span></code>错误, 应该先确定你是否正确安装了C++ boost库。头文件和库文件都应该被分别添加到<code class="docutils literal notranslate"><span class="pre">CPLUS_INCLUDE_PATH</span></code>, <code class="docutils literal notranslate"><span class="pre">LIBRARY_PATH</span></code>和<code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code>。</p>
<p><strong>用户定义的环境的搭建</strong></p>
<p>有时在运行VCS仿真的时候需要VCS的环境搭建文件<em>synopsys_sim.setup</em>。此外你也可能会想在VCS启动编译前运行一些脚本或代码来搭建环境, 你可以用<em>withVCSSimSetup</em>：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">simConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SimConfig</span><span class="w"></span>
<span class="p">.</span><span class="n">withVCS</span><span class="w"></span>
<span class="p">.</span><span class="n">withVCSSimSetup</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">setupFile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;~/work/myproj/sim/synopsys_sim.setup&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">beforeAnalysis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// this code block will be run before VCS analysis step.</span>
<span class="w">    </span><span class="s">&quot;pwd&quot;</span><span class="p">.</span><span class="o">!</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello, VCS&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>这个方法会把你自己的<em>synopsys_sim.setup</em>复制到VCS工作路径下, 并运行你的脚本。</p>
<p><strong>VCS Flags</strong></p>
<p>VCS后端流程包含三个编译流步骤：</p>
<ul class="simple">
<li><p>(1) 分析步骤：用<code class="docutils literal notranslate"><span class="pre">vlogan</span></code>和<code class="docutils literal notranslate"><span class="pre">vhdlan</span></code>分析HDL模型。</p></li>
<li><p>(2) 细化步骤：用<code class="docutils literal notranslate"><span class="pre">vcs</span></code>细化模型并生成可执行硬件模型。</p></li>
<li><p>(3) 仿真步骤：运行仿真。</p></li>
</ul>
<p>每一步, 用户可以通过<code class="docutils literal notranslate"><span class="pre">VCSFlags</span></code>传递一些特定的标志来是能像SDF反标或多线程等特征。</p>
<p><code class="docutils literal notranslate"><span class="pre">VCSFlags</span></code>由三个参数</p>
</li>
</ol>
<pre><code>|       名称       |    数据类型    |             描述             |
| :--------------: | :------------: | :--------------------------: |
|  `compileFlags`  | `List[String]` | 标志传递到`vlogan`或`vhdlan` |
| `elaborateFlags` | `List[String]` |       标志传递到`vcs`        |
|    `runFlags`    | `List[String]` |  标志传递到可执行硬件模型中  |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>例如, 你可以同时给编译步骤和细化步骤传递`-kdb`标志来进行Verdi debug：

```Scala
val flags = VCSFlags(
    compileFlags = List(&quot;-kdb&quot;),
    elaborateFlags = List(&quot;-kdb&quot;)
)

val config =
SimConfig
    .withVCS(flags)
    .withFSDBWave
    .workspacePath(&quot;tb&quot;)
    .compile(UIntAdder(8))

...
```

**波形产生**

VCS后端可以生成三种波形形式：`VCD`, `VPD`和`FSDB`(Verdi所需的)。

你可以通过以下`SpinalSImConfig`方法使能他们：
</pre></div>
</div>
<pre><code>|      方法      |      描述      |
| :------------: | :------------: |
|   `withWave`   | 使能`VCS`波形  |
| `withVPDWave`  | 使能`VPD`波形  |
| `withFSDBWave` | 使能`FSDB`波形 |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>同样的, 你可以通过`withWaveDepth(depth: Int)`控制波形轨迹的深度。

**用黑盒仿真**

有时, IP供应商会以Verilog/VHDL的格式给你提供设计实例, 如果你想要把他们集成在你的SpinalHDL设计中, 由如下两种方式：

+ (1) 在`Blackbox`定义时, 用`addRTLPath(path:String)`把外部的Verilog/VHDL文件赋值给黑盒。
+ (2) 用`SpinalConfig`中的`mergeRTLSource(fileName: String=null)`方法
</pre></div>
</div>
<ol>
<li><p>Verilator的搭建和安装(Setup and installation of Verilator)</p>
<p>在Linux和Windows平台上均支持SpinalSim + Verilator。</p>
<p><strong>Scala</strong></p>
<p>不要忘记在<code class="docutils literal notranslate"><span class="pre">build.sbt</span></code>文件中增加以下语句：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">fork</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
</pre></div>
</div>
<p>并且你还要在Scala testbench中引入如下库：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
</pre></div>
</div>
<p><strong>Linux</strong></p>
<p>你也需要一个最近版本安装的Verilator：</p>
<div class="highlight-Linux notranslate"><div class="highlight"><pre><span></span>sudo apt-get install git make autoconf g++ flex bison  # First time prerequisites
git clone http://git.veripool.org/git/verilator   # Only first time
unsetenv VERILATOR_ROOT  # For csh; ignore error if on bash
unset VERILATOR_ROOT  # For bash
cd verilator
git pull        # Make sure we&#39;re up-to-date
git checkout v4.040
autoconf        # Create ./configure script
./configure
make -j$(nproc)
sudo make install
echo &quot;DONE&quot;
</pre></div>
</div>
<p><strong>Windows</strong></p>
<p>为了让SpinalSim + Verilator能在Windows上工作, 你需要做如下操作：</p>
<ul class="simple">
<li><p>安装MSYS2</p></li>
<li><p>通过MSYS2安装gcc/g++/verilator(为了能从源文件对Verilator编译)</p></li>
<li><p>在Windows<code class="docutils literal notranslate"><span class="pre">PATH</span></code>下增加MSY2的<code class="docutils literal notranslate"><span class="pre">bin</span></code>和<code class="docutils literal notranslate"><span class="pre">usr\bin</span></code>(i.e.:<code class="docutils literal notranslate"><span class="pre">C:\msys64\usr\bin;C:\msys64\mingw64\bin</span></code>)</p></li>
<li><p>检查JAVA_HOME环境变量是否指向JDK安装文件夹(i.e.:<code class="docutils literal notranslate"><span class="pre">C:\Program</span> <span class="pre">Files\Java\jdk-13.0.2</span></code>)</p></li>
</ul>
<p>之后你应该可以不再用MSYS2就能从Scala工程中运行SpinalSim + Verilator了。</p>
<p>从新安装的64bits MSYS2 MinGW, 你还需要在MSYS2 MinGW 64-bits shell下运行如下指令(一行一行敲)：</p>
<p><strong>从MinGW包管理器中</strong></p>
<div class="highlight-linux notranslate"><div class="highlight"><pre><span></span>pacman -Syuu
# Close the MSYS2 shell once you&#39;re asked to
pacman -Syuu
pacman -S --needed base-devel mingw-w64-x86_64-toolchain \
                git flex\
                mingw-w64-x86_64-cmake

git clone http://git.veripool.org/git/verilator
unset VERILATOR_ROOT
cd verilator
git pull
git checkout v4.040
autoconf
./configure
export CPLUS_INCLUDE_PATH=/usr/include:$CPLUS_INCLUDE_PATH
export PATH=/usr/bin/core_perl:$PATH
cp /usr/include/FlexLexer.h ./src

make -j$(nproc)
make install
echo &quot;DONE&quot;
# Add C:\msys64\usr\bin;C:\msys64\mingw64\bin to your Windows PATH
</pre></div>
</div>
<blockquote>
<div><p>重要：确保你的<code class="docutils literal notranslate"><span class="pre">PATH</span></code>环境变量指向JDK 1.8而且不包含JRE的安装。</p>
</div></blockquote>
<blockquote>
<div><p>重要：把MSYS2<code class="docutils literal notranslate"><span class="pre">bin</span></code>文件夹添加到你Windows<code class="docutils literal notranslate"><span class="pre">PATH</span></code>下会产生一些副作用。这就是为什么要把他们放在<code class="docutils literal notranslate"><span class="pre">PATH</span></code>的最后部分, 这样能减少他们的优先级。</p>
</div></blockquote>
</li>
</ol>
</section>
</section>
<section id="boot-a-simulation">
<h2>启动仿真(Boot a Simulation)<a class="headerlink" href="#boot-a-simulation" title="Permalink to this heading"></a></h2>
<section id="id91">
<h3>一、介绍(Introduction)<a class="headerlink" href="#id91" title="Permalink to this heading"></a></h3>
<p>这是一个硬件定义+testbench的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//你的硬件顶层</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">//你的测试顶层</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>

<span class="k">object</span><span class="w"> </span><span class="nc">DutTests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nc">SimConfig</span><span class="p">.</span><span class="n">withWave</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">TopLevel</span><span class="p">).</span><span class="n">doSim</span><span class="p">{</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">      </span><span class="c1">//仿真代码</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="configuration">
<h3>二、配置(Configuration)<a class="headerlink" href="#configuration" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">SimConfig</span></code>会返回默认的仿真配置实例, 通过该实例能调用各种函数对仿真进行配置：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">语句</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>withWave</code></td>
<td style="text-align: center;">启用仿真波形捕获(默认模式)</td>
</tr>
<tr>
<td style="text-align: center;"><code>withVcdWave</code></td>
<td style="text-align: center;">启用仿真波形捕获(VCD文本模式)</td>
</tr>
<tr>
<td style="text-align: center;"><code>withFstWave</code></td>
<td style="text-align: center;">启用仿真波形捕获(二进制FST模式)</td>
</tr>
<tr>
<td style="text-align: center;"><code>withConfig(SpinalConfig)</code></td>
<td style="text-align: center;">指定用来产生硬件的<code>SpinalConfig</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>allOptimisation</code></td>
<td style="text-align: center;">启用所有的RTL编译优化来减少仿真时间(会增加编译时间)</td>
</tr>
<tr>
<td style="text-align: center;"><code>workspacePath(path)</code></td>
<td style="text-align: center;">改变生成的sim文件的文件夹位置</td>
</tr>
<tr>
<td style="text-align: center;"><code>withVerilator</code></td>
<td style="text-align: center;">用Verilator作为仿真后端(默认)</td>
</tr>
<tr>
<td style="text-align: center;"><code>withGhdl</code></td>
<td style="text-align: center;">用withGhdl作为仿真后端</td>
</tr>
<tr>
<td style="text-align: center;"><code>withIVerilog</code></td>
<td style="text-align: center;">用IVerilog作为仿真后端</td>
</tr>
<tr>
<td style="text-align: center;"><code>withVCS</code></td>
<td style="text-align: center;">用VCS作为仿真后端</td>
</tr>
</tbody>
</table><p>之后你可以调用<code class="docutils literal notranslate"><span class="pre">compile(rtl)</span></code>函数对硬件编译并为仿真器做准备。这个函数会返回<code class="docutils literal notranslate"><span class="pre">SimCompiled</span></code>实例。</p>
<p>在这个<code class="docutils literal notranslate"><span class="pre">SimCompiled</span></code>实例中你可以用以下函数运行你的仿真：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">语句</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>doSim[(simName[, seed])]{dut =&gt; ...}</code></td>
<td style="text-align: center;">一直运行仿真指导主线程完成(不等待分支线程)或直到所有线程卡住</td>
</tr>
<tr>
<td style="text-align: center;"><code>doSimUntilVoid[(simName[, seed])]{dut =&gt; ...}</code></td>
<td style="text-align: center;">一直运行仿真知道所有线程完成或卡住</td>
</tr>
</tbody>
</table><p>例如：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">spinalConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SpinalConfig</span><span class="p">(</span><span class="n">defaultClockDomainFrequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">FixedFrequency</span><span class="p">(</span><span class="mi">10</span><span class="w"> </span><span class="nc">MHz</span><span class="p">))</span><span class="w"></span>

<span class="nc">SimConfig</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">withConfig</span><span class="p">(</span><span class="n">spinalConfig</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">withWave</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">allOptimisation</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">workspacePath</span><span class="p">(</span><span class="s">&quot;~/tmp&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">TopLevel</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">doSim</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//仿真代码</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>注意默认情况下, 仿真文件会被替换成<code class="docutils literal notranslate"><span class="pre">simWorkspace/xxx</span></code>文件夹。你可以通过设置<code class="docutils literal notranslate"><span class="pre">SPINALSIM_WROKSPACE</span></code>环境变量重写simWorkspace的位置。</p>
</section>
<section id="running-multiple-tests-on-the-same-hardware">
<h3>三、在同一硬件上运行多个测试用例(Running multiple tests on the same hardware)<a class="headerlink" href="#running-multiple-tests-on-the-same-hardware" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">compiled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SimConfig</span><span class="p">.</span><span class="n">withWave</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Dut</span><span class="p">)</span><span class="w"></span>

<span class="n">compiled</span><span class="p">.</span><span class="n">doSim</span><span class="p">(</span><span class="s">&quot;testA&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">   </span><span class="c1">//仿真代码</span>
<span class="p">}</span><span class="w"></span>

<span class="n">compiled</span><span class="p">.</span><span class="n">doSim</span><span class="p">(</span><span class="s">&quot;testB&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">   </span><span class="c1">//仿真代码</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="throw-success-or-failure-of-the-simulation-from-a-thread">
<h3>四、从线程中报告仿真的成功或失败(Throw Success or Failure of the simulation from a thread)<a class="headerlink" href="#throw-success-or-failure-of-the-simulation-from-a-thread" title="Permalink to this heading"></a></h3>
<p>在仿真的任何一个时刻你都可以调用<code class="docutils literal notranslate"><span class="pre">simSuccess</span></code>或<code class="docutils literal notranslate"><span class="pre">simFailure</span></code>来终止它。</p>
<p>如果仿真太大, 很可能会产生仿真失败, 例如因为testbench在等待从未发生的条件的判断。为此, 调用<code class="docutils literal notranslate"><span class="pre">SimTimeout(maxDuration)</span></code>其中<code class="docutils literal notranslate"><span class="pre">maxDuration</span></code>所仿真应该会发生失败的时间(以仿真时间为单位)。</p>
<p>例如, 在1000个时钟周期后终止仿真：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
<span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">forkStimulus</span><span class="p">(</span><span class="n">period</span><span class="p">)</span><span class="w"></span>
<span class="nc">SimTimeout</span><span class="p">(</span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">period</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="accessing-signals-of-the-simulation">
<h2>访问仿真信号(Accessing signals of the simulation)<a class="headerlink" href="#accessing-signals-of-the-simulation" title="Permalink to this heading"></a></h2>
<section id="read-and-write-signals">
<h3>一、读写信号(Read and write signals)<a class="headerlink" href="#read-and-write-signals" title="Permalink to this heading"></a></h3>
<p>每个顶层的接口信号都可以通过Scala读写：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">语句</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>Bool.toBoolean</code></td>
<td style="text-align: center;">读出硬件<code>Bool</code>信号作为Scala<code>Boolean</code>值</td>
</tr>
<tr>
<td style="text-align: center;"><code>Bits</code>/<code>UInt</code>/<code>SInt.toInt</code></td>
<td style="text-align: center;">读出硬件<code>BitVector</code>信号作为Scala<code>Int</code>值</td>
</tr>
<tr>
<td style="text-align: center;"><code>Bits</code>/<code>UInt</code>/<code>SInt.toLong</code></td>
<td style="text-align: center;">读出硬件<code>BitVector</code>信号作为Scala<code>Long</code>值</td>
</tr>
<tr>
<td style="text-align: center;"><code>Bits</code>/<code>UInt</code>/<code>SInt.toBigInt</code></td>
<td style="text-align: center;">读出硬件<code>BitVector</code>信号作为Scala<code>BigInt</code>值</td>
</tr>
<tr>
<td style="text-align: center;"><code>SpinalEnumCraft.toEnum</code></td>
<td style="text-align: center;">读出硬件<code>SpinalEnumCraft</code>信号作为Scala<code>SpinalEnumElement</code>值</td>
</tr>
<tr>
<td style="text-align: center;"><code>Bool #= Boolean</code></td>
<td style="text-align: center;">用Scala<code>Boolean</code>值赋值给硬件<code>Bool</code>信号</td>
</tr>
<tr>
<td style="text-align: center;"><code>Bits</code>/<code>UInt</code>/<code>SInt #= Int</code></td>
<td style="text-align: center;">用Scala<code>Int</code>值赋值给硬件<code>BitVector</code>信号</td>
</tr>
<tr>
<td style="text-align: center;"><code>Bits</code>/<code>UInt</code>/<code>SInt #= Long</code></td>
<td style="text-align: center;">用Scala<code>Long</code>值赋值给硬件<code>BitVector</code>信号</td>
</tr>
<tr>
<td style="text-align: center;"><code>Bits</code>/<code>UInt</code>/<code>SInt #= BigInt</code></td>
<td style="text-align: center;">用Scala<code>BigInt</code>值赋值给硬件<code>BitVector</code>信号</td>
</tr>
<tr>
<td style="text-align: center;"><code>SpinalEnumCraft #= SpinalEnumElement</code></td>
<td style="text-align: center;">用Scala<code>SpinalEnumElement</code>值赋值给硬件<code>SpinalEnumCraft</code>信号</td>
</tr>
<tr>
<td style="text-align: center;"><code>Data.randomize()</code></td>
<td style="text-align: center;">给SpinalHDL值赋随机值</td>
</tr>
</tbody>
</table><div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="mi">42</span><span class="w"></span>
<span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="il">42l</span><span class="w"></span>
<span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="s">&quot;101010&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="nc">BigInt</span><span class="p">(</span><span class="s">&quot;0123456789ABCDEF&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"></span>
<span class="n">println</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">toInt</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="accessing-signals-inside-the-component-s-hierarchy">
<h3>二、在模块层次访问信号(Accessing signals inside the component’s hierarchy)<a class="headerlink" href="#accessing-signals-inside-the-component-s-hierarchy" title="Permalink to this heading"></a></h3>
<p>为了访问在模块层次内部的信号, 你应该先把信号设置成<code class="docutils literal notranslate"><span class="pre">simPublic</span></code>。</p>
<p>你可以直接在硬件描述中增加<code class="docutils literal notranslate"><span class="pre">simPublic</span></code>标签：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">SimAccessSubSignal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">simPublic</span><span class="p">()</span><span class="w"> </span><span class="c1">//这里给counter寄存器增加simPublic标签让其可被访问</span>
<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nc">SimConfig</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">TopLevel</span><span class="p">).</span><span class="n">doSim</span><span class="p">{</span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">forkStimulus</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">waitSampling</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">counter</span><span class="p">.</span><span class="n">toInt</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>或者你可以在完成对顶层例化后, 在仿真时增加标签</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">SimAccessSubSignal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nc">SimConfig</span><span class="p">.</span><span class="n">compile</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"></span>
<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">counter</span><span class="p">.</span><span class="n">simPublic</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="n">dut</span><span class="w"></span>
<span class="w">    </span><span class="p">}.</span><span class="n">doSim</span><span class="p">{</span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">forkStimulus</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">waitSampling</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">counter</span><span class="p">.</span><span class="n">toInt</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="id92">
<h2>时钟域(Clock domains)<a class="headerlink" href="#id92" title="Permalink to this heading"></a></h2>
<section id="api-stimulus-api">
<h3>一、激励API(Stimulus API)<a class="headerlink" href="#api-stimulus-api" title="Permalink to this heading"></a></h3>
<p>以下是<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>激励函数的列表：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">时钟域激励函数</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>forkStimulus(period)</code></td>
<td style="text-align: center;">分化仿真流程来产生时钟域激励(clock, reset, softReset, clockEnable singals)</td>
</tr>
<tr>
<td style="text-align: center;"><code>forkSimSpeedPrinter(printPeriod)</code></td>
<td style="text-align: center;">分化仿真流程定期以实时秒数下的千-周期打印仿真速度。<code>printPeriod</code>是实时秒数</td>
</tr>
<tr>
<td style="text-align: center;"><code>clockToggle()</code></td>
<td style="text-align: center;">切换时钟信号</td>
</tr>
<tr>
<td style="text-align: center;"><code>fallingEdge()</code></td>
<td style="text-align: center;">清空时钟信号</td>
</tr>
<tr>
<td style="text-align: center;"><code>risingEdge()</code></td>
<td style="text-align: center;">设置时钟信号</td>
</tr>
<tr>
<td style="text-align: center;"><code>assertReset()</code></td>
<td style="text-align: center;">将复位信号设置为有效电平</td>
</tr>
<tr>
<td style="text-align: center;"><code>deassertReset()</code></td>
<td style="text-align: center;">将复位信号设置为无效电平</td>
</tr>
<tr>
<td style="text-align: center;"><code>assertClockEnable()</code></td>
<td style="text-align: center;">将时钟使能信号设置为有效电平</td>
</tr>
<tr>
<td style="text-align: center;"><code>deassertClockEnable()</code></td>
<td style="text-align: center;">将时钟使能信号设置为无效电平</td>
</tr>
<tr>
<td style="text-align: center;"><code>assertSoftReset()</code></td>
<td style="text-align: center;">将软复位设置为有效电平</td>
</tr>
<tr>
<td style="text-align: center;"><code>deassertSoftReset()</code></td>
<td style="text-align: center;">将软复位信号设置为无效电平</td>
</tr>
</tbody>
</table></section>
<section id="api-wait-api">
<h3>二、等待API(Wait API)<a class="headerlink" href="#api-wait-api" title="Permalink to this heading"></a></h3>
<p>以下是可用于等待时钟域中给定事件的<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>实用程序列表：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">时钟域等待函数</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>waitSampling([cyclesCount])</code></td>
<td style="text-align: center;">一直等待直到<code>ClockDomain</code>采样(active clock edge &amp;&amp; deassertReset &amp;&amp; assertClockEnable)</td>
</tr>
<tr>
<td style="text-align: center;"><code>waitRisingEdge([cyclesCount])</code></td>
<td style="text-align: center;">等待<code>cyclesCount</code>个时钟上升沿, <code>cyclesCount</code>默认是1周期。注意, <code>cyclesCount=0</code>是合法的, 并且该函数对reset/softReset/clockEnable不敏感</td>
</tr>
<tr>
<td style="text-align: center;"><code>waitFallingEdge([cyclesCount])</code></td>
<td style="text-align: center;">与<code>waitRisingEdge</code>相同但是针对下降沿</td>
</tr>
<tr>
<td style="text-align: center;"><code>waitActiveEdge([cyclesCount])</code></td>
<td style="text-align: center;">与<code>waitRisingEdge</code>相同但是针对由<code>ClockDomainConfig</code>指定的边沿</td>
</tr>
<tr>
<td style="text-align: center;"><code>waitRisingEdgeWhere(condition)</code></td>
<td style="text-align: center;">与<code>waitRisingEdge</code>相同但要是退出, 当上升沿触发Boolean<code>condition</code>必须为真</td>
</tr>
<tr>
<td style="text-align: center;"><code>waitFallingEdgeWhere(condition)</code></td>
<td style="text-align: center;">与<code>waitRisingEdgeWhere</code>相同但是针对下降沿</td>
</tr>
<tr>
<td style="text-align: center;"><code>waitActiveEdgeWhere(condition)</code></td>
<td style="text-align: center;">与<code>waitRisingEdgeWhere</code>相同但是针对由<code>ClockDomainConfig</code>指定的边沿</td>
</tr>
</tbody>
</table><blockquote>
<div><p>注意：所有的等待API的功能只能从线程内部调用, 不能从传回调用。</p>
</div></blockquote>
</section>
<section id="api-callback-api">
<h3>三、传回API(Callback API)<a class="headerlink" href="#api-callback-api" title="Permalink to this heading"></a></h3>
<p>以下是可以用于传回时钟域中给定事件的<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>实用程序列表：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">时钟域传回函数</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>onNextSampling{ callback }</code></td>
<td style="text-align: center;">只在下一个<code>ClockDomain</code>采样时执行传回代码(active edge + reset off + clock enable on)</td>
</tr>
<tr>
<td style="text-align: center;"><code>onSamplings{ callback }</code></td>
<td style="text-align: center;">每次<code>ClockDomain</code>采样时执行传回代码(active edge + reset off + clock enable on)</td>
</tr>
<tr>
<td style="text-align: center;"><code>onActiveEdges{ callback }</code></td>
<td style="text-align: center;">每次<code>ClockDomain</code>生成配置边沿时执行传回代码</td>
</tr>
<tr>
<td style="text-align: center;"><code>onEdges{ callback }</code></td>
<td style="text-align: center;">每次<code>ClockDomain</code>生成上升或下降边沿时执行传回代码</td>
</tr>
<tr>
<td style="text-align: center;"><code>onRisingEdges{ callback }</code></td>
<td style="text-align: center;">每次<code>ClockDomain</code>生成上升边沿时执行传回代码</td>
</tr>
<tr>
<td style="text-align: center;"><code>onFallingEdges{ callback }</code></td>
<td style="text-align: center;">每次<code>ClockDomain</code>生成下降边沿时执行传回代码</td>
</tr>
</tbody>
</table></section>
<section id="default-clockdomain">
<h3>四、默认时钟域(Default ClockDomain)<a class="headerlink" href="#default-clockdomain" title="Permalink to this heading"></a></h3>
<p>你可以如下所示访存顶层的默认<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//线程分叉以产生复位的例子, 并且之后每5个单位时间翻转一次时钟。</span>
<span class="c1">//dut.clockDomain参考在模块例化期间产生的隐含的时钟域</span>
<span class="n">fork</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">assertReset</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">fallingEdge</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">clockToggle</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p>备注：你也可以直接分化一个标准reset/clock进程：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">forkStimulus</span><span class="p">(</span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>下例所如何等待时钟上升沿的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">waitRisingEdge</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="new-clockdomain">
<h3>五、新时钟域(New ClockDomain)<a class="headerlink" href="#new-clockdomain" title="Permalink to this heading"></a></h3>
<p>如果你顶层定义了一些时钟并且复位输入没有直接集成到<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>中, 你可以直接在testbench中定义他们对应的<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//在testbench中</span>
<span class="nc">ClockDomain</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">coreClk</span><span class="p">,</span><span class="w"> </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">coreReset</span><span class="p">).</span><span class="n">forkStimulus</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="api-thread-full-api">
<h2>满线程API(Thread-full API)<a class="headerlink" href="#api-thread-full-api" title="Permalink to this heading"></a></h2>
<p>在SpinalSim中, 你可以用多线程写testbench, 这种方式比较像SystemVerilog, 也有点像VHDL/Verilog process/always块。这允许你写并行人物并用流式API控制仿真时间。</p>
<section id="fork-and-join-simulation-threads">
<h3>一、仿真线程的分叉和汇合(Fork and Join simulation threads)<a class="headerlink" href="#fork-and-join-simulation-threads" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//建立新线程</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myNewThread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// New simulation thread body</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">//一直等待`myNewThread`直到完成执行</span>
<span class="n">myNewThread</span><span class="p">.</span><span class="n">join</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="sleep-and-waituntil">
<h3>二、休眠和等待(Sleep and WaitUntil)<a class="headerlink" href="#sleep-and-waituntil" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//睡眠1000个单位时间</span>
<span class="n">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span><span class="w"></span>

<span class="c1">//在继续进行之前一直等待直到dut.io.a大于42</span>
<span class="n">waitUntil</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="api-thread-less-api">
<h2>少线程API(Thread-less API)<a class="headerlink" href="#api-thread-less-api" title="Permalink to this heading"></a></h2>
<p>也有一些函数帮助你避免线程的使用, 但是仍会允许你控制仿真时间流。</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">少线程函数</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>delayed(delay){ callback }</code></td>
<td style="text-align: center;">存下在当前时间步之后的<code>delay</code>仿真时间步时被调用的回调代码块</td>
</tr>
</tbody>
</table><p>相比于用一般仿真线程+睡眠, <code class="docutils literal notranslate"><span class="pre">delayed</span></code>函数的优势：</p>
<ul class="simple">
<li><p>性能(没有上下文切换)</p></li>
<li><p>存储空间的利用(没有本地JVM线程存储空间的收集)</p></li>
</ul>
<p>一些与<code class="docutils literal notranslate"><span class="pre">ClockDomain</span></code>相关的其他少线程函数都记录在”Callback API”模块中, 其他与delta-cycle相关的处理过程记录在”Sensitive API”中。</p>
</section>
<section id="api-sensitive-api">
<h2>敏感API(Sensitive API)<a class="headerlink" href="#api-sensitive-api" title="Permalink to this heading"></a></h2>
<p>你可以寄存每个仿真中的delta-cycle回调函数：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">敏感函数</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>forkSensitive{ callback }</code></td>
<td style="text-align: center;">寄存每个仿真中的delta-cycle回调函数</td>
</tr>
<tr>
<td style="text-align: center;"><code>forkSensitiveWhile{ callback }</code></td>
<td style="text-align: center;">寄存每个仿真中的增量周期(delta-cycle)回调函数, 当回调返回值为真(意味着它应该在下一个delta-cycle重新调度)</td>
</tr>
</tbody>
</table></section>
<section id="simulation-engine">
<h2>仿真引擎(Simulation engine)<a class="headerlink" href="#simulation-engine" title="Permalink to this heading"></a></h2>
<p>这一章解释了仿真引擎的内部构造。</p>
<p>仿真引擎通过在顶层Verilator C++仿真模型中应用以下仿真环来模仿事件驱动的仿真器(像VHDL/Verilog)：</p>
<p><img alt="simEngine" src="_images/simEngine.png" /></p>
<p>在底层, 仿真引擎管理如下原语：</p>
<ul class="simple">
<li><p><em>敏感回调</em>, 允许用户在每个仿真增量周期调用函数；</p></li>
<li><p><em>延时回调</em>, 允许用户在未来仿真时间调用函数；</p></li>
<li><p><em>仿真线程</em>, 允许用户描述并行进程；</p></li>
<li><p><em>指令缓存</em>, 允许用户一直延时对DUT的写访问直到当前增量周期；</p></li>
</ul>
<p>关于这些原语有一些使用的操作：</p>
<ul class="simple">
<li><p>敏感回调可以像时钟上升沿一样, 当给定条件发生唤醒仿真线程；</p></li>
<li><p>延时回调可以用来调度激励, 例如在给定时间, 或者时钟翻转后取消对复位信号断言；</p></li>
<li><p>上述二者均可以用来恢复仿真线程；</p></li>
<li><p>仿真线程可以用来产生激励并检查DUT的输出值；</p></li>
<li><p>指令缓存的目的主要是避免DUT和testbench之间的并发事件。</p></li>
</ul>
</section>
<section id="id93">
<h2>例子(Examples)<a class="headerlink" href="#id93" title="Permalink to this heading"></a></h2>
<section id="asychronous-adder">
<h3>一、异步加法器(Asychronous adder)<a class="headerlink" href="#asychronous-adder" title="Permalink to this heading"></a></h3>
<p>该例使用组合逻辑创建了能处理一些简单算术运算的三操作数<code class="docutils literal notranslate"><span class="pre">Component</span></code>：</p>
<p>testbench执行100次下述步骤：</p>
<ul class="simple">
<li><p>在0..255的范围内随机初始化<code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>和<code class="docutils literal notranslate"><span class="pre">c</span></code>；</p></li>
<li><p>给DUT的<code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>输入激励；</p></li>
<li><p>等1个仿真时间步(让输入信号传播)</p></li>
<li><p>检查输出是否正确。</p></li>
</ul>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>

<span class="k">import</span><span class="w"> </span><span class="nn">scala</span><span class="p">.</span><span class="nn">util</span><span class="p">.</span><span class="nc">Random</span>


<span class="k">object</span><span class="w"> </span><span class="nc">SimAsynchronousExample</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">Dut</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="w"> </span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="w"> </span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">c</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nc">SimConfig</span><span class="p">.</span><span class="n">withWave</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Dut</span><span class="p">).</span><span class="n">doSim</span><span class="p">{</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">      </span><span class="kd">var</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Random</span><span class="p">.</span><span class="n">nextInt</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">c</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="w">        </span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">//休眠1个时间步</span>
<span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="p">.</span><span class="n">toInt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">((</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="n">idx</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="fifo-dual-clock-fifo">
<h3>二、双时钟FIFO(Dual clock FIFO)<a class="headerlink" href="#fifo-dual-clock-fifo" title="Permalink to this heading"></a></h3>
<p>该例创建了为跨时钟域设计的<code class="docutils literal notranslate"><span class="pre">StreamFifoCC</span></code>, 用了3个仿真线程。</p>
<p>线程用来处理：</p>
<ul class="simple">
<li><p>管理两个时钟；</p></li>
<li><p>把数据推入FIFO；</p></li>
<li><p>把数据移出FIFO。</p></li>
</ul>
<p>输入随机数推入FIFO。</p>
<p>FIFO推出线程检查DUT的输出和参考模型是否匹配(原始的scala.collection.mutable.Queue实例)。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>

<span class="k">import</span><span class="w"> </span><span class="nn">scala</span><span class="p">.</span><span class="nn">collection</span><span class="p">.</span><span class="nn">mutable</span><span class="p">.</span><span class="nc">Queue</span>


<span class="k">object</span><span class="w"> </span><span class="nc">SimStreamFifoCCExample</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Compile the Component for the simulator.</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">compiled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SimConfig</span><span class="p">.</span><span class="n">withWave</span><span class="p">.</span><span class="n">allOptimisation</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">rtl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StreamFifoCC</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">dataType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">pushClock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">external</span><span class="p">(</span><span class="s">&quot;clkA&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">popClock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">external</span><span class="p">(</span><span class="s">&quot;clkB&quot;</span><span class="p">,</span><span class="n">withReset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Run the simulation.</span>
<span class="w">    </span><span class="n">compiled</span><span class="p">.</span><span class="n">doSimUntilVoid</span><span class="p">{</span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">queueModel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mutable</span><span class="p">.</span><span class="nc">Queue</span><span class="p">[</span><span class="nc">Long</span><span class="p">]()</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Fork a thread to manage the clock domains signals</span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">clocksThread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Clear the clock domains&#39; signals, to be sure the simulation captures their first edges.</span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">pushClock</span><span class="p">.</span><span class="n">fallingEdge</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">popClock</span><span class="p">.</span><span class="n">fallingEdge</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">pushClock</span><span class="p">.</span><span class="n">deassertReset</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Do the resets.</span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">pushClock</span><span class="p">.</span><span class="n">assertReset</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">pushClock</span><span class="p">.</span><span class="n">deassertReset</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Forever, randomly toggle one of the clocks.</span>
<span class="w">        </span><span class="c1">// This will create asynchronous clocks without fixed frequencies.</span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="nc">Random</span><span class="p">.</span><span class="n">nextBoolean</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">dut</span><span class="p">.</span><span class="n">pushClock</span><span class="p">.</span><span class="n">clockToggle</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">dut</span><span class="p">.</span><span class="n">popClock</span><span class="p">.</span><span class="n">clockToggle</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Push data randomly, and fill the queueModel with pushed transactions.</span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">pushThread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="p">.</span><span class="n">valid</span><span class="p">.</span><span class="n">randomize</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">randomize</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="n">dut</span><span class="p">.</span><span class="n">pushClock</span><span class="p">.</span><span class="n">waitSampling</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="p">.</span><span class="n">valid</span><span class="p">.</span><span class="n">toBoolean</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="p">.</span><span class="n">ready</span><span class="p">.</span><span class="n">toBoolean</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">queueModel</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">toLong</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Pop data randomly, and check that it match with the queueModel.</span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">popThread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="mi">100000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="p">.</span><span class="n">ready</span><span class="p">.</span><span class="n">randomize</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="n">dut</span><span class="p">.</span><span class="n">popClock</span><span class="p">.</span><span class="n">waitSampling</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="p">.</span><span class="n">valid</span><span class="p">.</span><span class="n">toBoolean</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="p">.</span><span class="n">ready</span><span class="p">.</span><span class="n">toBoolean</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">assert</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">toLong</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueModel</span><span class="p">.</span><span class="n">dequeue</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">simSuccess</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="fifo-single-clock-fifo">
<h3>三、单时钟FIFO(Single clock FIFO)<a class="headerlink" href="#fifo-single-clock-fifo" title="Permalink to this heading"></a></h3>
<p>该例创建了<code class="docutils literal notranslate"><span class="pre">StreamFifo</span></code>, 并产生3个仿真线程。不像Dual clock fifo, 本FIFO不需要复杂的时钟管理。</p>
<p>三个仿真线程用来处理：</p>
<ul class="simple">
<li><p>管理时钟/复位</p></li>
<li><p>数据推入FIFO</p></li>
<li><p>数据推出FIFO</p></li>
</ul>
<p>输入随机数推入FIFO</p>
<p>FIFO推出线程检查DUT的输出和参考模型是否匹配(原始的scala.collection.mutable.Queue实例)。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>

<span class="k">import</span><span class="w"> </span><span class="nn">scala</span><span class="p">.</span><span class="nn">collection</span><span class="p">.</span><span class="nn">mutable</span><span class="p">.</span><span class="nc">Queue</span>


<span class="k">object</span><span class="w"> </span><span class="nc">SimStreamFifoExample</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Compile the Component for the simulator.</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">compiled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SimConfig</span><span class="p">.</span><span class="n">withWave</span><span class="p">.</span><span class="n">allOptimisation</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">rtl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StreamFifo</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">dataType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="w"></span>
<span class="w">      </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Run the simulation.</span>
<span class="w">    </span><span class="n">compiled</span><span class="p">.</span><span class="n">doSimUntilVoid</span><span class="p">{</span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">queueModel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mutable</span><span class="p">.</span><span class="nc">Queue</span><span class="p">[</span><span class="nc">Long</span><span class="p">]()</span><span class="w"></span>

<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">forkStimulus</span><span class="p">(</span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="nc">SimTimeout</span><span class="p">(</span><span class="mi">1000000</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Push data randomly, and fill the queueModel with pushed transactions.</span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">pushThread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="p">.</span><span class="n">valid</span><span class="p">.</span><span class="n">randomize</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">randomize</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">waitSampling</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="p">.</span><span class="n">valid</span><span class="p">.</span><span class="n">toBoolean</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="p">.</span><span class="n">ready</span><span class="p">.</span><span class="n">toBoolean</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">queueModel</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">push</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">toLong</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Pop data randomly, and check that it match with the queueModel.</span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">popThread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="p">.</span><span class="n">ready</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="mi">100000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="p">.</span><span class="n">ready</span><span class="p">.</span><span class="n">randomize</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">waitSampling</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="p">.</span><span class="n">valid</span><span class="p">.</span><span class="n">toBoolean</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="p">.</span><span class="n">ready</span><span class="p">.</span><span class="n">toBoolean</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">assert</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pop</span><span class="p">.</span><span class="n">payload</span><span class="p">.</span><span class="n">toLong</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">queueModel</span><span class="p">.</span><span class="n">dequeue</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">simSuccess</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="synchronous-adder">
<h3>四、同步加法器(Synchronous adder)<a class="headerlink" href="#synchronous-adder" title="Permalink to this heading"></a></h3>
<p>本例用时序逻辑搭建了三操作数的简单算术运算<code class="docutils literal notranslate"><span class="pre">Component</span></code>。</p>
<ul class="simple">
<li><p>在0..255的范围内随机初始化<code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>和<code class="docutils literal notranslate"><span class="pre">c</span></code>；</p></li>
<li><p>给DUT的<code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>输入激励；</p></li>
<li><p>一直等待直到DUT信号再次被仿真采样；</p></li>
<li><p>检查输出是否正确。</p></li>
</ul>
<p>该例和Asynchronous adder例子的主要区别是本<code class="docutils literal notranslate"><span class="pre">Component</span></code>需要用<code class="docutils literal notranslate"><span class="pre">forkStimulus</span></code>产生时钟信号, 因为它内部用的是时序逻辑。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>

<span class="k">import</span><span class="w"> </span><span class="nn">scala</span><span class="p">.</span><span class="nn">util</span><span class="p">.</span><span class="nc">Random</span>


<span class="k">object</span><span class="w"> </span><span class="nc">SimSynchronousExample</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">Dut</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="w"> </span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="w"> </span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nc">SimConfig</span><span class="p">.</span><span class="n">withWave</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Dut</span><span class="p">).</span><span class="n">doSim</span><span class="p">{</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"></span>
<span class="w">      </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">forkStimulus</span><span class="p">(</span><span class="n">period</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="kd">var</span><span class="w"> </span><span class="n">resultModel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="mi">100</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="nc">Random</span><span class="p">.</span><span class="n">nextInt</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="nc">Random</span><span class="p">.</span><span class="n">nextInt</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">c</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="nc">Random</span><span class="p">.</span><span class="n">nextInt</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">dut</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">waitSampling</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="p">.</span><span class="n">toInt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">resultModel</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">resultModel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">toInt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">toInt</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">dut</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">toInt</span><span class="p">)</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="uart-decoder">
<h3>五、串口译码器(Uart decoder)<a class="headerlink" href="#uart-decoder" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// Fork a simulation process which will analyze the uartPin and print transmitted bytes into the simulation terminal.</span>
<span class="n">fork</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Wait until the design sets the uartPin to true (wait for the reset effect).</span>
<span class="w">  </span><span class="n">waitUntil</span><span class="p">(</span><span class="n">uartPin</span><span class="p">.</span><span class="n">toBoolean</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">waitUntil</span><span class="p">(</span><span class="n">uartPin</span><span class="p">.</span><span class="n">toBoolean</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="n">baudPeriod</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">uartPin</span><span class="p">.</span><span class="n">toBoolean</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="n">baudPeriod</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">bitId</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">uartPin</span><span class="p">.</span><span class="n">toBoolean</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">buffer</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">bitId</span><span class="w"></span>
<span class="w">      </span><span class="n">sleep</span><span class="p">(</span><span class="n">baudPeriod</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">uartPin</span><span class="p">.</span><span class="n">toBoolean</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">toChar</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="uart-encoder">
<h3>六、串口编码器(Uart encoder)<a class="headerlink" href="#uart-encoder" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// Fork a simulation process which will get chars typed into the simulation terminal and transmit them on the simulation uartPin.</span>
<span class="n">fork</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">uartPin</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// System.in is the java equivalent of the C&#39;s stdin.</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="nc">System</span><span class="p">.</span><span class="n">in</span><span class="p">.</span><span class="n">available</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kd">val</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">System</span><span class="p">.</span><span class="n">in</span><span class="p">.</span><span class="n">read</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="n">uartPin</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">      </span><span class="n">sleep</span><span class="p">(</span><span class="n">baudPeriod</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="n">bitId</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">uartPin</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="p">((</span><span class="n">buffer</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">bitId</span><span class="p">)</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">        </span><span class="n">sleep</span><span class="p">(</span><span class="n">baudPeriod</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="n">uartPin</span><span class="w"> </span><span class="o">#=</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">      </span><span class="n">sleep</span><span class="p">(</span><span class="n">baudPeriod</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">sleep</span><span class="p">(</span><span class="n">baudPeriod</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="c1">// Sleep a little while to avoid polling System.in too often.</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div STYLE="page-break-after: always;"></div></section>
</section>
</section>
<section id="formal-verification">
<h1>形式验证(Formal verification)<a class="headerlink" href="#formal-verification" title="Permalink to this heading"></a></h1>
<section id="general">
<h2>通常(General)<a class="headerlink" href="#general" title="Permalink to this heading"></a></h2>
<p>SpinalHDL可以生成SystemVerilog Assertions(SVA)的子集。大多数是断言, 假设, 覆盖和一些其他的。</p>
<p>此外它还提供允许直接在开源Symbi-Yosys工具链运行的形式化验证后端。</p>
</section>
<section id="formal-backend">
<h2>形式后端(Formal backend)<a class="headerlink" href="#formal-backend" title="Permalink to this heading"></a></h2>
<p>你可以通过如下代码运行一个模块的形式化验证：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">formal</span><span class="p">.</span><span class="n">_</span>
<span class="nc">FormalConfig</span><span class="p">.</span><span class="n">withBMC</span><span class="p">(</span><span class="mi">15</span><span class="p">).</span><span class="n">doVerify</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Toplevel to verify</span>
<span class="p">})</span><span class="w"></span>
</pre></div>
</div>
<p>同时支持三个模式：</p>
<ul class="simple">
<li><p>withBMC(depth)</p></li>
<li><p>withProve(depth)</p></li>
<li><p>withCover(depth)</p></li>
</ul>
</section>
<section id="installing-requirements">
<h2>安装需求(Installing requirements)<a class="headerlink" href="#installing-requirements" title="Permalink to this heading"></a></h2>
<p>为了安装Symbi-Yosys, 你需要一些设置, 你可以在如下网址得到预编译包：</p>
<ul class="simple">
<li><p>https://github.com/YosysHQ/oss-cad-suite-build/releases</p></li>
<li><p>https://github.com/YosysHQ/fpga-toolchain/releases</p></li>
</ul>
<p>或者你也可以从头开始编译：</p>
<ul class="simple">
<li><p>https://symbiyosys.readthedocs.io/en/latest/install.html</p></li>
</ul>
</section>
<section id="id94">
<h2>举例(Example)<a class="headerlink" href="#id94" title="Permalink to this heading"></a></h2>
<section id="external-assertions">
<h3>一、外部断言(External assertions)<a class="headerlink" href="#external-assertions" title="Permalink to this heading"></a></h3>
<p>这是一个简单计数器和其对应形式化验证的例子：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>

<span class="c1">//Here is our DUT</span>
<span class="k">class</span><span class="w"> </span><span class="nc">LimitedCounter</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">//The value register will always be between [2:10]</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">object</span><span class="w"> </span><span class="nc">LimitedCounterFormal</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">App</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// import utilities to run the formal verification, but also some utilities to describe formal stuff</span>
<span class="w">  </span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">formal</span><span class="p">.</span><span class="n">_</span>

<span class="w">  </span><span class="c1">// Here we run a formal verification which will explore the state space up to 15 cycles to find an assertion failure</span>
<span class="w">  </span><span class="nc">FormalConfig</span><span class="p">.</span><span class="n">withBMC</span><span class="p">(</span><span class="mi">15</span><span class="p">).</span><span class="n">doVerify</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Instanciate our LimitedCounter DUT as a FormalDut, which ensure that all the outputs of the dut are:</span>
<span class="w">    </span><span class="c1">// - directly and indirectly driven (no latch / no floating wire)</span>
<span class="w">    </span><span class="c1">// - allows the current toplevel to read every signal across the hierarchy</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">FormalDut</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">LimitedCounter</span><span class="p">())</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Ensure that the state space start with a proper reset</span>
<span class="w">    </span><span class="n">assumeInitial</span><span class="p">(</span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">isResetActive</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Check a few things</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="nc">Internal</span><span class="w"> </span><span class="n">assertions</span><span class="w"></span>

<span class="nc">If</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">want</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">embed</span><span class="w"> </span><span class="n">formal</span><span class="w"> </span><span class="n">statements</span><span class="w"> </span><span class="n">directly</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="nc">DUT</span><span class="p">:</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">LimitedCounterEmbedded</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// That code block will not be in the SpinalVerilog netlist by default. (would need to enable SpinalConfig().includeFormal. ...</span>
<span class="w">  </span><span class="nc">GenerationFlags</span><span class="p">.</span><span class="n">formal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">object</span><span class="w"> </span><span class="nc">LimitedCounterEmbeddedFormal</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">App</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">formal</span><span class="p">.</span><span class="n">_</span>

<span class="w">  </span><span class="nc">FormalConfig</span><span class="p">.</span><span class="n">withBMC</span><span class="p">(</span><span class="mi">15</span><span class="p">).</span><span class="n">doVerify</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">FormalDut</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">LimitedCounterEmbedded</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="n">assumeInitial</span><span class="p">(</span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">isResetActive</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="internal-assertions">
<h3>二、内部断言(Internal assertions)<a class="headerlink" href="#internal-assertions" title="Permalink to this heading"></a></h3>
<p>如果你愿意你也可以把形式化语句直接包含在DUT中：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">LimitedCounterEmbedded</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// That code block will not be in the SpinalVerilog netlist by default. (would need to enable SpinalConfig().includeFormal. ...</span>
<span class="w">  </span><span class="nc">GenerationFlags</span><span class="p">.</span><span class="n">formal</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">object</span><span class="w"> </span><span class="nc">LimitedCounterEmbeddedFormal</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">App</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">formal</span><span class="p">.</span><span class="n">_</span>

<span class="w">  </span><span class="nc">FormalConfig</span><span class="p">.</span><span class="n">withBMC</span><span class="p">(</span><span class="mi">15</span><span class="p">).</span><span class="n">doVerify</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">FormalDut</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">LimitedCounterEmbedded</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="n">assumeInitial</span><span class="p">(</span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">isResetActive</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="external-stimulus">
<h3>三、外部激励(External stimulus)<a class="headerlink" href="#external-stimulus" title="Permalink to this heading"></a></h3>
<p>如果你的DUT有输入, 你需要从testbench中驱动他们。所有的一般硬件语句都可以实现它, 但是你也可以用形式化<em>anyseq</em>,<em>qnyconst</em>, <em>allseq</em>, <em>allconst</em>语句：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">LimitedCounterInc</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">//Only increment the value when the inc input is set</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">inc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">inc</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">object</span><span class="w"> </span><span class="nc">LimitedCounterIncFormal</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">App</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">formal</span><span class="p">.</span><span class="n">_</span>

<span class="w">  </span><span class="nc">FormalConfig</span><span class="p">.</span><span class="n">withBMC</span><span class="p">(</span><span class="mi">15</span><span class="p">).</span><span class="n">doVerify</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">FormalDut</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">LimitedCounterInc</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="n">assumeInitial</span><span class="p">(</span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">isResetActive</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Drive dut.inc with random values</span>
<span class="w">    </span><span class="n">anyseq</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">inc</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="more-assertions-past">
<h3>四、更多的断言/传递(More assertions/past)<a class="headerlink" href="#more-assertions-past" title="Permalink to this heading"></a></h3>
<p>例如我们可以检查值是否计数自增(如果没到10):</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="nc">FormalConfig</span><span class="p">.</span><span class="n">withBMC</span><span class="p">(</span><span class="mi">15</span><span class="p">).</span><span class="n">doVerify</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">FormalDut</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">LimitedCounter</span><span class="p">())</span><span class="w"></span>
<span class="w">  </span><span class="n">assumeInitial</span><span class="p">(</span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">isResetActive</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Check that the value is incrementing.</span>
<span class="w">  </span><span class="c1">// hasPast is used to ensure that the past(dut.value) had at least one sampling out of reset</span>
<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">pastValid</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">past</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">=/=</span><span class="w"> </span><span class="mi">10</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">past</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">})</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="assuming-memory-content">
<h3>五、假设存储内容(Assuming memory content)<a class="headerlink" href="#assuming-memory-content" title="Permalink to this heading"></a></h3>
<p>本例中我们希望防止<code class="docutils literal notranslate"><span class="pre">1</span></code>出现在内存中：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">DutWithRam</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">ram</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Mem</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">4</span><span class="p">)(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="n">ram</span><span class="p">.</span><span class="n">writePort</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="n">ram</span><span class="p">.</span><span class="n">readAsyncPort</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">object</span><span class="w"> </span><span class="nc">FormalRam</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">App</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">formal</span><span class="p">.</span><span class="n">_</span>

<span class="w">  </span><span class="nc">FormalConfig</span><span class="p">.</span><span class="n">withBMC</span><span class="p">(</span><span class="mi">15</span><span class="p">).</span><span class="n">doVerify</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">dut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">FormalDut</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">DutWithRam</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="n">assumeInitial</span><span class="p">(</span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">isResetActive</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">// assume that no word in the ram has the value 1</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">dut</span><span class="p">.</span><span class="n">ram</span><span class="p">.</span><span class="n">wordCount</span><span class="p">){</span><span class="w"></span>
<span class="w">      </span><span class="n">assumeInitial</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">ram</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=/=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allow the write anything but value 1 in the ram</span>
<span class="w">    </span><span class="n">anyseq</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">write</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">clockDomain</span><span class="p">.</span><span class="n">withoutReset</span><span class="p">(){</span><span class="w"> </span><span class="c1">//As the memory write can occur during reset, we need to ensure the assume apply there too</span>
<span class="w">      </span><span class="n">assume</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">write</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=/=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Check that no word in the ram is set to 1</span>
<span class="w">    </span><span class="n">anyseq</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">read</span><span class="p">.</span><span class="n">address</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">read</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=/=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="utilities-and-primitives">
<h2>实用程序和原语(Utilities and primitives)<a class="headerlink" href="#utilities-and-primitives" title="Permalink to this heading"></a></h2>
<section id="assertions-clock-reset">
<h3>一、断言/时钟/复位(Assertions/clock/reset)<a class="headerlink" href="#assertions-clock-reset" title="Permalink to this heading"></a></h3>
<p>在复位时, 断言经常是计时和禁用的, 这也同样适用于假设和覆盖。</p>
<p>如果你想在复位期间保持断言使能, 你可以用如下操作：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">withoutReset</span><span class="p">(){</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">wuff</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="specifying-the-initial-value-of-a-signal">
<h3>二、给定信号初始值(Specifying the initial value of a signal)<a class="headerlink" href="#specifying-the-initial-value-of-a-signal" title="Permalink to this heading"></a></h3>
<p>例如, 对于当前时钟域的复位信号(在顶层很有用)：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">readResetWire</span><span class="w"> </span><span class="n">initial</span><span class="p">(</span><span class="nc">False</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="specifying-a-initial-assumption">
<h3>三、给定初始化声明(Specifying a initial assumption)<a class="headerlink" href="#specifying-a-initial-assumption" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">assumeInitial</span><span class="p">(</span><span class="n">clockDomain</span><span class="p">.</span><span class="n">isResetActive</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="memory-content">
<h3>四、存储内容(Memory content)<a class="headerlink" href="#memory-content" title="Permalink to this heading"></a></h3>
<p>如果在你的设计中有Mem, 并且你想检查它的内容, 你可以用如下方式：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// Manual access</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">dut</span><span class="p">.</span><span class="n">ram</span><span class="p">.</span><span class="n">wordCount</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="n">assumeInitial</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">ram</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=/=</span><span class="w"> </span><span class="nc">X</span><span class="p">)</span><span class="w"> </span><span class="c1">//No occurence of the word X</span>
<span class="p">}</span><span class="w"></span>

<span class="n">assumeInitial</span><span class="p">(</span><span class="o">!</span><span class="n">dut</span><span class="p">.</span><span class="n">ram</span><span class="p">.</span><span class="n">formalContains</span><span class="p">(</span><span class="nc">X</span><span class="p">))</span><span class="w"> </span><span class="c1">//No occurence of the word X</span>

<span class="n">assumeInitial</span><span class="p">(</span><span class="n">dut</span><span class="p">.</span><span class="n">ram</span><span class="p">.</span><span class="n">formalCount</span><span class="p">(</span><span class="nc">X</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">//only one occurence of the word X</span>
</pre></div>
</div>
</section>
<section id="specifying-assertion-in-the-reset-scope">
<h3>五、在复位区域内给定断言(Specifying assertion in the reset scope)<a class="headerlink" href="#specifying-assertion-in-the-reset-scope" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">duringReset</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">assume</span><span class="p">(</span><span class="n">rawrrr</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">assume</span><span class="p">(</span><span class="n">wuff</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="formal-primitives">
<h3>六、形式化原语(Formal primitives)<a class="headerlink" href="#formal-primitives" title="Permalink to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">语句</th>
<th style="text-align: center;">返回类型</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>assert(Bool)</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><code>assume(Bool)</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><code>cover(Bool)</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><code>past(that: T, delay: Int)</code></td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">返回延时<code>delay</code>周期的<code>that</code>(默认1周期)</td>
</tr>
<tr>
<td style="text-align: center;"><code>rose(that: Bool)</code></td>
<td style="text-align: center;">Bool</td>
<td style="text-align: center;">当<code>that</code>从False变换成True, 返回True</td>
</tr>
<tr>
<td style="text-align: center;"><code>fall(that: Bool)</code></td>
<td style="text-align: center;">Bool</td>
<td style="text-align: center;">当<code>that</code>从False变换成True, 返回True</td>
</tr>
<tr>
<td style="text-align: center;"><code>changed(that: Bool)</code></td>
<td style="text-align: center;">Bool</td>
<td style="text-align: center;">当<code>that</code>当前值与上周期相比发生变化, 返回True</td>
</tr>
<tr>
<td style="text-align: center;"><code>stable(that: Bool)</code></td>
<td style="text-align: center;">Bool</td>
<td style="text-align: center;">当<code>that</code>当前值与上周期相比没有发生变化, 返回True</td>
</tr>
<tr>
<td style="text-align: center;"><code>initstate()</code></td>
<td style="text-align: center;">Bool</td>
<td style="text-align: center;">第一个周期返回True</td>
</tr>
</tbody>
</table><blockquote>
<div><p>你也可以在past用initstate：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">when</span><span class="p">(</span><span class="n">past</span><span class="p">(</span><span class="n">enable</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="nc">False</span><span class="p">)){</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
</section>
</section>
<section id="limitations">
<h2>限制(Limitations)<a class="headerlink" href="#limitations" title="Permalink to this heading"></a></h2>
<p>对于未计时的断言暂不支持, 但似乎很多代码在第三方验证例子中的的使用这种代码风格。</p>
<section id="id95">
<h3>四、例子(Example)<a class="headerlink" href="#id95" title="Permalink to this heading"></a></h3>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RegFileIntrExample</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="kd">val</span><span class="w"> </span><span class="n">apb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">Apb3</span><span class="p">(</span><span class="nc">Apb3Config</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">)))</span><span class="w"></span>
<span class="w">     </span><span class="kd">val</span><span class="w"> </span><span class="n">int_pulse0</span><span class="p">,</span><span class="w"> </span><span class="n">int_pulse1</span><span class="p">,</span><span class="w"> </span><span class="n">int_pulse2</span><span class="p">,</span><span class="w"> </span><span class="n">int_pulse3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">     </span><span class="kd">val</span><span class="w"> </span><span class="n">int_level0</span><span class="p">,</span><span class="w"> </span><span class="n">int_level1</span><span class="p">,</span><span class="w"> </span><span class="n">int_level2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">     </span><span class="kd">val</span><span class="w"> </span><span class="n">sys_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">     </span><span class="kd">val</span><span class="w"> </span><span class="n">gpio_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="kd">val</span><span class="w"> </span><span class="n">busif</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BusInterface</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="p">,</span><span class="w">  </span><span class="p">(</span><span class="mh">0x000</span><span class="p">,</span><span class="mi">1</span><span class="w"> </span><span class="nc">KiB</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">regPre</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;AP&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">io</span><span class="p">.</span><span class="n">sys_int</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">interruptFactory</span><span class="p">(</span><span class="s">&quot;SYS&quot;</span><span class="p">,</span><span class="n">io</span><span class="p">.</span><span class="n">int_pulse0</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">int_pulse1</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">int_pulse2</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">int_pulse3</span><span class="p">)</span><span class="w"></span>
<span class="w">   </span><span class="n">io</span><span class="p">.</span><span class="n">gpio_int</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">busif</span><span class="p">.</span><span class="n">interruptLevelFactory</span><span class="p">(</span><span class="s">&quot;GPIO&quot;</span><span class="p">,</span><span class="n">io</span><span class="p">.</span><span class="n">int_level0</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">int_level1</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">int_level2</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">sys_int</span><span class="p">)</span><span class="w"></span>

<span class="w">   </span><span class="k">def</span><span class="w"> </span><span class="nf">genDoc</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">CHeaderGenerator</span><span class="p">(</span><span class="s">&quot;intrreg&quot;</span><span class="p">,</span><span class="s">&quot;Intr&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">     </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">HtmlGenerator</span><span class="p">(</span><span class="s">&quot;intrreg&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Interupt Example&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">     </span><span class="n">busif</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="nc">JsonGenerator</span><span class="p">(</span><span class="s">&quot;intrreg&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">     </span><span class="bp">this</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="bp">this</span><span class="p">.</span><span class="n">genDoc</span><span class="p">()</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><img alt="intc" src="_images/intc.jpeg" /></p>
</section>
<section id="id96">
<h3>五、开发区域(Developers Area)<a class="headerlink" href="#id96" title="Permalink to this heading"></a></h3>
<p>用户可以通过扩展BusIfVistor Trait来添加用户的文档类型。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Latex</span><span class="p">(</span><span class="n">fileName</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">BusIfVisitor</span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>BusIfVistor提供对BusIf.RegInsts的访问来实现用户所需的：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// lib/src/main/scala/lib/bus/regif/BusIfVistor.scala</span>

<span class="k">trait</span><span class="w">  </span><span class="nc">BusIfVisitor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">begin</span><span class="p">(</span><span class="n">busDataWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">visit</span><span class="p">(</span><span class="n">descr</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">FifoDescr</span><span class="p">)</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">visit</span><span class="p">(</span><span class="n">descr</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">RegDescr</span><span class="p">)</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">end</span><span class="p">()</span><span class="w">                     </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="id97">
<h2>总线(bus)<a class="headerlink" href="#id97" title="Permalink to this heading"></a></h2>
<section id="id98">
<h3>一、AHB-Lite3<a class="headerlink" href="#id98" title="Permalink to this heading"></a></h3>
<ol>
<li><p>配置与实例化(Configuration and instanciation)</p>
<p>首先，每次创建AHB-Lite3总线时，都需要一个配置对象。这个配置对象是一个<code class="docutils literal notranslate"><span class="pre">AhbLite3Config</span></code>，有以下参数:
|    参数名    | 类型  | 默认值 |         描述          |
| :———-: | :—: | :—-: | :——————-: |
| addressWidth |  Int  |        | HADDR的位宽(字节粒度) |
|  dataWidth   |  Int  |        | HWDATA和HRDATA的位宽  |</p>
<p>简而言之，在SpinalHDL库中AHB-Lite3总线是如下定义的:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">AhbLite3</span><span class="p">(</span><span class="n">config</span><span class="p">:</span><span class="w"> </span><span class="nc">AhbLite3Config</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//  地址和控制</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HADDR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">addressWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HSEL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HREADY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HWRITE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HSIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HBURST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HPROT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HTRANS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HMASTLOCK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="c1">//  数据</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HWDATA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HRDATA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//  传输回答</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HREADYOUT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">HRESP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="p">(</span><span class="nc">HADDR</span><span class="p">,</span><span class="nc">HWRITE</span><span class="p">,</span><span class="nc">HSIZE</span><span class="p">,</span><span class="nc">HBURST</span><span class="p">,</span><span class="nc">HPROT</span><span class="p">,</span><span class="nc">HTRANS</span><span class="p">,</span><span class="nc">HMASTLOCK</span><span class="p">,</span><span class="nc">HWDATA</span><span class="p">,</span><span class="nc">HREADY</span><span class="p">,</span><span class="nc">HSEL</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">in</span><span class="p">(</span><span class="nc">HREADYOUT</span><span class="p">,</span><span class="nc">HRESP</span><span class="p">,</span><span class="nc">HRDATA</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>简单的使用样例：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">ahbConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">AhbLite3Config</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">addressWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">dataWidth</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ahbX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">AhbLite3</span><span class="p">(</span><span class="n">ahbConfig</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ahbY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">AhbLite3</span><span class="p">(</span><span class="n">ahbConfig</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">ahbY</span><span class="p">.</span><span class="nc">HSEL</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="c1">//...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>变式(Variations)</p>
<p>有一个AhbLite3Master变体。唯一的区别是没有<code class="docutils literal notranslate"><span class="pre">HREADYOUT</span></code>信号。当互连线和从端口使用<code class="docutils literal notranslate"><span class="pre">AhbLite3</span></code>时，这个变式应该只被master使用。</p>
</li>
</ol>
</section>
<section id="id99">
<h3>二、Apb3<a class="headerlink" href="#id99" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>AMBA3-APB总线通常用于连接低带宽外设。</p>
</li>
<li><p>配置和实例化</p>
<p>首先，每次创建APB3总线时，都需要一个配置对象。这个配置对象是<code class="docutils literal notranslate"><span class="pre">Apb3Config</span></code>，有以下参数:
|    参数名     |  类型   | 默认值 |         描述          |
| :———–: | :—–: | :—-: | :——————-: |
| addressWidth  |   Int   |        | HADDR的位宽(字节粒度) |
|   dataWidth   |   Int   |        | PWDATA和PRDATA的位宽  |
|   selWidth    |   Int   |   1    |      PSEL的位宽       |
| useSlaveError | Boolean | false  |     指定PSLVERROR     |</p>
<p>简而言之，APB3总线在SpinalHDL库中定义的方式如下:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Apb3</span><span class="p">(</span><span class="n">config</span><span class="p">:</span><span class="w"> </span><span class="nc">Apb3Config</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PADDR</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">addressWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PSEL</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">selWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PENABLE</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PREADY</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PWRITE</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PWDATA</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PRDATA</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PSLVERROR</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">useSlaveError</span><span class="p">)</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="kc">null</span><span class="w"></span>
<span class="w">    </span><span class="c1">//...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>简单的使用样例：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">apbConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3Config</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">addressWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">dataWidth</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">apbX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3</span><span class="p">(</span><span class="n">apbConfig</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">apbY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3</span><span class="p">(</span><span class="n">apbConfig</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">apbY</span><span class="p">.</span><span class="nc">PENABLE</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="c1">//...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>函数和运算(Functions and operators)</p></li>
</ol>
<pre><code>| 参数名 | 返回  |            描述            |
| :----: | :---: | :------------------------: |
| X &gt;&gt; Y |       | 连接X到Y。Y的地址可以小于X |
| X &lt;&lt; Y |       |      做与&gt;&gt;相反的操作      |
</code></pre><p><h3>三、Axi4</h3></p>
<ol>
<li><p>简介</p>
<p>AXI4是ARM定义的高带宽总线</p>
</li>
<li><p>配置和实例化</p>
<p>首先，每次创建AXI4总线时，都需要一个配置对象。这个配置对象是一个<code class="docutils literal notranslate"><span class="pre">Axi4Config</span></code>，它有以下参数:
注意:useXXX 指定总线是否有 XXX 信号。</p>
</li>
</ol>
<pre><code>|    参数名    |  类型   | 默认值 |
| :----------: | :-----: | :----: |
| addressWidth |   Int   |        |
|  dataWidth   |   Int   |        |
|   idWidth    |   Int   |        |
|  userWidth   |   Int   |        |
|    useld     | Boolean |  true  |
|  useRegion   | Boolean |  true  |
|   useBurst   | Boolean |  true  |
|   useLock    | Boolean |  true  |
|   useCache   | Boolean |  true  |
|   useSize    | Boolean |  true  |
|    useQos    | Boolean |  true  |
|    useLen    | Boolean |  true  |
|   useLast    | Boolean |  true  |
|   useResp    | Boolean |  true  |
|   useProt    | Boolean |  true  |
|   useStrb    | Boolean |  true  |
|   useUser    | Boolean | false  |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>简而言之，SpinalHDL库中定义AXI4总线的方式如下:
```Scala
case class Axi4(config: Axi4Config) extends Bundle with IMasterSlave{
    val aw = Stream(Axi4Aw(config))
    val w  = Stream(Axi4W(config))
    val b  = Stream(Axi4B(config))
    val ar = Stream(Axi4Ar(config))
    val r  = Stream(Axi4R(config))

    override def asMaster(): Unit = {
        master(ar,aw,w)
        slave(r,b)
    }
}
```
简单的使用样例：
```Scala
val axiConfig = Axi4Config(
    addressWidth = 32,
    dataWidth    = 32,
    idWidth      = 4
)
    val axiX = Axi4(axiConfig)
    val axiY = Axi4(axiConfig)

    when(axiY.aw.valid){
    //...
}
```
</pre></div>
</div>
<ol>
<li><p>变式</p>
<p>Axi4总线有三个变式：</p>
</li>
</ol>
<pre><code>|     类型      |                                                                                                      描述                                                                                                      |
| :-----------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| Axi4ReadOnly  |                                                                                               只有AR和R通道存在                                                                                                |
| Axi4WriteOnly |                                                                                              只有AW、W和B通道存在                                                                                              |
|  Axi4Shared   | 这种变式是该库的首创。&lt;br&gt;它使用4个通道，W, B,R，还有一个名为AWR的新通道。&lt;br&gt;AWR通道可以用来传输AR和AW事务。要分离它们，需要一个信号`write`。&lt;br&gt;这种Axi4Shared变体的优点是使用更少的面积，尤其是在互连方面。 |
</code></pre><ol class="simple">
<li><p>函数与操作</p></li>
</ol>
<pre><code>|    参数名     |     返回      |                                     描述                                     |
| :-----------: | :-----------: | :--------------------------------------------------------------------------: |
|    X &gt;&gt; Y     |               | 连接X到Y。能够像AXI4规范中指定的那样推断默认值，并以安全的方式调整一些宽度。 |
|    X &lt;&lt; Y     |               |                               做与&gt;&gt;相反的操作                               |
| X.toWriteOnly | Axi4WriteOnly |                      返回一个由X驱动的Axi4WriteOnly总线                      |
| X.toReadOnly  | Axi4ReadOnly  |                      返回一个由X驱动的Axi4ReadOnly总线                       |
</code></pre></section>
<section id="id100">
<h3>四、AvalonMM<a class="headerlink" href="#id100" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>AvalonMM总线非常适合FPGA。它非常灵活:</p>
<ul class="simple">
<li><p>与APB一样简单</p></li>
<li><p>在许多需要带宽的应用程序中，比AHB表现更好，因为AvalonMM有一种模式，可以从命令中解耦读响应(减少延迟读延迟的影响)。</p></li>
<li><p>性能不如AXI，但使用的面积少得多(读写命令使用相同的握手通道。主端口不需要存储挂起请求的地址以避免读/写风险)</p></li>
</ul>
</li>
<li><p>配置和实例化</p>
<p>AvalonMM Bundle有一个构造参数<code class="docutils literal notranslate"><span class="pre">AvalonMMConfig</span></code>。由于Avalon总线的灵活性，<code class="docutils literal notranslate"><span class="pre">AvalonMMConfig</span></code>可以作为许多配置元素。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">AvalonMMConfig</span><span class="p">(</span><span class="w"> </span><span class="n">addressWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">dataWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">burstCountWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useByteEnable</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useDebugAccess</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useRead</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useWrite</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useResponse</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useLock</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useWaitRequestn</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useReadDataValid</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">useBurstCount</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="c1">//useEndOfPacket : Boolean,</span>

<span class="w">                       </span><span class="n">addressUnits</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">AddressUnits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">symbols</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">burstCountUnits</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">AddressUnits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">words</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">burstOnBurstBoundariesOnly</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">constantBurstBehavior</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">holdTime</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">linewrapBursts</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">maximumPendingReadTransactions</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">maximumPendingWriteTransactions</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// unlimited</span>
<span class="w">                       </span><span class="n">readLatency</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">readWaitTime</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">setupTime</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="n">writeWaitTime</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">                       </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>这样的配置类也有一些函数：
|       函数名       |      返回      |                   描述                   |
| :—————-: | :————: | :————————————–: |
| getReadOnlyConfig  | AvalonMMConfig | 返回一个类似的配置，但禁用所有写入属性。 |
| getWriteOnlyConfig | AvalonMMConfig |   返回一个类似的配置，但禁用所有读属性   |</p>
<p>这个配置对象也有一些函数来提供一些AvalonMMConfig模板:
|                     函数名                      |      返回      |                   描述                   |
| :———————————————: | :————: | :————————————–: |
|    fixed(addressWidth,dataWidth,readLatency)    | AvalonMMConfig |   返回一个具有固定读取时间的简单配置。   |
|        pipelined(addressWidth,dataWidth)        | AvalonMMConfig |        返回一个配置，读取延迟可变        |
| bursted(addressWidth,dataWidth,burstCountWidth) | AvalonMMConfig | 返回一个具有可变延迟读取和突发功能的配置 |</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">// 创建一个只写的AvalonMM配置，具有突发能力和字节使能</span>
<span class="kd">val</span><span class="w"> </span><span class="n">myAvalonConfig</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="nc">AvalonMMConfig</span><span class="p">.</span><span class="n">bursted</span><span class="p">(</span><span class="w"></span>
<span class="w">                    </span><span class="n">addressWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addressWidth</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">dataWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memDataWidth</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">burstCountWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">log2Up</span><span class="p">(</span><span class="n">burstSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="p">).</span><span class="n">copy</span><span class="p">(</span><span class="w"></span>
<span class="w">                    </span><span class="n">useByteEnable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">constantBurstBehavior</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">burstOnBurstBoundariesOnly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="w">                  </span><span class="p">).</span><span class="n">getWriteOnlyConfig</span><span class="w"></span>

<span class="c1">// 创建一个利用该配置的总线实例</span>
<span class="kd">val</span><span class="w"> </span><span class="n">bus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">AvalonMM</span><span class="p">(</span><span class="n">myAvalonConfig</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="id101">
<h2>Com<a class="headerlink" href="#id101" title="Permalink to this heading"></a></h2>
<section id="id102">
<h3>一、UART<a class="headerlink" href="#id102" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>可以使用UART协议来发出和接收RS232 / RS485帧。</p>
<p>有一个没有奇偶校验并拥有一个停止位的8位帧的例子:</p>
<p><img alt="uart" src="_images/uart.png" /></p>
</li>
<li><p>总线定义</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Uart</span><span class="p">()</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">txd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"> </span><span class="c1">// Used to emit frames</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">rxd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"> </span><span class="c1">// Used to receive frames</span>

<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="p">(</span><span class="n">txd</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">in</span><span class="p">(</span><span class="n">rxd</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>UartCtrl</p>
<p>库中实现了一个Uart控制器。这个控制器的特性是使用一个采样窗口来读取<code class="docutils literal notranslate"><span class="pre">rxd</span></code>引脚，然后使用多数投票制来过滤它的值。
| IO口名 |  方向  |      类型      |                       描述                        |
| :—-: | :—-: | :————: | :———————————————–: |
| config |   in   | UartCtrlConfig | 用于设置控制器的时钟分频器/奇偶校验/停止/数据长度 |
| write  | slave  |  Stream[Bits]  |          用于请求进行帧交换传输的流端口           |
|  read  | master |   Flow[Bits]   |              用于接收解码帧的流端口               |
| write  | master |      Uart      |               与实际实现的连接接口                |</p>
<p>控制器可以通过一个<code class="docutils literal notranslate"><span class="pre">UartCtrlGenerics</span></code>配置对象实例化:
|       属性        | 类型  |                         描述                         |
| :—————: | :—: | :————————————————–: |
|   dataWidthMax    |  Int  |                    帧内的最大位数                    |
| clockDividerWidth |  Int  |                 内部时钟分频器的位宽                 |
|  preSamplingSize  |  Int  |   指定有多少samplingTick在一个UART波特的起始处下降   |
|   samplingSize    |  Int  | 指定有多少samplingTick用于采样UART波特中段的<code class="docutils literal notranslate"><span class="pre">rxd</span></code>值  |
| postSamplingSize  |  Int  | 指定在一个UART波特值的末尾有多少个samplingTick被丢弃 |</p>
</li>
</ol>
</section>
<section id="id103">
<h3>二、USB设备<a class="headerlink" href="#id103" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>SpinalHDL库中有一个USB设备控制器。在以下几个要点中，它可以设置为:</p>
<ul class="simple">
<li><p>它允许CPU配置和管理端点</p></li>
<li><p>存储端点状态和事务描述符的内部RAM</p></li>
<li><p>多达16个端点(几乎没有额外开销)</p></li>
<li><p>支持USB主机全速运行(12Mbps)</p></li>
<li><p>在linux上使用自己的驱动程序进行测试(https://github.com/SpinalHDL/linux/blob/dev/drivers/usb/gadget/udc/spinal_udc.c)</p></li>
<li><p>用于配置的Bmb内存接口</p></li>
<li><p>内部需要一个频率是12Mhz的倍数的时钟，至少为48Mhz</p></li>
<li><p>控制器频率不受限制</p></li>
<li><p>不需要外部phy</p></li>
</ul>
<p>Linux小工具测试和功能:</p>
<ul class="simple">
<li><p>串行连接</p></li>
<li><p>以太网连接</p></li>
<li><p>大容量存储(在ArtyA7 linux上达到8mbps)</p></li>
</ul>
<p>部署：</p>
<ul class="simple">
<li><p>https://github.com/SpinalHDL/SaxonSoc/tree/dev-0.3/bsp/digilent/ArtyA7SmpLinux</p></li>
<li><p>https://github.com/SpinalHDL/SaxonSoc/tree/dev-0.3/bsp/radiona/ulx3s/smp</p></li>
</ul>
</li>
<li><p>架构(Architecture)</p>
<p>控制器由以下部分组成：</p>
<ul class="simple">
<li><p>少数控制寄存器</p></li>
<li><p>一个用来存储端点状态的内部RAM，一个传输描述符合端点0配置数据。</p></li>
</ul>
<p>每个端点的描述符链表是为了处理USB的出入任务和数据。</p>
<p>端点0也会像其他端点一样处理出入USB的交换任务但也会有一些额外的硬件来处理SETUP(设置)任务：</p>
<ul class="simple">
<li><p>它的链表在每个设置任务上被清除</p></li>
<li><p>设置任务的数据存储在一个固定的位置(SETUP_DATA)</p></li>
<li><p>它对设置任务有一个特定的中断标志</p></li>
</ul>
</li>
<li><p>寄存器(Registers)</p>
<p>注意，控制器的所有寄存器和内存只能以32位的字访问，不支持字节访问。</p>
<ul class="simple">
<li><p>帧FRAME (0xFF00)</p></li>
</ul>
</li>
</ol>
<pre><code>    |    名称    | 类型  | 比特  |      描述       |
    | :--------: | :---: | :---: | :-------------: |
    | usbFrameId |  RO   | 31-0  | 目前的usb帧的id |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">地址ADDRESS</span> <span class="p">(</span><span class="mh">0xFF04</span><span class="p">)</span>
</pre></div>
</div>
<pre><code>    |  名称   | 类型  | 比特  |                                   描述                                    |
    | :-----: | :---: | :---: | :-----------------------------------------------------------------------: |
    | address |  WO   |  6-0  | 该USB设备只会被特定地址的令牌(token)所控制。其字段会被usb重置任务自动清除 |
    | enable  |  WO   |   8   |                         如果设置，启用USB地址过滤                         |
    | trigger |  WO   |   9   |        设置下一个EP0 IN令牌使能(见上文)。在任何EP0完成后由硬件清除        |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    这里的想法是保持整个寄存器清空，直到EP0上接收到USB SET_ADDRESS设置包。此时，用户可以设置地址和触发器字段，然后向EP0提供IN零长度描述符，以结束SET_ADDRESS序列。然后，控制器将在描述符完成时自动打开地址过滤。

- 中断INTERRUPT (0xFF08)

    这个寄存器的所有位都可以通过写入“1”来清除。
    |    名称    | 类型  | 比特  |           描述            |
    | :--------: | :---: | :---: | :-----------------------: |
    | endpoints  |  RC   | 15-0  |   当端点产生中断时拉高    |
    |   reset    |  RC   |  16   |    当USB复位发生时拉高    |
    |  ep0Setup  |  RC   |  17   | 当端点0收到配置请求时拉高 |
    |  suspend   |  RC   |  18   |     当端点悬挂时拉高      |
    |   resume   |  RC   |  19   |     当端点恢复时拉高      |
    | disconnect |  RC   |  20   |   当端点连接中断时拉高    |

- Halt (0xFF0C)

    这个寄存器允许在休眠状态下放置一个端点，以确保CPU操作的原子性，允许对端点寄存器和描述符进行读/修改/写操作。如果给定的端点是由usb主机寻址的，外围设备将返回NAK。
</pre></div>
</div>
<pre><code>    |       名称       | 类型  | 比特  |                          描述                          |
    | :--------------: | :---: | :---: | :----------------------------------------------------: |
    |    endpointId    |  WO   |  3-0  |                 用户想要休眠的目标端点                 |
    |      enable      |  WO   |   4   |                                                        |
    | effective enable |  RO   |   5   | 在设置了使能后，需要等待硬件本身设置该位，以确保原子性 |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">配置CONFIG</span> <span class="p">(</span><span class="mh">0xFF10</span><span class="p">)</span>
</pre></div>
</div>
<pre><code>    |         名称         | 类型  | 比特  |                 描述                 |
    | :------------------: | :---: | :---: | :----------------------------------: |
    |      pullupSet       |  SO   |   0   | 写入' 1 '来启用dp引脚上的USB设备上拉 |
    |     pullupClear      |  SO   |   1   |                                      |
    |  interruptEnableSet  |  SO   |   2   |    写“1”，让现在和未来的中断发生     |
    | interruptEnableClear |  SO   |   3   |                                      |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">INFO</span> <span class="p">(</span><span class="mh">0xFF20</span><span class="p">)</span>
</pre></div>
</div>
<pre><code>    |  名称   | 类型  | 比特  |            描述            |
    | :-----: | :---: | :---: | :------------------------: |
    | ramSize |  RO   |  3-0  | 内部ram将有(1 &lt;&lt; this)字节 |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>- 端点 ENDPOINTS (0x0000 - 0x003F)

    端点状态存储在内部ram的开头，每个有32位字。
    |     名称      | 类型  | 比特  |                               描述                                |
    | :-----------: | :---: | :---: | :---------------------------------------------------------------: |
    |    enable     |  RW   |   0   |             若不设置，则该端点忽略所有的流量(traffic)             |
    |     stall     |  RW   |   1   |                 若设置了，端点将始终返回STALL状态                 |
    |     nack      |  RW   |   2   |                 若设置了，端点将始终返回NACK状态                  |
    |   dataPhase   |  RW   |   3   |  指定使用的IO数据PID。&#39; 0 &#39; = &gt; DATA0。这个字段也由控制器更新。   |
    |     head      |  RW   | 15-4  | 指定当前描述符头部(链表)0 =&gt; empty list, byte address = this &lt;&lt; 4 |
    |  isochronous  |  RW   |  16   | 指定当前描述符头部(链表)0 =&gt; empty list, byte address = this &lt;&lt; 4 |
    | maxPacketSize |  RW   | 31-22 |                                                                   |

    为了获得一个端点响应需要：设置其使能标志位为1.

    还有其他一些例子:要么用户有停滞或纳标记集,因此,控制器总是有相应的响应；要么EP0设置请求,控制器不会使用描述符,但将数据写入SETUP_DATA寄存器和ACK；要么用户有一个空链表(head==0)并响应NACK；要么用户至少有一个描述符由头部指出,在这种情况下将执行和ACK。

- SETUP_DATA (0x0040 - 0x0047)

    当端点0接收SETUP任务时，该任务的数据将存储在该位置
</pre></div>
</div>
<ol>
<li><p>描述符(Descriptors)</p>
<p>描述符允许指定端点需要如何处理IO传输任务的数据阶段。它们存储在内部ram中，可以通过它们的链表链接在一起，并且需要在16字节的边界上对齐.</p>
</li>
</ol>
<pre><code>|       名称        |  字   | 比特  |                                                               描述                                                                |
| :---------------: | :---: | :---: | :-------------------------------------------------------------------------------------------------------------------------------: |
|      offset       |   0   | 15-0  |                                                  指定当前传输进度(以字节为单位)                                                   |
|       code        |   0   | 19-16 |                                                0xF =&gt; in progress, 0x0 =&gt; success                                                 |
|       next        |   1   | 15-4  |                                      指定下一个传输符 0 =&gt; nothing, byte address = this &lt;&lt; 4                                      |
|      length       |   1   | 31-16 |                                                      为数据字段分配的字节数                                                       |
|     direction     |   2   |  16   |                                                       ‘0’ =&gt; OUT, ‘1’ =&gt; IN                                                       |
|     interrupt     |   2   |  17   |                                            如果设置了，则描述符的完成将生成一个中断。                                             |
| completionOnFull  |   2   |  18   | 通常，描述符补全只发生在USB传输小于maxPacketSize时。但是如果设置了这个字段，那么当描述符被填满时也被认为事件已完成。(抵消= =长度) |
| data1OnCompletion |   2   |  19   |                                                     强制端点dataphase为DATA1                                                      |
|       data        |  ...  |  ...  |                                                                                                                                   |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>注意，如果控制器接收到一个帧，其中IO不匹配描述符IO，该帧将被忽略。

另外，要初始化描述符，CPU应该将代码字段设置为0xF.
</pre></div>
</div>
<ol>
<li><p>使用(usage)</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">bus</span><span class="p">.</span><span class="nn">bmb</span><span class="p">.</span><span class="nc">BmbParameter</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">com</span><span class="p">.</span><span class="nn">usb</span><span class="p">.</span><span class="nn">phy</span><span class="p">.</span><span class="nc">UsbDevicePhyNative</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">com</span><span class="p">.</span><span class="nn">usb</span><span class="p">.</span><span class="nn">sim</span><span class="p">.</span><span class="nc">UsbLsFsPhyAbstractIoAgent</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="nn">com</span><span class="p">.</span><span class="nn">usb</span><span class="p">.</span><span class="nn">udc</span><span class="p">.{</span><span class="nc">UsbDeviceCtrl</span><span class="p">,</span><span class="w"> </span><span class="nc">UsbDeviceCtrlParameter</span><span class="p">}</span>


<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">UsbDeviceTop</span><span class="p">()</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ctrlCd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">external</span><span class="p">(</span><span class="s">&quot;ctrlCd&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">frequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">FixedFrequency</span><span class="p">(</span><span class="mi">100</span><span class="w"> </span><span class="nc">MHz</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">phyCd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">external</span><span class="p">(</span><span class="s">&quot;phyCd&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">frequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">FixedFrequency</span><span class="p">(</span><span class="mi">48</span><span class="w"> </span><span class="nc">MHz</span><span class="p">))</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">ctrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctrlCd</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">UsbDeviceCtrl</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UsbDeviceCtrlParameter</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">addressWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">14</span><span class="w"></span>
<span class="w">        </span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">bmbParameter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BmbParameter</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">addressWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UsbDeviceCtrl</span><span class="p">.</span><span class="n">ctrlAddressWidth</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">dataWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">sourceWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">contextWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">lengthWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">        </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">phy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">phyCd</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">UsbDevicePhyNative</span><span class="p">(</span><span class="n">sim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">)</span><span class="w"></span>
<span class="n">ctrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">cc</span><span class="p">(</span><span class="n">ctrlCd</span><span class="p">,</span><span class="w"> </span><span class="n">phyCd</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">phy</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">ctrl</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">bmb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">toIo</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">usb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">phy</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">usb</span><span class="p">.</span><span class="n">toIo</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">power</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">phy</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">toIo</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">pullup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">phy</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">pullup</span><span class="p">.</span><span class="n">toIo</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">interrupts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">interrupt</span><span class="p">.</span><span class="n">toIo</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">object</span><span class="w"> </span><span class="nc">UsbDeviceGen</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">App</span><span class="p">{</span><span class="w"></span>
<span class="nc">SpinalVerilog</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">UsbDeviceTop</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="id104">
<h2>IO口<a class="headerlink" href="#id104" title="Permalink to this heading"></a></h2>
<section id="id105">
<h3>一、ReadableOpenDrain<a class="headerlink" href="#id105" title="Permalink to this heading"></a></h3>
<p>ReadableOpenDrain包的定义如下:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ReadableOpenDrain</span><span class="p">[</span><span class="nc">T</span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">dataType</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">HardType</span><span class="p">[</span><span class="nc">T</span><span class="p">])</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="n">read</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dataType</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">out</span><span class="p">(</span><span class="n">write</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">in</span><span class="p">(</span><span class="n">read</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>然后，作为主端口，可以使用<code class="docutils literal notranslate"><span class="pre">read</span></code>信号读取外部值，并使用<code class="docutils literal notranslate"><span class="pre">write</span></code>信号设置用户希望在输出上驱动的值。</p>
<p>这里有一个使用例子:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">dataBus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">ReadableOpenDrain</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x12345678</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">read</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">42</span><span class="p">){</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="id106">
<h3>二、三态(Tristate)<a class="headerlink" href="#id106" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>三态信号在很多情况下处理起来都很奇怪:</p>
<ul class="simple">
<li><p>它们不满足真正的数字性</p></li>
<li><p>除了IO，它们不用于数字设计</p></li>
<li><p>三态概念不适合SpinalHDL内部图。</p></li>
</ul>
<p>SpinalHDL为三态信号提供了两种不同的抽象。<code class="docutils literal notranslate"><span class="pre">TriState</span></code>包和<code class="docutils literal notranslate"><span class="pre">analog</span> <span class="pre">and</span> <span class="pre">inout</span></code>信号。两者都有不同的目的:</p>
<ul class="simple">
<li><p>三态应用于大多数目的，特别是在设计中。包包含一个额外的信号来传递当前的方向。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">analog</span> <span class="pre">and</span> <span class="pre">inout</span></code>应该用于设备边界上的驱动程序和其他一些特殊情况。请参阅参考文档页了解更多细节。</p></li>
</ul>
<p>如上所述，推荐的方法是在设计中使用<code class="docutils literal notranslate"><span class="pre">TriState</span></code>。然后在顶层文件中，将<code class="docutils literal notranslate"><span class="pre">TriState</span></code>包分配给一个<code class="docutils literal notranslate"><span class="pre">analog</span> <span class="pre">and</span> <span class="pre">inout</span></code>口，以获得综合工具来推断正确的I/O驱动程序。这可以通过InOutWrapper自动完成，也可以根据需要手动完成。</p>
</li>
<li><p>三态</p>
<p><code class="docutils literal notranslate"><span class="pre">TriState</span></code>定义如下;</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">TriState</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">dataType</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">HardType</span><span class="p">[</span><span class="nc">T</span><span class="p">])</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">read</span><span class="p">,</span><span class="n">write</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dataType</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">writeEnable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="p">(</span><span class="n">write</span><span class="p">,</span><span class="n">writeEnable</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">in</span><span class="p">(</span><span class="n">read</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>主端口可以使用<code class="docutils literal notranslate"><span class="pre">read</span></code>信号来读取外部值，<code class="docutils literal notranslate"><span class="pre">writeEnable</span></code>来启用输出，最后使用<code class="docutils literal notranslate"><span class="pre">write</span></code>来设置输出驱动的值。</p>
<p>使用样例：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">dataBus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">TriState</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">writeEnable</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x12345678</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">read</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">42</span><span class="p">){</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>三态阵列(TriStateArray)</p>
<p>在某些情况下，用户需要控制每个单独的引脚的输出启用(就像GPIO一样)。在这种情况下，可以使用TriStateArray包。</p>
<p>其定义如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">TriStateArray</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">BitCount</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">read</span><span class="p">,</span><span class="n">write</span><span class="p">,</span><span class="n">writeEnable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">width</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="p">(</span><span class="n">write</span><span class="p">,</span><span class="n">writeEnable</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">in</span><span class="p">(</span><span class="n">read</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>它与TriState包相同，不同的是<code class="docutils literal notranslate"><span class="pre">writeEnable</span></code>是一个Bits来控制每个输出缓冲区。</p>
<p>使用样例：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">dataBus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">TriStateArray</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">writeEnable</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x87654321</span><span class="w"></span>
<span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mh">0x12345678</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">dataBus</span><span class="p">.</span><span class="n">read</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">42</span><span class="p">){</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="id107">
<h2>图形(Graphics)<a class="headerlink" href="#id107" title="Permalink to this heading"></a></h2>
<section id="id108">
<h3>一、颜色<a class="headerlink" href="#id108" title="Permalink to this heading"></a></h3>
<ol>
<li><p>RGB</p>
<p>用户可以使用Rgb包在硬件中建模颜色。这个Rgb包使用RgbConfig类作为参数并指定每个通道的比特数:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">RgbConfig</span><span class="p">(</span><span class="n">rWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="n">gWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="n">bWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">getWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rWidth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">gWidth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bWidth</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Rgb</span><span class="p">(</span><span class="n">c</span><span class="p">:</span><span class="w"> </span><span class="nc">RgbConfig</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">rWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">gWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">bWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这些类可以按如下使用：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RgbConfig</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Rgb</span><span class="p">(</span><span class="n">config</span><span class="p">)</span><span class="w"></span>
<span class="n">color</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">31</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="id109">
<h3>二、VGA<a class="headerlink" href="#id109" title="Permalink to this heading"></a></h3>
<ol>
<li><p>VGA总线</p>
<p>VGA总线通过VGA包定义：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Vga</span><span class="w"> </span><span class="p">(</span><span class="n">rgbConfig</span><span class="p">:</span><span class="w"> </span><span class="nc">RgbConfig</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">vSync</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">hSync</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">colorEn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w">  </span><span class="c1">//High when the frame is inside the color area</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Rgb</span><span class="p">(</span><span class="n">rgbConfig</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">asOutput</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>VGA时序(timings)</p>
<p>VGA时序可以通过使用VgaTimings包在硬件中建模:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">VgaTimingsHV</span><span class="p">(</span><span class="n">timingsWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">colorStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">timingsWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">colorEnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">timingsWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">syncStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">timingsWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">syncEnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">timingsWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">VgaTimings</span><span class="p">(</span><span class="n">timingsWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">VgaTimingsHV</span><span class="p">(</span><span class="n">timingsWidth</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">VgaTimingsHV</span><span class="p">(</span><span class="n">timingsWidth</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">setAs_h640_v480_r60</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">driveFrom</span><span class="p">(</span><span class="n">busCtrl</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">BusSlaveFactory</span><span class="p">,</span><span class="n">baseAddress</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>VGA控制器</p>
<p>VGA控制器的定义如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">VgaCtrl</span><span class="p">(</span><span class="n">rgbConfig</span><span class="p">:</span><span class="w"> </span><span class="nc">RgbConfig</span><span class="p">,</span><span class="w"> </span><span class="n">timingsWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">softReset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">timings</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nc">VgaTimings</span><span class="p">(</span><span class="n">timingsWidth</span><span class="p">))</span><span class="w"></span>

<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">frameStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">pixels</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="w"> </span><span class="p">(</span><span class="nc">Rgb</span><span class="p">(</span><span class="n">rgbConfig</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">vga</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">Vga</span><span class="p">(</span><span class="n">rgbConfig</span><span class="p">))</span><span class="w"></span>

<span class="w">        </span><span class="kd">val</span><span class="w"> </span><span class="n">error</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">frameStart</span></code>是一个信号，在每一帧的开始脉冲一个周期。</p>
<p><code class="docutils literal notranslate"><span class="pre">pixels</span></code>是一种色彩流，用于在需要时提供给VGA接口。</p>
<p>当需要对像素进行传输但没有对象时，<code class="docutils literal notranslate"><span class="pre">error</span></code>会拉高。</p>
</li>
</ol>
</section>
</section>
<section id="id110">
<h2>自动设计工具(EDA)<a class="headerlink" href="#id110" title="Permalink to this heading"></a></h2>
<section id="id111">
<h3>一、QSysify<a class="headerlink" href="#id111" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>QSysify是一个可以从SpinalHDL组件通过分析其IO定义生成QSys IP (tcl脚本)的工具。目前实现了以下接口特性:</p>
<ul class="simple">
<li><p>Master/Slave AvalonMM</p></li>
<li><p>Master/Slave APB3</p></li>
<li><p>时钟域输入</p></li>
<li><p>复位输出</p></li>
<li><p>中断输入</p></li>
<li><p>导线</p></li>
</ul>
</li>
<li><p>例子</p>
<p>以UART控制器为例;</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">AvalonMMUartCtrl</span><span class="p">(...)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">bus</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">slave</span><span class="p">(</span><span class="nc">AvalonMM</span><span class="p">(</span><span class="nc">AvalonMMUartCtrl</span><span class="p">.</span><span class="n">getAvalonMMConfig</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">uart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">Uart</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">//...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>下面的<code class="docutils literal notranslate"><span class="pre">main</span></code>将使用io.bus和io.uart生成Verilog和QSys TCL脚本:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">AvalonMMUartCtrl</span><span class="p">{</span><span class="w"></span>
<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//生成verilog</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">toplevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SpinalVerilog</span><span class="p">(</span><span class="nc">AvalonMMUartCtrl</span><span class="p">(</span><span class="nc">UartCtrlMemoryMappedConfig</span><span class="p">(...))).</span><span class="n">toplevel</span><span class="w"></span>

<span class="w">    </span><span class="c1">//对avalon总线添加标志位并指明时钟域</span>
<span class="w">    </span><span class="n">toplevel</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">bus</span><span class="w"> </span><span class="n">addTag</span><span class="p">(</span><span class="nc">ClockDomainTag</span><span class="p">(</span><span class="n">toplevel</span><span class="p">.</span><span class="n">clockDomain</span><span class="p">))</span><span class="w"></span>

<span class="w">    </span><span class="c1">//利用tcl脚本生成QSysIP</span>
<span class="w">    </span><span class="nc">QSysify</span><span class="p">(</span><span class="n">toplevel</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>标志(tags)</p>
<p>因为QSys需要SpinalHDL硬件规范中没有指定的一些信息，所以应该向接口添加一些标记:</p>
<ul class="simple">
<li><p>AvalonMM / APB3</p></li>
</ul>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">io</span><span class="p">.</span><span class="n">bus</span><span class="w"> </span><span class="n">addTag</span><span class="p">(</span><span class="nc">ClockDomainTag</span><span class="p">(</span><span class="n">busClockDomain</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>中断输入(Interrupt input)</p></li>
</ul>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">io</span><span class="p">.</span><span class="n">interrupt</span><span class="w"> </span><span class="n">addTag</span><span class="p">(</span><span class="nc">InterruptReceiverTag</span><span class="p">(</span><span class="n">relatedMemoryInterfacei</span><span class="p">,</span><span class="w"> </span><span class="n">interruptClockDomain</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>重置输出(Reset output)</p></li>
</ul>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">io</span><span class="p">.</span><span class="n">resetOutput</span><span class="w"> </span><span class="n">addTag</span><span class="p">(</span><span class="nc">ResetEmitterTag</span><span class="p">(</span><span class="n">resetOutputClockDomain</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>添加新的接口支持(Adding new interface support)</p>
<p>基本上，QSysify工具可以通过一个接口<code class="docutils literal notranslate"><span class="pre">emitter</span></code>列表来设置。</p>
<p>用户可以通过创建一个扩展QSysifyInterfaceEmiter的新类来创建自己的发射器。</p>
</li>
</ol>
</section>
<section id="id112">
<h3>二、QuartusFlow<a class="headerlink" href="#id112" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>编译流是altera定义的命令序列，它使用命令行可执行文件的组合。完整的编译流按顺序启动所有编译器模块，以综合、匹配、分析最终的时序，并生成编程文件。</p>
<p>这个文件中的工具可以帮助消除冗余的Quartus GUI。</p>
</li>
<li><p>对于单个rtl文件</p>
<p>对象<code class="docutils literal notranslate"><span class="pre">spinal.lib.eda.altera.QuartusFlow</span></code>可以自动报告单个rtl文件的使用面积和最大频率。</p>
<p>例如:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">report</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">QuartusFlow</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">quartusPath</span><span class="o">=</span><span class="s">&quot;/eda/intelFPGA_lite/17.0/quartus/bin/&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">workspacePath</span><span class="o">=</span><span class="s">&quot;/home/spinalvm/tmp&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">toplevelPath</span><span class="o">=</span><span class="s">&quot;TopLevel.vhd&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">family</span><span class="o">=</span><span class="s">&quot;Cyclone V&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">device</span><span class="o">=</span><span class="s">&quot;5CSEMA5F31C6&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">frequencyTarget</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nc">MHz</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="n">println</span><span class="p">(</span><span class="n">report</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>上面的代码将使用<code class="docutils literal notranslate"><span class="pre">topllevel.vhd</span></code>创建一个新的Quartus项目。</p>
<blockquote>
<div><p><strong>警告：该操作将移除<code class="docutils literal notranslate"><span class="pre">workspacePath</span></code>文件夹</strong></p>
</div></blockquote>
<blockquote>
<div><p><strong>注意：<code class="docutils literal notranslate"><span class="pre">family</span></code>和<code class="docutils literal notranslate"><span class="pre">devbice</span></code>值直接作为参数传递给Quartus CLI。请检查Quartus文档，以确定要在项目中使用的正确值。</strong></p>
</div></blockquote>
<p>小贴士：</p>
<p>为了测试含有多个引脚的组件，请将它们设置为<code class="docutils literal notranslate"><span class="pre">VIRTUAL_PIN</span></code>。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">miaou</span><span class="p">:</span><span class="w"> </span><span class="nc">Vec</span><span class="p">[</span><span class="nc">Flow</span><span class="p">[</span><span class="nc">Bool</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="n">master</span><span class="p">(</span><span class="nc">Flow</span><span class="p">(</span><span class="nc">Bool</span><span class="p">())),</span><span class="w"> </span><span class="mi">666</span><span class="p">)</span><span class="w"></span>
<span class="n">miaou</span><span class="p">.</span><span class="n">addAttribute</span><span class="p">(</span><span class="s">&quot;altera_attribute&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;-name VIRTUAL_PIN ON&quot;</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="id113">
<h3>三、对于一个已存在的项目(For an existing project)<a class="headerlink" href="#id113" title="Permalink to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spinal.lib.eda.altera.QuartusProject</span></code>类可以自动查找现有项目中的配置文件。它们用于对设备进行编译和编程。</p>
<p>例如：
指定包含项目文件(如.qpf和.cdf)的路径。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">prj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">QuartusProject</span><span class="p">(</span><span class="w"></span>
<span class="w">   </span><span class="n">quartusPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;F:/intelFPGA_lite/20.1/quartus/bin64/&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">workspacePath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;G:/&quot;</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="n">prj</span><span class="p">.</span><span class="n">compile</span><span class="p">()</span><span class="w"></span>
<span class="n">prj</span><span class="p">.</span><span class="n">program</span><span class="p">()</span><span class="w">  </span><span class="c1">// 自动寻找项目的链表描述文件</span>
</pre></div>
</div>
<blockquote>
<div><p><strong>重要：请记住调用<code class="docutils literal notranslate"><span class="pre">prj.program()</span></code>前保存项目的<code class="docutils literal notranslate"><span class="pre">.cdf</span></code>文件</strong></p>
</div></blockquote>
</section>
</section>
<section id="id114">
<h2>Misc<a class="headerlink" href="#id114" title="Permalink to this heading"></a></h2>
<section id="id115">
<h3>一、Plic映射器<a class="headerlink" href="#id115" title="Permalink to this heading"></a></h3>
<p>PLIC映射器定义了PLIC(平台级中断控制器)的寄存器生成和访问。</p>
<ol>
<li><p><code class="docutils literal notranslate"><span class="pre">PlicMapper.apply</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">(bus:</span> <span class="pre">BusSlaveFactory,</span> <span class="pre">mapping:</span> <span class="pre">PlicMapping)(gateways</span> <span class="pre">:</span> <span class="pre">Seq[PlicGateway],</span> <span class="pre">targets</span> <span class="pre">:</span> <span class="pre">Seq[PlicTarget])</span></code></p>
<p>PlicMapper参数:</p>
<ul class="simple">
<li><p>总线:连接此控制的总线</p></li>
<li><p>映射:一个映射配置(参见上面)</p></li>
<li><p>网关:用于生成总线访问控制的PlicGateway(中断源)序列</p></li>
<li><p>目标: 生成总线访问控制的PlicTarget的序列(如:多核)</p></li>
</ul>
<p>它遵循由riscv给出的接口:https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic.adoc</p>
<p>到目前为止，有两个内存映射可用:</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">PlicMapping.sifive</span></code></p>
<p>遵循SiFive PLIC映射(例如。E31核心复合手册)，基本上是一个成熟的PLIC</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">PlicMapping.light</span></code></p>
<p>这种映射以丢失一些可选特性为代价，产生了一个更轻量级的PLIC:</p>
<ul class="simple">
<li><p>不读取中断的优先级</p></li>
<li><p>不读取中断的悬挂位(必须使用claim/complete机制)</p></li>
<li><p>不读取目标的阈值</p></li>
</ul>
<p>剩下的寄存器和逻辑被生成。</p>
</li>
</ol>
<div STYLE="page-break-after: always;"></div></section>
</section>
</section>
<section id="id116">
<h1>例子(Examples)<a class="headerlink" href="#id116" title="Permalink to this heading"></a></h1>
<section id="id117">
<h2>简单的实例<a class="headerlink" href="#id117" title="Permalink to this heading"></a></h2>
<section id="id118">
<h3>一、APB3<a class="headerlink" href="#id118" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>该例子将会展示定义APB3类的语句。</p>
</li>
<li><p>规范</p>
<p>ARM关于APB3的端口规范如下：
| 信号名称  |         类型         | 驱动端 |       描述       |
| :——-: | :——————: | :—-: | :————–: |
|   PADDR   |   UInt(位宽 bits)    | Master | 字节为单位的地址 |
|   PSEL    |    Bits(selWidth)    | Master |   每个从端1bit   |
|  PENABLE  |         Bool         | Master |                  |
|  PWRITE   |         Bool         | Master |                  |
|  PWDATA   | Bits(dataWidth bits) | Master |                  |
|  PREADY   |         Bool         | Slave  |                  |
|  PRDATA   | Bits(dataWidth bits) | Slave  |                  |
| PSLVERROR |         Bool         | Slave  |       可选       |</p>
</li>
<li><p>实现</p>
<p>上述规范说明APB3总线有许多可能的配置。为了实现多样的配置，我们可以在Scala中定义一个配置类：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Apb3Config</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">addressWidth</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">dataWidth</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">selWidth</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">useSlaveError</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>随后我们可以定义用来表示硬件总线的APB3类：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Apb3</span><span class="p">(</span><span class="n">config</span><span class="p">:</span><span class="w"> </span><span class="nc">Apb3Config</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">PADDR</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">addressWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">PSEL</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">selWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">PENABLE</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">PREADY</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">PWRITE</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">PWDATA</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">PRDATA</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">PSLVERROR</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">useSlaveError</span><span class="p">)</span><span class="w"> </span><span class="nc">Bool</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="kc">null</span><span class="w"></span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">out</span><span class="p">(</span><span class="nc">PADDR</span><span class="p">,</span><span class="nc">PSEL</span><span class="p">,</span><span class="nc">PENABLE</span><span class="p">,</span><span class="nc">PWRITE</span><span class="p">,</span><span class="nc">PWDATA</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">in</span><span class="p">(</span><span class="nc">PREADY</span><span class="p">,</span><span class="nc">PRDATA</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">useSlaveError</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nc">PSLVERROR</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>应用(Usage)</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">apbConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3Config</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">addressWidth</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">dataWidth</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">selWidth</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">useSlaveError</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">apb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">Apb3</span><span class="p">(</span><span class="n">apbConfig</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="p">.</span><span class="nc">PREADY</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="p">.</span><span class="nc">PSEL</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">apb</span><span class="p">.</span><span class="nc">PENABLE</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="c1">//...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>上述代码比较简陋，个人编写了一个简单的APB3的Slave端总线挂一个寄存堆的代码，如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">package</span><span class="w"> </span><span class="nc">Apb3</span>

<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="n">_</span><span class="w">   </span><span class="c1">// 使用IMasterSlave需要调用lib库</span>

<span class="k">import</span><span class="w"> </span><span class="nn">scala</span><span class="p">.</span><span class="nn">math</span><span class="p">.</span><span class="n">_</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Apb3Slave</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">APB3Config</span><span class="p">(</span><span class="n">addressWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">dataWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">selWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">useSlaveError</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">)</span><span class="w"> </span><span class="c1">// APB3总线的参数配置</span>


<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">APB3</span><span class="w"> </span><span class="p">(</span><span class="kd">val</span><span class="w"> </span><span class="n">config</span><span class="p">:</span><span class="w"> </span><span class="nc">APB3Config</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PADDR</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">addressWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PSEL</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">selWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PENABLE</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PREADY</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PWRITE</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PWDATA</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PRDATA</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="nc">PSLVERROR</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">useSlaveError</span><span class="p">)</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="kc">null</span><span class="w">   </span><span class="c1">// 只有当配置中的useSlaveError为真时才生成该端口</span>

<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">()</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="p">(</span><span class="nc">PADDR</span><span class="p">,</span><span class="nc">PSEL</span><span class="p">,</span><span class="nc">PENABLE</span><span class="p">,</span><span class="nc">PWRITE</span><span class="p">,</span><span class="nc">PWDATA</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">in</span><span class="p">(</span><span class="nc">PREADY</span><span class="p">,</span><span class="nc">PRDATA</span><span class="p">)</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">useSlaveError</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nc">PSLVERROR</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 使用asMaster的好处在于，asSlave直接就默认是Master端口的反面</span>



<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">apbConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">APB3Config</span><span class="p">(</span><span class="n">addressWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="n">dataWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="n">selWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">useSlaveError</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="c1">// 用户配置参数</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">slaveBus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">APB3</span><span class="p">(</span><span class="n">apbConfig</span><span class="p">))</span><span class="w"> </span><span class="c1">// 定义总线的slave端</span>
<span class="w">    </span><span class="c1">//val masterBus = master(APB3(apbConfig))// 定义总线的master端，不知道为何，用asMater定义，无法使用io.masterBus.PADDR表述</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">slaveBus</span><span class="p">.</span><span class="nc">PREADY</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">num</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">slaveBus</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">addressWidth</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">mem</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="nc">Mem</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">slaveBus</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">dataWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="n">num</span><span class="p">.</span><span class="n">toInt</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">mem</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">enable</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">slaveBus</span><span class="p">.</span><span class="nc">PSEL</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">slaveBus</span><span class="p">.</span><span class="nc">PWRITE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">slaveBus</span><span class="p">.</span><span class="nc">PADDR</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">slaveBus</span><span class="p">.</span><span class="nc">PWDATA</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">slaveBus</span><span class="p">.</span><span class="nc">PRDATA</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">mem</span><span class="p">.</span><span class="n">readSync</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">enable</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">slaveBus</span><span class="p">.</span><span class="nc">PSEL</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">slaveBus</span><span class="p">.</span><span class="nc">PENABLE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">slaveBus</span><span class="p">.</span><span class="nc">PADDR</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
<span class="k">object</span><span class="w"> </span><span class="nc">Apb3SlaveInst</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nc">SpinalVerilog</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">Apb3Slave</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>生成的Verilog代码为：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// Generator : SpinalHDL v1.6.0    git head : 73c8d8e2b86b45646e9d0b2e729291f2b65e6be3</span>
<span class="c1">// Component : Apb3Slave</span>
<span class="k">module</span><span class="w"> </span><span class="n">Apb3Slave</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_slaveBus_PADDR</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_slaveBus_PSEL</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_slaveBus_PENABLE</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">io_slaveBus_PREADY</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_slaveBus_PWRITE</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_slaveBus_PWDATA</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_slaveBus_PRDATA</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_mem_port1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_mem_port</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_io_slaveBus_PRDATA</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">15</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_mem_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_slaveBus_PSEL</span><span class="p">[</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">io_slaveBus_PWRITE</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">_zz_mem_port</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">mem</span><span class="p">[</span><span class="n">io_slaveBus_PADDR</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_slaveBus_PWDATA</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">_zz_io_slaveBus_PRDATA</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">_zz_mem_port1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">mem</span><span class="p">[</span><span class="n">io_slaveBus_PADDR</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_slaveBus_PREADY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_io_slaveBus_PRDATA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_slaveBus_PSEL</span><span class="p">[</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">io_slaveBus_PENABLE</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_slaveBus_PRDATA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_mem_port1</span><span class="p">;</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="carry-adder">
<h3>二、进位加法器(Carry Adder)<a class="headerlink" href="#carry-adder" title="Permalink to this heading"></a></h3>
<p>该示例定义了一个具有输入<code class="docutils literal notranslate"><span class="pre">a</span></code>和<code class="docutils literal notranslate"><span class="pre">b</span></code>以及<code class="docutils literal notranslate"><span class="pre">result</span></code>输出的组件。在任何时候，结果都是<code class="docutils literal notranslate"><span class="pre">a</span></code>和<code class="docutils literal notranslate"><span class="pre">b</span></code>(组合逻辑)的和。这个求和是由进位加法器完成的。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CarryAdder</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w">      </span><span class="c1">//result = a + b</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">False</span><span class="w">                   </span><span class="c1">//Carry, like a VHDL variable</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//Create some intermediate value in the loop scope.</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">//The carry adder&#39;s asynchronous logic</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">^</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">^</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="w"> </span><span class="o">\=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="n">&amp;</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w">    </span><span class="c1">//variable assignment</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">object</span><span class="w"> </span><span class="nc">CarryAdderProject</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nc">SpinalVhdl</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">CarryAdder</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>会生成如下代码:</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// Generator : SpinalHDL v1.6.0    git head : 73c8d8e2b86b45646e9d0b2e729291f2b65e6be3</span>
<span class="c1">// Component : CarryAdder</span>



<span class="k">module</span><span class="w"> </span><span class="n">CarryAdder</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_a</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_b</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_result</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">c_4</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">c_3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">c_2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">c_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_c_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_c_1_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_c_2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_c_2_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_c_3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_c_3_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_c_4</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_c_4_1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">c_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_3</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">c_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">_zz_c_4</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">_zz_c_4_1</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_c_4</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c_3</span><span class="p">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_c_4_1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c_3</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">c_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">c_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">_zz_c_3</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">_zz_c_3_1</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_c_3</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c_2</span><span class="p">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_c_3_1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c_2</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">c_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">c_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">_zz_c_2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">_zz_c_2_1</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_c_2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c_1</span><span class="p">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_c_2_1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c_1</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">c_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">c_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">_zz_c_1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">_zz_c_1_1</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_c_1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="p">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_c_1_1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_c_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_a</span><span class="p">[</span><span class="mh">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_c_1_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_b</span><span class="p">[</span><span class="mh">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_result</span><span class="p">[</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">_zz_c_1</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">_zz_c_1_1</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_result</span><span class="p">[</span><span class="mh">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">_zz_c_2</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">_zz_c_2_1</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">c_1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_result</span><span class="p">[</span><span class="mh">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">_zz_c_3</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">_zz_c_3_1</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">c_2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">io_result</span><span class="p">[</span><span class="mh">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">_zz_c_4</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">_zz_c_4_1</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">c_3</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_c_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_a</span><span class="p">[</span><span class="mh">1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_c_2_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_b</span><span class="p">[</span><span class="mh">1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_c_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_a</span><span class="p">[</span><span class="mh">2</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_c_3_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_b</span><span class="p">[</span><span class="mh">2</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_c_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_a</span><span class="p">[</span><span class="mh">3</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_c_4_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io_b</span><span class="p">[</span><span class="mh">3</span><span class="p">];</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="color-summing">
<h3>三、颜色求和(Color Summing)<a class="headerlink" href="#color-summing" title="Permalink to this heading"></a></h3>
<p>首先，定义一个带有加法的Color <code class="docutils literal notranslate"><span class="pre">Bundle</span></code>。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Color</span><span class="p">(</span><span class="n">channelWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">channelWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">channelWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">channelWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">+</span><span class="p">(</span><span class="n">that</span><span class="p">:</span><span class="w"> </span><span class="nc">Color</span><span class="p">):</span><span class="w"> </span><span class="nc">Color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Color</span><span class="p">(</span><span class="n">channelWidth</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="n">r</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">g</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">g</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="n">g</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="n">b</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">clear</span><span class="p">():</span><span class="w"> </span><span class="nc">Color</span><span class="w"> </span><span class="o">=</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">this</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="bp">this</span><span class="p">.</span><span class="n">g</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="bp">this</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="bp">this</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>然后，定义一个带<code class="docutils literal notranslate"><span class="pre">source</span></code>输入(颜色向量)和输出<code class="docutils literal notranslate"><span class="pre">result</span></code>(<code class="docutils literal notranslate"><span class="pre">source</span></code>输入之和)的组件。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ColorSumming</span><span class="p">(</span><span class="n">sourceCount</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">channelWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">sources</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="nc">Color</span><span class="p">(</span><span class="n">channelWidth</span><span class="p">),</span><span class="w"> </span><span class="n">sourceCount</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">Color</span><span class="p">(</span><span class="n">channelWidth</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Color</span><span class="p">(</span><span class="n">channelWidth</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">sum</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">sourceCount</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">\=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">sources</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">sum</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>总的SpinalHDL代码为：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">package</span><span class="w"> </span><span class="nc">ColorSumming</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="n">_</span>
<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Color</span><span class="p">(</span><span class="n">channelWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">channelWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">channelWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">channelWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">+</span><span class="p">(</span><span class="n">that</span><span class="p">:</span><span class="w"> </span><span class="nc">Color</span><span class="p">):</span><span class="w"> </span><span class="nc">Color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Color</span><span class="p">(</span><span class="n">channelWidth</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="n">r</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">g</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">g</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="n">g</span><span class="w"></span>
<span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="bp">this</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="n">b</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">clear</span><span class="p">():</span><span class="w"> </span><span class="nc">Color</span><span class="w"> </span><span class="o">=</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">this</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="bp">this</span><span class="p">.</span><span class="n">g</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="bp">this</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="bp">this</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">ColorSumming</span><span class="p">(</span><span class="n">sourceCount</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"> </span><span class="n">channelWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">sources</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Vec</span><span class="p">(</span><span class="nc">Color</span><span class="p">(</span><span class="n">channelWidth</span><span class="p">),</span><span class="w"> </span><span class="n">sourceCount</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">(</span><span class="nc">Color</span><span class="p">(</span><span class="n">channelWidth</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Color</span><span class="p">(</span><span class="n">channelWidth</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">sum</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">sourceCount</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">\=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">sources</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">sum</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">object</span><span class="w"> </span><span class="nc">ColorSummingInst</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nc">SpinalVerilog</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">ColorSumming</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>生成的Verilog代码为：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// Generator : SpinalHDL v1.6.0    git head : 73c8d8e2b86b45646e9d0b2e729291f2b65e6be3</span>
<span class="c1">// Component : ColorSumming</span>
<span class="k">module</span><span class="w"> </span><span class="n">ColorSumming</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_sources_0_r</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_sources_0_g</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_sources_0_b</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_sources_1_r</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_sources_1_g</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_sources_1_b</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_sources_2_r</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_sources_2_g</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_sources_2_b</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_result_r</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_result_g</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_result_b</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_io_result_r</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_io_result_g</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_io_result_b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_io_result_r_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_io_result_g_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_io_result_b_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_io_result_r_2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_io_result_g_2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_io_result_b_2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">sum_r</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">sum_g</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">sum_b</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_result_r_1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_io_result_r_1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io_sources_2_r</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_result_g_1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_io_result_g_1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io_sources_2_g</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_result_b_1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_io_result_b_1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io_sources_2_b</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_r_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_result_r_2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_r_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_io_result_r_2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io_sources_1_r</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_g_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_result_g_2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_g_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_io_result_g_2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io_sources_1_g</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_b_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_result_b_2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_b_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_io_result_b_2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io_sources_1_b</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_r_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum_r</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_r_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">sum_r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io_sources_0_r</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_g_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum_g</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_g_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">sum_g</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io_sources_0_g</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_b_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum_b</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">_zz_io_result_b_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">sum_b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io_sources_0_b</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">sum_r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">sum_g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">sum_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_result_r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_result_r</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_result_g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_result_g</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_result_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_result_b</span><span class="p">;</span><span class="w"></span>

<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="counter-with-clear">
<h3>四、带清除的计数器(Counter with clear)<a class="headerlink" href="#counter-with-clear" title="Permalink to this heading"></a></h3>
<p>本例定义了一个具有<code class="docutils literal notranslate"><span class="pre">clear</span></code>输入和<code class="docutils literal notranslate"><span class="pre">value</span></code>输出的组件。每个时钟周期输出的<code class="docutils literal notranslate"><span class="pre">value</span></code>都是递增的，但是当<code class="docutils literal notranslate"><span class="pre">clear</span></code>值很高时，<code class="docutils literal notranslate"><span class="pre">value</span></code>被清除。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Counter</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">clear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">register</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">register</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">register</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">clear</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">register</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">register</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="pll-blackbox-and-reset-controller">
<h3>五、锁相环黑盒与复位控制器(PLL BlackBox and reset controller)<a class="headerlink" href="#pll-blackbox-and-reset-controller" title="Permalink to this heading"></a></h3>
<p>假设用户需要定义一个<code class="docutils literal notranslate"><span class="pre">TopLevel</span></code>组件来例化一个PLL<code class="docutils literal notranslate"><span class="pre">BlackBox</span></code>，并且利用它建立一个新的时钟域应用到设计中。同时用户可能需要将外部的异步复位逻辑应用到该时钟域中，与一个同步复位资源连接。</p>
<p>本小章中需要导入如下库：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">core</span><span class="p">.</span><span class="n">_</span>
<span class="k">import</span><span class="w"> </span><span class="nn">spinal</span><span class="p">.</span><span class="nn">lib</span><span class="p">.</span><span class="n">_</span>
</pre></div>
</div>
<ol>
<li><p>锁相环黑盒定义(The PLL BlackBox definition)</p>
<p>下述代码展示了如何定义锁相环<code class="docutils literal notranslate"><span class="pre">BlackBox</span></code>：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">PLL</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">BlackBox</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">clkIn</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">clkOut</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">isLocked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">noIoPrefix</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>其会生成如下VHDL代码：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">component</span><span class="w"> </span><span class="nc">PLL</span><span class="w"> </span><span class="n">is</span><span class="w"></span>
<span class="w">  </span><span class="n">port</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">clkIn</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">clkOut</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="n">std_logic</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">isLocked</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="n">std_logic</span><span class="w"></span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
<span class="n">end</span><span class="w"> </span><span class="n">component</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>顶层定义(TopLevel definition)</p>
<p>下述例子展示了如何定义个人的<code class="docutils literal notranslate"><span class="pre">TopLevel</span></code>来例化锁相环，建立新<code class="docutils literal notranslate"><span class="pre">clockdomain</span></code>并且将异步复位的输入连接至同步复位端口：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">aReset</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">clk100Mhz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">result</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 创建一个Area来管理所有时钟和复位</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">clkCtrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//例化并驱动PLL</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">pll</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">PLL</span><span class="w"></span>
<span class="w">    </span><span class="n">pll</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">clkIn</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">clk100Mhz</span><span class="w"></span>

<span class="w">    </span><span class="c1">//建立新时钟域&#39;core&#39;</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">coreClockDomain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">ClockDomain</span><span class="p">.</span><span class="n">internal</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;core&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">frequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">FixedFrequency</span><span class="p">(</span><span class="mi">200</span><span class="w"> </span><span class="nc">MHz</span><span class="p">)</span><span class="w">  </span><span class="c1">// 该频率要求可以被使用</span>
<span class="w">    </span><span class="p">)</span><span class="w">                                      </span><span class="c1">// 通过coreClockDomain用户来做某些计算</span>

<span class="w">    </span><span class="c1">//驱动coreClockDomain的时钟和复位</span>
<span class="w">    </span><span class="n">coreClockDomain</span><span class="p">.</span><span class="n">clock</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">pll</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">clkOut</span><span class="w"></span>
<span class="w">    </span><span class="n">coreClockDomain</span><span class="p">.</span><span class="n">reset</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">ResetCtrl</span><span class="p">.</span><span class="n">asyncAssertSyncDeassert</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">aReset</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">pll</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">isLocked</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">clockDomain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">coreClockDomain</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">//建立clkCtrl.coreClockDomain下的ClockingArea</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">core</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">ClockingArea</span><span class="p">(</span><span class="n">clkCtrl</span><span class="p">.</span><span class="n">coreClockDomain</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>会生成如下Verilog代码：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// Generator : SpinalHDL v1.6.0    git head : 73c8d8e2b86b45646e9d0b2e729291f2b65e6be3</span>
<span class="c1">// Component : MyTopLevel</span>
<span class="k">module</span><span class="w"> </span><span class="n">MyTopLevel</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_aReset</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_clk100Mhz</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_result</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">clkCtrl_pll_clkOut</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">clkCtrl_pll_isLocked</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">bufferCC_1_io_dataOut</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">core_clk</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">core_reset</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">core_counter</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">PLL</span><span class="w"> </span><span class="n">clkCtrl_pll</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">clkIn</span><span class="w">       </span><span class="p">(</span><span class="n">io_clk100Mhz</span><span class="w">          </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">clkOut</span><span class="w">      </span><span class="p">(</span><span class="n">clkCtrl_pll_clkOut</span><span class="w">    </span><span class="p">),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">isLocked</span><span class="w">    </span><span class="p">(</span><span class="n">clkCtrl_pll_isLocked</span><span class="w">  </span><span class="p">)</span><span class="w">  </span><span class="c1">//o</span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">BufferCC</span><span class="w"> </span><span class="n">bufferCC_1</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">io_dataIn</span><span class="w">     </span><span class="p">(</span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="w">                   </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">io_dataOut</span><span class="w">    </span><span class="p">(</span><span class="n">bufferCC_1_io_dataOut</span><span class="w">  </span><span class="p">),</span><span class="w"> </span><span class="c1">//o</span>
<span class="w">    </span><span class="p">.</span><span class="n">core_clk</span><span class="w">      </span><span class="p">(</span><span class="n">core_clk</span><span class="w">               </span><span class="p">),</span><span class="w"> </span><span class="c1">//i</span>
<span class="w">    </span><span class="p">.</span><span class="n">_zz_1</span><span class="w">         </span><span class="p">(</span><span class="n">_zz_1</span><span class="w">                  </span><span class="p">)</span><span class="w">  </span><span class="c1">//i</span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">core_clk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clkCtrl_pll_clkOut</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_aReset</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="w"> </span><span class="n">clkCtrl_pll_isLocked</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">core_reset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bufferCC_1_io_dataOut</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">core_counter</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">core_clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">core_reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">core_reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">core_counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">core_counter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">core_counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0001</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>


<span class="k">endmodule</span><span class="w"></span>

<span class="k">module</span><span class="w"> </span><span class="n">BufferCC</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_dataIn</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">              </span><span class="n">io_dataOut</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">core_clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">_zz_1</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="n">async_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="kt">reg</span><span class="w">                 </span><span class="n">buffers_0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="n">async_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="kt">reg</span><span class="w">                 </span><span class="n">buffers_1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_dataOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffers_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">core_clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">_zz_1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">_zz_1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">buffers_0</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">buffers_1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">buffers_0</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">io_dataIn</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">buffers_1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">buffers_0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>


<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="rgb">
<h3>六、RGB转灰度图<a class="headerlink" href="#rgb" title="Permalink to this heading"></a></h3>
<p>假设要建立一个可以将RGB图转化成灰度图并存到外部Memory的组件。</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">IO名称</th>
<th style="text-align: center;">方向</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">clear</td>
<td style="text-align: center;">in</td>
<td style="text-align: center;">清除所有内部寄存器</td>
</tr>
<tr>
<td style="text-align: center;">r,g,b</td>
<td style="text-align: center;">in</td>
<td style="text-align: center;">颜色输入</td>
</tr>
<tr>
<td style="text-align: center;">wr</td>
<td style="text-align: center;">out</td>
<td style="text-align: center;">写存储</td>
</tr>
<tr>
<td style="text-align: center;">address</td>
<td style="text-align: center;">out</td>
<td style="text-align: center;">存储地址，每周期增加</td>
</tr>
<tr>
<td style="text-align: center;">data</td>
<td style="text-align: center;">out</td>
<td style="text-align: center;">存储数据，灰度等级</td>
</tr>
</tbody>
</table><div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RgbToGray</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">clear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">wr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">16</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">coef</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="p">,</span><span class="n">by</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Float</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">UInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nc">U</span><span class="p">((</span><span class="mi">255</span><span class="o">*</span><span class="n">by</span><span class="p">).</span><span class="n">toInt</span><span class="p">,</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">gray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">coef</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">r</span><span class="p">,</span><span class="mf">0.3f</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">    </span><span class="n">coef</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">g</span><span class="p">,</span><span class="mf">0.4f</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">    </span><span class="n">coef</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">b</span><span class="p">,</span><span class="mf">0.3f</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">CounterFreeRun</span><span class="p">(</span><span class="n">stateCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">address</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">address</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">wr</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">gray</span><span class="w"></span>

<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">clear</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">gray</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="n">address</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">wr</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>生成的Verilog如下：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// Generator : SpinalHDL v1.6.0    git head : 73c8d8e2b86b45646e9d0b2e729291f2b65e6be3</span>
<span class="c1">// Component : RgbToGray</span>
<span class="k">module</span><span class="w"> </span><span class="n">RgbToGray</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_clear</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_r</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_g</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_b</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w">          </span><span class="n">io_wr</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_address</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_data</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_gray</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_gray_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_gray_2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_gray_3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_gray_4</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_gray_5</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_gray_6</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_address_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_address_valueNext_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">gray</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">address_willIncrement</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">                 </span><span class="n">address_willClear</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">address_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">address_value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">address_willOverflowIfInc</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">address_willOverflow</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_gray_1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_zz_gray_3</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gray_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_gray_2</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="mh">8</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gray_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">8&#39;h4c</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gray_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_gray_4</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="mh">8</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gray_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_g</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">8&#39;h66</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gray_5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_gray_6</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="mh">8</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_gray_6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">8&#39;h4c</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_address_valueNext_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address_willIncrement</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_address_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">15</span><span class="mi">&#39;d0</span><span class="p">,</span><span class="w"> </span><span class="n">_zz_address_valueNext_1</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">address_willClear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_clear</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">address_willClear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">address_willOverflowIfInc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">address_value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">16&#39;hffff</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">address_willOverflow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">address_willOverflowIfInc</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">address_willIncrement</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">address_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">address_value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_zz_address_valueNext</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">address_willClear</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">address_valueNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">16&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">address_willIncrement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address_value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_wr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_clear</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">io_wr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gray</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">gray</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">_zz_gray</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_zz_gray_5</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_clear</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">gray</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">address_value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">16&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">address_value</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">address_valueNext</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>


<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="rom-sinus-rom">
<h3>七、正弦ROM(Sinus rom)<a class="headerlink" href="#rom-sinus-rom" title="Permalink to this heading"></a></h3>
<p>假设用户需要生成一个正弦波以及其滤波后的形式。</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">参数名称</th>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">resolutionWidth</td>
<td style="text-align: center;">Int</td>
<td style="text-align: center;">表述数值的比特位宽</td>
</tr>
<tr>
<td style="text-align: center;">sampleCount</td>
<td style="text-align: center;">Int</td>
<td style="text-align: center;">一个正弦周期的采样点数</td>
</tr>
</tbody>
</table><table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">IO名称</th>
<th style="text-align: center;">方向</th>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">sin</td>
<td style="text-align: center;">out</td>
<td style="text-align: center;">SInt(resolutionWidth bits)</td>
<td style="text-align: center;">描述正弦波的输出</td>
</tr>
<tr>
<td style="text-align: center;">sinFiltred</td>
<td style="text-align: center;">out</td>
<td style="text-align: center;">SInt(resolutionWidth bits)</td>
<td style="text-align: center;">描述滤波后正弦波的输出</td>
</tr>
</tbody>
</table><p>定义一个<code class="docutils literal notranslate"><span class="pre">Component</span></code></p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="p">(</span><span class="n">resolutionWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="n">sampleCount</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">sin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">SInt</span><span class="p">(</span><span class="n">resolutionWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">sinFiltred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">SInt</span><span class="p">(</span><span class="n">resolutionWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 这里写逻辑实现</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>为了在<code class="docutils literal notranslate"><span class="pre">sin</span></code>输出端口输出正弦波，需要定义一个包含了正弦波一个周期内所有采样点的ROM。随后可以利用相位计数器读取ROM并生成正弦波。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="c1">//定义生成ROM的函数</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sinTable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="p">(</span><span class="n">sampleIndex</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">sampleCount</span><span class="p">)</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">sinValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Math</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nc">Math</span><span class="p">.</span><span class="nc">PI</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sampleIndex</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">sampleCount</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nc">S</span><span class="p">((</span><span class="n">sinValue</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">resolutionWidth</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)).</span><span class="n">toInt</span><span class="p">,</span><span class="n">resolutionWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">val</span><span class="w"> </span><span class="n">rom</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="nc">Mem</span><span class="p">(</span><span class="nc">SInt</span><span class="p">(</span><span class="n">resolutionWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="n">initialContent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sinTable</span><span class="p">)</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="n">log2Up</span><span class="p">(</span><span class="n">sampleCount</span><span class="p">)</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="n">phase</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="n">io</span><span class="p">.</span><span class="n">sin</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rom</span><span class="p">.</span><span class="n">readSync</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>随后生成<code class="docutils literal notranslate"><span class="pre">sinFiltered</span></code>，例如可以使用一个一阶低通滤波器：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">io</span><span class="p">.</span><span class="n">sinFiltred</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">sinFiltred</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">sinFiltred</span><span class="w">  </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">sin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>完整代码如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TopLevel</span><span class="p">(</span><span class="n">resolutionWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="n">sampleCount</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">sin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">SInt</span><span class="p">(</span><span class="n">resolutionWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">sinFiltred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">SInt</span><span class="p">(</span><span class="n">resolutionWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">sinTable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="p">(</span><span class="n">sampleIndex</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">sampleCount</span><span class="p">)</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">sinValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Math</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nc">Math</span><span class="p">.</span><span class="nc">PI</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sampleIndex</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">sampleCount</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="nc">S</span><span class="p">((</span><span class="n">sinValue</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">resolutionWidth</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)).</span><span class="n">toInt</span><span class="p">,</span><span class="n">resolutionWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">rom</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="nc">Mem</span><span class="p">(</span><span class="nc">SInt</span><span class="p">(</span><span class="n">resolutionWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="n">initialContent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sinTable</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="n">log2Up</span><span class="p">(</span><span class="n">sampleCount</span><span class="p">)</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">phase</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">sin</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">rom</span><span class="p">.</span><span class="n">readSync</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">sinFiltred</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">sinFiltred</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">sinFiltred</span><span class="w">  </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">sin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>设置位宽为16，采样数为32，生成的Verilog为：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// Generator : SpinalHDL v1.6.0    git head : 73c8d8e2b86b45646e9d0b2e729291f2b65e6be3</span>
<span class="c1">// Component : MyTopLevel</span>



<span class="k">module</span><span class="w"> </span><span class="n">MyTopLevel</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_sin</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">io_sinFiltred</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_rom_port0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_rom_port</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">_zz_io_sin</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz__zz_io_sinFiltred</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz__zz_io_sinFiltred_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">10</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz__zz_io_sinFiltred_2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz__zz_io_sinFiltred_3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">10</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz__zz_io_sinFiltred_4</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">4</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">phase</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_io_sinFiltred</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">rom</span><span class="w"> </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">31</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz__zz_io_sinFiltred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">$signed</span><span class="p">(</span><span class="n">io_sinFiltred</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">$signed</span><span class="p">(</span><span class="n">_zz__zz_io_sinFiltred_1</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz__zz_io_sinFiltred_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_sinFiltred</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="mh">5</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz__zz_io_sinFiltred_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mh">5</span><span class="p">{</span><span class="n">_zz__zz_io_sinFiltred_2</span><span class="p">[</span><span class="mh">10</span><span class="p">]}},</span><span class="w"> </span><span class="n">_zz__zz_io_sinFiltred_2</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz__zz_io_sinFiltred_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">io_sin</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="mh">5</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz__zz_io_sinFiltred_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mh">5</span><span class="p">{</span><span class="n">_zz__zz_io_sinFiltred_4</span><span class="p">[</span><span class="mh">10</span><span class="p">]}},</span><span class="w"> </span><span class="n">_zz__zz_io_sinFiltred_4</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_io_sin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">initial</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="nb">$readmemb</span><span class="p">(</span><span class="s">&quot;MyTopLevel.v_toplevel_rom.bin&quot;</span><span class="p">,</span><span class="n">rom</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">_zz_io_sin</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">_zz_rom_port0</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">rom</span><span class="p">[</span><span class="n">phase</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_sin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_rom_port0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_sinFiltred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_zz_io_sinFiltred</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">phase</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">5&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">_zz_io_sinFiltred</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">16&#39;h0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">phase</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">phase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">5&#39;h01</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">_zz_io_sinFiltred</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">$signed</span><span class="p">(</span><span class="n">_zz__zz_io_sinFiltred</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">$signed</span><span class="p">(</span><span class="n">_zz__zz_io_sinFiltred_3</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>


<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
<p>其中ROM的Binary文件为：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0000000000000000</span>
<span class="mi">0001100011111000</span>
<span class="mi">0011000011111011</span>
<span class="mi">0100011100011100</span>
<span class="mi">0101101010000001</span>
<span class="mi">0110101001101100</span>
<span class="mi">0111011001000000</span>
<span class="mi">0111110110001001</span>
<span class="mi">0111111111111111</span>
<span class="mi">0111110110001001</span>
<span class="mi">0111011001000000</span>
<span class="mi">0110101001101100</span>
<span class="mi">0101101010000001</span>
<span class="mi">0100011100011100</span>
<span class="mi">0011000011111011</span>
<span class="mi">0001100011111000</span>
<span class="mi">0000000000000000</span>
<span class="mi">1110011100001000</span>
<span class="mi">1100111100000101</span>
<span class="mi">1011100011100100</span>
<span class="mi">1010010101111111</span>
<span class="mi">1001010110010100</span>
<span class="mi">1000100111000000</span>
<span class="mi">1000001001110111</span>
<span class="mi">1000000000000001</span>
<span class="mi">1000001001110111</span>
<span class="mi">1000100111000000</span>
<span class="mi">1001010110010100</span>
<span class="mi">1010010101111111</span>
<span class="mi">1011100011100100</span>
<span class="mi">1100111100000101</span>
<span class="mi">1110011100001000</span>
</pre></div>
</div>
</section>
</section>
<section id="id119">
<h2>进阶实例<a class="headerlink" href="#id119" title="Permalink to this heading"></a></h2>
<section id="fractal-calculator">
<h3>一、分形计算器(Fractal calculator)<a class="headerlink" href="#fractal-calculator" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>该例子将会展示如何利用数据流以及定点计算实现一个未优化的曼德布洛特分形计算器(Mandelbrot fractal calculator)。</p>
</li>
<li><p>规范</p>
<p>组件将会接收像素任务的一个<code class="docutils literal notranslate"><span class="pre">Stream</span></code>(包含曼德布洛特空间的XY坐标)并且产生像素结果的一个<code class="docutils literal notranslate"><span class="pre">Stream</span></code>(包含对应任务的迭代次数)。</p>
<p>定义组件的IO为：
| IO名称 |  方向  |        类型         |             描述              |
| :—-: | :—-: | :—————–: | :—————————: |
|  cmd   | slave  |  Stream[PixelTask]  |       提供XY坐标来处理        |
|  rsp   | master | Stream[PixelResult] | 返回对应cmd交换所需的迭代次数 |</p>
<p>PixelTask<code class="docutils literal notranslate"><span class="pre">Bundle</span></code>为：
| 单元名称 | 类型  |         描述         |
| :——: | :—: | :——————: |
|    x     | SFix  | 曼德布洛特空间的坐标 |
|    y     | SFix  | 曼德布洛特空间的坐标 |</p>
<p>PixelResult<code class="docutils literal notranslate"><span class="pre">Bundle</span></code>为：
| 单元名称  | 类型  |      描述      |
| :——-: | :—: | :————: |
| iteration | UInt  | 所需的迭代次数 |</p>
</li>
<li><p>细化参数(Elaboration parameters)</p>
<p>定义可以为用户系统提供构造参数的类：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">PixelSolverGenerics</span><span class="p">(</span><span class="n">fixAmplitude</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="n">fixResolution</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="n">iterationLimit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">iterationWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">log2Up</span><span class="p">(</span><span class="n">iterationLimit</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">iterationType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">iterationWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">fixType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">SFix</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">peak</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fixAmplitude</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">resolution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fixResolution</span><span class="w"> </span><span class="n">exp</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p><strong>iterationType和fixType是可以调用来实例化新信号的函数。就像C语言中的typedef。</strong></p>
</div></blockquote>
</li>
<li><p>Bundle定义</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">PixelTask</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">PixelSolverGenerics</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">fixType</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">PixelResult</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">PixelSolverGenerics</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">iterationType</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>组件实现</p>
<p>下述代码是一个无流水线/多线程的简单实现：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">PixelSolver</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">PixelSolverGenerics</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w">  </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">PixelTask</span><span class="p">(</span><span class="n">g</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">rsp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">PixelResult</span><span class="p">(</span><span class="n">g</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">import</span><span class="w"> </span><span class="nn">g</span><span class="p">.</span><span class="n">_</span>

<span class="w">  </span><span class="c1">//定义状态</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="n">fixType</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="n">iterationType</span><span class="p">)</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1">//共享计算</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">xx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">yy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">xy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="w"></span>

<span class="w">  </span><span class="c1">//默认赋值</span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">ready</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">iteration</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">iteration</span><span class="w"></span>

<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">valid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">xx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">yy</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mf">4.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">iterationLimit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">io</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">ready</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">io</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">ready</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">        </span><span class="n">iteration</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">x</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">xx</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">yy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">x</span><span class="p">).</span><span class="n">truncated</span><span class="w"></span>
<span class="w">      </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(((</span><span class="n">xy</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">y</span><span class="p">).</span><span class="n">truncated</span><span class="w"></span>
<span class="w">      </span><span class="n">iteration</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>生成的Verilog如下：</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// Generator : SpinalHDL v1.6.0    git head : 73c8d8e2b86b45646e9d0b2e729291f2b65e6be3</span>
<span class="c1">// Component : PixelSolver</span>



<span class="k">module</span><span class="w"> </span><span class="n">PixelSolver</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_cmd_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w">          </span><span class="n">io_cmd_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_cmd_payload_x</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">      </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_cmd_payload_y</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w">          </span><span class="n">io_rsp_valid</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">io_rsp_ready</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">output</span><span class="w">     </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">io_rsp_payload_iteration</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">clk</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">input</span><span class="w">               </span><span class="n">reset</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_when_PixelSolver_l45</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_when_PixelSolver_l45_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">17</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">17</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_x_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">_zz_x_2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">17</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_x_3</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">18</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_y</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">18</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_y_1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">18</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">_zz_y_2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">reg</span><span class="w">        </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">iteration</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">xx</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">yy</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">       </span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">    </span><span class="n">xy</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">wire</span><span class="w">                </span><span class="n">when_PixelSolver_l45</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_when_PixelSolver_l45</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="mb">&#39;b00</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_when_PixelSolver_l45_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">$signed</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">$signed</span><span class="p">(</span><span class="n">yy</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">$signed</span><span class="p">(</span><span class="n">_zz_x_1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">$signed</span><span class="p">(</span><span class="n">_zz_x_3</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_x_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">({</span><span class="mh">16</span><span class="mi">&#39;d0</span><span class="p">,</span><span class="n">_zz_x_2</span><span class="p">}</span><span class="w"> </span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mh">16</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_x_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">$signed</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">$signed</span><span class="p">(</span><span class="n">yy</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_x_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mh">17</span><span class="p">{</span><span class="n">io_cmd_payload_x</span><span class="p">[</span><span class="mh">0</span><span class="p">]}},</span><span class="w"> </span><span class="n">io_cmd_payload_x</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">$signed</span><span class="p">(</span><span class="n">_zz_y_1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">$signed</span><span class="p">(</span><span class="n">_zz_y_2</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_y_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">({</span><span class="mh">17</span><span class="mi">&#39;d0</span><span class="p">,</span><span class="n">xy</span><span class="p">}</span><span class="w"> </span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mh">17</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">_zz_y_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="mh">18</span><span class="p">{</span><span class="n">io_cmd_payload_y</span><span class="p">[</span><span class="mh">0</span><span class="p">]}},</span><span class="w"> </span><span class="n">io_cmd_payload_y</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">xx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">$signed</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">$signed</span><span class="p">(</span><span class="n">x</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">yy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">$signed</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">$signed</span><span class="p">(</span><span class="n">y</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">xy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">$signed</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">$signed</span><span class="p">(</span><span class="n">y</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_cmd_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_cmd_valid</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">when_PixelSolver_l45</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">io_rsp_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">          </span><span class="n">io_cmd_ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="n">io_rsp_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">io_cmd_valid</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">when_PixelSolver_l45</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="n">io_rsp_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>

<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">io_rsp_payload_iteration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iteration</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">assign</span><span class="w"> </span><span class="n">when_PixelSolver_l45</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">$signed</span><span class="p">(</span><span class="n">_zz_when_PixelSolver_l45</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">$signed</span><span class="p">(</span><span class="n">_zz_when_PixelSolver_l45_1</span><span class="p">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">iteration</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b1010</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">iteration</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">io_cmd_valid</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">when_PixelSolver_l45</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">io_rsp_ready</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">            </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">iteration</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0000</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">end</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span><span class="w"></span>
<span class="w">          </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">_zz_x</span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">0</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">_zz_y</span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">0</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">iteration</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">iteration</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">4</span><span class="mb">&#39;b0001</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">end</span><span class="w"></span>
<span class="w">      </span><span class="k">end</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"></span>


<span class="k">endmodule</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="id120">
<h3>二、UART<a class="headerlink" href="#id120" title="Permalink to this heading"></a></h3>
<ol>
<li><p>规范</p>
<p>该UART实现参考来自于https://github.com/SpinalHDL/SpinalHDL/tree/master/lib/src/main/scala/spinal/lib/com/uart的指导。</p>
<p>该实现的特征有：</p>
<ul class="simple">
<li><p>ClockDivider/Parity/StopBit/DataLength的配置被组件的输入所设置</p></li>
<li><p>RXD输入采用N个采样点和多数投票法的抽样窗口进行滤波。</p></li>
</ul>
<p>该UART控制端口为：
|  名称  |      类型      |                     描述                     |
| :—-: | :————: | :——————————————: |
| config | UartCtrlConfig |             将所有配置发给控制器             |
| write  |  Stream[Bits]  |     系统发送传输顺序给控制器所使用的端口     |
|  read  |   Flow[Bits]   | 控制器发送成功接收帧提示给系统所使用的的端口 |
|  uart  |      Uart      |             带rxd/txd的Uart端口              |</p>
</li>
<li><p>数据结构</p>
<p>在实现控制器之前，需要定义一些数据结构。</p>
<ul class="simple">
<li><p>控制器构造参数</p></li>
</ul>
</li>
</ol>
<pre><code>    |       名称        | 类型  |                     描述                      |
    | :---------------: | :---: | :-------------------------------------------: |
    |   dataWidthMax    |  Int  |     使用单个UART帧可以发送的最大数据位数      |
    | clockDividerWidth |  Int  |              时钟分频器的比特数               |
    |  preSamplingSize  |  Int  |        在采样窗口开始时要drop的样本数         |
    |   samplingSize    |  Int  | 获得滤波后的RXD值所需的窗口中间使用的样本数量 |
    | postSamplingSize  |  Int  |        在采样窗口结束时要drop的样本数         |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    为了使得实现简单，假设`preSamplingSize + samplingSize + postSamplingSize`都是2的幂次方。

    同时不需要将每个构造参数(泛型)逐个添加到`UartCtrl`中，而是可以将它们分组到一个类中，这个类将用作`UartCtrl`的单个参数。
    ```Scala
    case class UartCtrlGenerics( dataWidthMax: Int = 8,
                         clockDividerWidth: Int = 20, // baudrate = Fclk / rxSamplePerBit / clockDividerWidth
                         preSamplingSize: Int = 1,
                         samplingSize: Int = 5,
                         postSamplingSize: Int = 2) {
      val rxSamplePerBit = preSamplingSize + samplingSize + postSamplingSize
      assert(isPow2(rxSamplePerBit))
      if ((samplingSize % 2) == 0)
        SpinalWarning(s&quot;It&#39;s not nice to have a odd samplingSize value (because of the majority vote)&quot;)
    }
    ```
- UART总线

    定义一个无流控制的UART总线：
    ```Scala
    case class Uart() extends Bundle with IMasterSlave {
      val txd = Bool()
      val rxd = Bool()

      override def asMaster(): Unit = {
        out(txd)
        in(rxd)
      }
    }
    ```

- UART配置枚举(UART configuration enums)

    定义奇偶校验和停止位枚举(stop bit enumerations)
    ```Scala
    object UartParityType extends SpinalEnum(sequancial) {
      val NONE, EVEN, ODD = newElement()
    }

    object UartStopType extends SpinalEnum(sequancial) {
      val ONE, TWO = newElement()
      def toBitCount(that : T) : UInt = (that === ONE) ? U&quot;0&quot; | U&quot;1&quot;
    }
    ```

- UartCtrl配置类

    定义将会被用作IO单元来设置`UartCtrl`的`Bundle`。
    ```Scala
    case class UartCtrlFrameConfig(g: UartCtrlGenerics) extends Bundle {
      val dataLength = UInt(log2Up(g.dataWidthMax) bits) //Bit count = dataLength + 1
      val stop       = UartStopType()
      val parity     = UartParityType()
    }

    case class UartCtrlConfig(g: UartCtrlGenerics) extends Bundle {
      val frame        = UartCtrlFrameConfig(g)
      val clockDivider = UInt (g.clockDividerWidth bits) //请见UartCtrlGenerics.clockDividerWidth

      def setClockDivider(baudrate : Double,clkFrequency : Double = ClockDomain.current.frequency.getValue) : Unit = {
        clockDivider := (clkFrequency / baudrate / g.rxSamplePerBit).toInt
      }
    }
    ```
</pre></div>
</div>
<ol>
<li><p>实现</p>
<p>在<code class="docutils literal notranslate"><span class="pre">UartCtrl</span></code>中，三个物体会被实例化：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> - 一个时钟分频器，以UART RX采样率产生采样脉冲
 - 一个`UartCtrlTx``Component`
 - 一个`UartCtrlRx``Component`
</pre></div>
</div>
<ul>
<li><p>UartCtrlTx</p>
<p>该<code class="docutils literal notranslate"><span class="pre">Component</span></code>的端口如下：
|     名称     |        类型         |                     描述                     |
| :———-: | :—————–: | :——————————————: |
| configFrame  | UartCtrlFrameConfig |        包含数据位宽度计数和停止位配置        |
| samplingTick |        Bool         | 每UART波特，脉冲<code class="docutils literal notranslate"><span class="pre">rxSamplePerBit</span></code>次的时间参考 |
|    write     |    Stream[Bits]     |        系统向控制器发出传输指令的端口        |
|     txd      |        Bool         |                UART txd 引脚                 |</p>
<p>定义用作存储<code class="docutils literal notranslate"><span class="pre">UartCtrlTX</span></code>状态的枚举：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">UartCtrlTxState</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">SpinalEnum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">IDLE</span><span class="p">,</span><span class="w"> </span><span class="nc">START</span><span class="p">,</span><span class="w"> </span><span class="nc">DATA</span><span class="p">,</span><span class="w"> </span><span class="nc">PARITY</span><span class="p">,</span><span class="w"> </span><span class="nc">STOP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newElement</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>定义<code class="docutils literal notranslate"><span class="pre">UartCtrlTx</span></code>的框架:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span>class UartCtrlTx(g : UartCtrlGenerics) extends Component {
  `import g._

  val io = new Bundle {
    val configFrame  = in(UartCtrlFrameConfig(g))
    val samplingTick = in Bool()
    val write        = slave Stream (Bits(dataWidthMax bits))
    val txd          = out Bool
  }


  val clockDivider = new Area {
    val counter = Reg(UInt(log2Up(rxSamplePerBit) bits)) init(0)
    val tick = False
    ..
  }

  machine to count up data bits and stop bits
  val tickCounter = new Area {
    val value = Reg(UInt(Math.max(dataWidthMax, 2) bits))
    def reset() = value := 0
    ..
  }

  val stateMachine = new Area {
    import UartCtrlTxState._

    val state = RegInit(IDLE)
    val parity = Reg(Bool)
    val txd = True
    ..
    switch(state) {
      ..
    }
  }

  io.txd := RegNext(stateMachine.txd) init(True)
}
</pre></div>
</div>
<p>完整实现如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">UartCtrlTx</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">UartCtrlGenerics</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">import</span><span class="w"> </span><span class="nn">g</span><span class="p">.</span><span class="n">_</span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">configFrame</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nc">UartCtrlFrameConfig</span><span class="p">(</span><span class="n">g</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">samplingTick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">write</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="w"> </span><span class="nc">Stream</span><span class="w"> </span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="n">dataWidthMax</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">txd</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">clockDivider</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="n">log2Up</span><span class="p">(</span><span class="n">rxSamplePerBit</span><span class="p">)</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">tick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">samplingTick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="n">tick</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">machine</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">stop</span><span class="w"> </span><span class="n">bits</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">tickCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="nc">Math</span><span class="p">.</span><span class="n">max</span><span class="p">(</span><span class="n">dataWidthMax</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">clockDivider</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">stateMachine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">import</span><span class="w"> </span><span class="nc">UartCtrlTxState</span><span class="p">.</span><span class="n">_</span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegInit</span><span class="p">(</span><span class="nc">IDLE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">parity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bool</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">txd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>

<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">clockDivider</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">parity</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">parity</span><span class="w"> </span><span class="n">^</span><span class="w"> </span><span class="n">txd</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">write</span><span class="p">.</span><span class="n">ready</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="w">    </span><span class="n">switch</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">is</span><span class="p">(</span><span class="nc">IDLE</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">write</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">clockDivider</span><span class="p">.</span><span class="n">tick</span><span class="p">){</span><span class="w"></span>
<span class="w">          </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">START</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">is</span><span class="p">(</span><span class="nc">START</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">txd</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">clockDivider</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">DATA</span><span class="w"></span>
<span class="w">          </span><span class="n">parity</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">configFrame</span><span class="p">.</span><span class="n">parity</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">UartParityType</span><span class="p">.</span><span class="nc">ODD</span><span class="w"></span>
<span class="w">          </span><span class="n">tickCounter</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">is</span><span class="p">(</span><span class="nc">DATA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">txd</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">write</span><span class="p">.</span><span class="n">payload</span><span class="p">(</span><span class="n">tickCounter</span><span class="p">.</span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">clockDivider</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">when</span><span class="p">(</span><span class="n">tickCounter</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">configFrame</span><span class="p">.</span><span class="n">dataLength</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">io</span><span class="p">.</span><span class="n">write</span><span class="p">.</span><span class="n">ready</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="w">            </span><span class="n">tickCounter</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">configFrame</span><span class="p">.</span><span class="n">parity</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">UartParityType</span><span class="p">.</span><span class="nc">NONE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">STOP</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">PARITY</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">is</span><span class="p">(</span><span class="nc">PARITY</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">txd</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">parity</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">clockDivider</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">STOP</span><span class="w"></span>
<span class="w">          </span><span class="n">tickCounter</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">is</span><span class="p">(</span><span class="nc">STOP</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">clockDivider</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">when</span><span class="p">(</span><span class="n">tickCounter</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">toBitCount</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">configFrame</span><span class="p">.</span><span class="n">stop</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">write</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">START</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nc">IDLE</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">txd</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">stateMachine</span><span class="p">.</span><span class="n">txd</span><span class="p">,</span><span class="w"> </span><span class="nc">True</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>UartCtrlRx</p>
<p>该<code class="docutils literal notranslate"><span class="pre">Component</span></code>的端口如下：
|     名称     |        类型         |                     描述                     |
| :———-: | :—————–: | :——————————————: |
| configFrame  | UartCtrlFrameConfig |        包含数据位宽度计数和停止位配置        |
| samplingTick |        Bool         | 每UART波特，脉冲<code class="docutils literal notranslate"><span class="pre">rxSamplePerBit</span></code>次的时间参考 |
|     read     |     Flow[Bits]      |         用来向系统告知数据帧接收成功         |
|     txd      |        Bool         |     UART txd 引脚，没有与当前时钟域同步      |</p>
<p>定义用作存储<code class="docutils literal notranslate"><span class="pre">UartCtrlTX</span></code>状态的枚举：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">UartCtrlRxState</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">SpinalEnum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">IDLE</span><span class="p">,</span><span class="w"> </span><span class="nc">START</span><span class="p">,</span><span class="w"> </span><span class="nc">DATA</span><span class="p">,</span><span class="w"> </span><span class="nc">PARITY</span><span class="p">,</span><span class="w"> </span><span class="nc">STOP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newElement</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>定义<code class="docutils literal notranslate"><span class="pre">UartCtrlTx</span></code>的框架:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">UartCtrlRx</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">UartCtrlGenerics</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">import</span><span class="w"> </span><span class="nn">g</span><span class="p">.</span><span class="n">_</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">configFrame</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nc">UartCtrlFrameConfig</span><span class="p">(</span><span class="n">g</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">samplingTick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">read</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Flow</span><span class="w"> </span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="n">dataWidthMax</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">rxd</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">sampler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">syncroniser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BufferCC</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">rxd</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">samples</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">History</span><span class="p">(</span><span class="n">that</span><span class="o">=</span><span class="n">syncroniser</span><span class="p">,</span><span class="n">when</span><span class="o">=</span><span class="n">io</span><span class="p">.</span><span class="n">samplingTick</span><span class="p">,</span><span class="n">length</span><span class="o">=</span><span class="n">samplingSize</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="nc">MajorityVote</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">tick</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">samplingTick</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">bitTimer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="n">log2Up</span><span class="p">(</span><span class="n">rxSamplePerBit</span><span class="p">)</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">preSamplingSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">samplingSize</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">tick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">bitCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="nc">Math</span><span class="p">.</span><span class="n">max</span><span class="p">(</span><span class="n">dataWidthMax</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">stateMachine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">import</span><span class="w"> </span><span class="nc">UartCtrlRxState</span><span class="p">.</span><span class="n">_</span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">state</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">RegInit</span><span class="p">(</span><span class="nc">IDLE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">parity</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bool</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">shifter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">read</span><span class="p">.</span><span class="n">payload</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">switch</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>完整实现如下：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">UartCtrlRx</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">UartCtrlGenerics</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">import</span><span class="w"> </span><span class="nn">g</span><span class="p">.</span><span class="n">_</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">configFrame</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nc">UartCtrlFrameConfig</span><span class="p">(</span><span class="n">g</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">samplingTick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">read</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="nc">Flow</span><span class="w"> </span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="n">dataWidthMax</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">rxd</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">sampler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">syncroniser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">BufferCC</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">rxd</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">samples</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nc">History</span><span class="p">(</span><span class="n">that</span><span class="o">=</span><span class="n">syncroniser</span><span class="p">,</span><span class="n">when</span><span class="o">=</span><span class="n">io</span><span class="p">.</span><span class="n">samplingTick</span><span class="p">,</span><span class="n">length</span><span class="o">=</span><span class="n">samplingSize</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="nc">MajorityVote</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">tick</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">samplingTick</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">bitTimer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="n">log2Up</span><span class="p">(</span><span class="n">rxSamplePerBit</span><span class="p">)</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">preSamplingSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">samplingSize</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">tick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">sampler</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">tick</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>


<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">bitCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="nc">Math</span><span class="p">.</span><span class="n">max</span><span class="p">(</span><span class="n">dataWidthMax</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">bitTimer</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">stateMachine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">import</span><span class="w"> </span><span class="nc">UartCtrlRxState</span><span class="p">.</span><span class="n">_</span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">state</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nc">RegInit</span><span class="p">(</span><span class="nc">IDLE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">parity</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bool</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">shifter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">read</span><span class="p">.</span><span class="n">payload</span><span class="p">)</span><span class="w"></span>


<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">bitTimer</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">parity</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">parity</span><span class="w"> </span><span class="n">^</span><span class="w"> </span><span class="n">sampler</span><span class="p">.</span><span class="n">value</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">read</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">False</span><span class="w"></span>
<span class="w">    </span><span class="n">switch</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">is</span><span class="p">(</span><span class="nc">IDLE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">sampler</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">False</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">START</span><span class="w"></span>
<span class="w">          </span><span class="n">bitTimer</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">is</span><span class="p">(</span><span class="nc">START</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">bitTimer</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">DATA</span><span class="w"></span>
<span class="w">          </span><span class="n">bitCounter</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="n">parity</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">configFrame</span><span class="p">.</span><span class="n">parity</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">UartParityType</span><span class="p">.</span><span class="nc">ODD</span><span class="w"></span>
<span class="w">          </span><span class="n">when</span><span class="p">(</span><span class="n">sampler</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">True</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">IDLE</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">is</span><span class="p">(</span><span class="nc">DATA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">bitTimer</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">shifter</span><span class="p">(</span><span class="n">bitCounter</span><span class="p">.</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">sampler</span><span class="p">.</span><span class="n">value</span><span class="w"></span>
<span class="w">          </span><span class="n">when</span><span class="p">(</span><span class="n">bitCounter</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">configFrame</span><span class="p">.</span><span class="n">dataLength</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">bitCounter</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">configFrame</span><span class="p">.</span><span class="n">parity</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">UartParityType</span><span class="p">.</span><span class="nc">NONE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">STOP</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">              </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">PARITY</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">is</span><span class="p">(</span><span class="nc">PARITY</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">bitTimer</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">STOP</span><span class="w"></span>
<span class="w">          </span><span class="n">bitCounter</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span><span class="w"></span>
<span class="w">          </span><span class="n">when</span><span class="p">(</span><span class="n">parity</span><span class="w"> </span><span class="o">=/=</span><span class="w"> </span><span class="n">sampler</span><span class="p">.</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">IDLE</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">is</span><span class="p">(</span><span class="nc">STOP</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">when</span><span class="p">(</span><span class="n">bitTimer</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">when</span><span class="p">(</span><span class="o">!</span><span class="n">sampler</span><span class="p">.</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">IDLE</span><span class="w"></span>
<span class="w">          </span><span class="p">}.</span><span class="n">elsewhen</span><span class="p">(</span><span class="n">bitCounter</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">toBitCount</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">configFrame</span><span class="p">.</span><span class="n">stop</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">IDLE</span><span class="w"></span>
<span class="w">            </span><span class="n">io</span><span class="p">.</span><span class="n">read</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">read</span><span class="p">.</span><span class="n">payload</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">stateMachine</span><span class="p">.</span><span class="n">shifter</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>UartCtrl</p>
<p>让编写<code class="docutils literal notranslate"><span class="pre">UartCtrl</span></code>来实例化<code class="docutils literal notranslate"><span class="pre">UartCtrlRx</span></code>和<code class="docutils literal notranslate"><span class="pre">UartCtrlTx</span></code>部分，生成时钟分频器逻辑，并将它们彼此连接起来。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">UartCtrl</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">UartCtrlGenerics</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UartCtrlGenerics</span><span class="p">())</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nc">UartCtrlConfig</span><span class="p">(</span><span class="n">g</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">write</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">dataWidthMax</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">read</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">Flow</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">dataWidthMax</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">uart</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">Uart</span><span class="p">())</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">UartCtrlTx</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">rx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">UartCtrlRx</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1">//Clock divider used by RX and TX</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">clockDivider</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">clockDividerWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">tick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">tick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">clockDivider</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">tx</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">samplingTick</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">clockDivider</span><span class="p">.</span><span class="n">tick</span><span class="w"></span>
<span class="w">  </span><span class="n">rx</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">samplingTick</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">clockDivider</span><span class="p">.</span><span class="n">tick</span><span class="w"></span>

<span class="w">  </span><span class="n">tx</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">configFrame</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">frame</span><span class="w"></span>
<span class="w">  </span><span class="n">rx</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">configFrame</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">frame</span><span class="w"></span>

<span class="w">  </span><span class="n">tx</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">write</span><span class="w"></span>
<span class="w">  </span><span class="n">rx</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">read</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">read</span><span class="w"></span>

<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">uart</span><span class="p">.</span><span class="n">txd</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">tx</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">txd</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">uart</span><span class="p">.</span><span class="n">rxd</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">rxd</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>简单使用</p>
<p>将<code class="docutils literal notranslate"><span class="pre">uartCtrl</span></code>综合为<code class="docutils literal notranslate"><span class="pre">115200-N-8-1</span></code>：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">uartCtrl</span><span class="p">:</span><span class="w"> </span><span class="nc">UartCtrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UartCtrl</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UartCtrlInitConfig</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">baudrate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">115200</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">dataLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w">  </span><span class="c1">// 8 bits</span>
<span class="w">    </span><span class="n">parity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UartParityType</span><span class="p">.</span><span class="nc">NONE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">stop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UartStopType</span><span class="p">.</span><span class="nc">ONE</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>如果只使用<code class="docutils literal notranslate"><span class="pre">txd</span></code>引脚：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">uart</span><span class="p">.</span><span class="n">rxd</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w">  </span><span class="c1">//UART空闲状态置高</span>
<span class="n">txd</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">uart</span><span class="p">.</span><span class="n">txd</span><span class="w"></span>
</pre></div>
</div>
<p>相反，如果只使用<code class="docutils literal notranslate"><span class="pre">rxd</span></code>引脚：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">uartCtrl</span><span class="p">:</span><span class="w"> </span><span class="nc">UartCtrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UartCtrl</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UartCtrlInitConfig</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">baudrate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">115200</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">dataLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w">  </span><span class="c1">// 8 bits</span>
<span class="w">    </span><span class="n">parity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UartParityType</span><span class="p">.</span><span class="nc">NONE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">stop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UartStopType</span><span class="p">.</span><span class="nc">ONE</span><span class="w"></span>
<span class="w">  </span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">readonly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>带TB的例子</p>
<p>下面是一个顶层的例子，做了以下事情:</p>
<ul class="simple">
<li><p>实例化<code class="docutils literal notranslate"><span class="pre">UartCtrl</span></code>并将其配置为921600波特/秒，无奇偶校验，1个停止位。</p></li>
<li><p>每次从UART接收到一个字节时，它就把它写到led输出上。</p></li>
<li><p>每2000个周期，它将开关的输入值发送给UART。</p></li>
</ul>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">UartCtrlUsageExample</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">uart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">Uart</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">switchs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">leds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">uartCtrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">UartCtrl</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">setClockDivider</span><span class="p">(</span><span class="mi">921600</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">dataLength</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="c1">//8 bits</span>
<span class="w">  </span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">parity</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">UartParityType</span><span class="p">.</span><span class="nc">NONE</span><span class="w"></span>
<span class="w">  </span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">stop</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">UartStopType</span><span class="p">.</span><span class="nc">ONE</span><span class="w"></span>
<span class="w">  </span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">uart</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">uart</span><span class="w"></span>

<span class="w">  </span><span class="c1">//Assign io.led with a register loaded each time a byte is received</span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">leds</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">read</span><span class="p">.</span><span class="n">toReg</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="c1">//Write the value of switch on the uart each 2000 cycles</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="n">write</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">CounterFreeRun</span><span class="p">(</span><span class="mi">2000</span><span class="p">).</span><span class="n">willOverflow</span><span class="w"></span>
<span class="w">  </span><span class="n">write</span><span class="p">.</span><span class="n">payload</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">switchs</span><span class="w"></span>
<span class="w">  </span><span class="n">write</span><span class="w"> </span><span class="o">&gt;-&gt;</span><span class="w"> </span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">write</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">object</span><span class="w"> </span><span class="nc">UartCtrlUsageExample</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nc">SpinalVhdl</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="nc">UartCtrlUsageExample</span><span class="p">,</span><span class="n">defaultClockDomainFrequency</span><span class="o">=</span><span class="nc">FixedFrequency</span><span class="p">(</span><span class="mf">50e6</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>如果想在发送交换机的值之前发送一个0x55头部，可以用下面的例子来替换写生成器:</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Fragment</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)))</span><span class="w"></span>
<span class="n">write</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">CounterFreeRun</span><span class="p">(</span><span class="mi">4000</span><span class="p">).</span><span class="n">willOverflow</span><span class="w"></span>
<span class="n">write</span><span class="p">.</span><span class="n">fragment</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">switchs</span><span class="w"></span>
<span class="n">write</span><span class="p">.</span><span class="n">last</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nc">True</span><span class="w"></span>
<span class="n">write</span><span class="p">.</span><span class="n">stage</span><span class="p">().</span><span class="n">insertHeader</span><span class="p">(</span><span class="mh">0x55</span><span class="p">).</span><span class="n">toStreamOfFragment</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">write</span><span class="w"></span>
</pre></div>
</div>
<p>可以从https://github.com/SpinalHDL/SpinalHDL/blob/master/tester/src/test/resources/UartCtrlUsageExample_tb.vhd获取简单的VHDL测试文件。</p>
</li>
<li><p>使用Stream</p>
<p>想要将UART来的数据入队：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">uartCtrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">UartCtrl</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">queuedReads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">read</span><span class="p">.</span><span class="n">toStream</span><span class="p">.</span><span class="n">queue</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>想要在写端口上加一个队列并做流控制：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">uartCtrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">UartCtrl</span><span class="p">()</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">writeCmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Stream</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="kd">val</span><span class="w"> </span><span class="n">stopIt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="w"></span>
<span class="n">writeCmd</span><span class="p">.</span><span class="n">queue</span><span class="p">(</span><span class="mi">16</span><span class="p">).</span><span class="n">haltWhen</span><span class="p">(</span><span class="n">stopIt</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">write</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="id121">
<h3>三、VGA<a class="headerlink" href="#id121" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>VGA接口正在变得稀少，但实现VGA控制器仍然是一个很好的练习。</p>
<p>关于VGA协议的解释可以在https://xess.com/blog/vga-the-rest-of-the-story/找到。</p>
<p>本VGA控制器教程基于https://github.com/SpinalHDL/SpinalHDL/blob/master/lib/src/main/scala/spinal/lib/graphic/vga/VgaCtrl.scala实现。</p>
</li>
<li><p>数据结构</p>
<p>在实现控制器前需要定义一些数据结构。</p>
<ul>
<li><p>RGB颜色</p>
<p>首先，需要一个三通道的颜色结构(红、绿、蓝)。这个数据结构将被用来给控制器提供像素，也将被VGA总线使用。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">RgbConfig</span><span class="p">(</span><span class="n">rWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="n">gWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">,</span><span class="n">bWidth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">getWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rWidth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">gWidth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bWidth</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Rgb</span><span class="p">(</span><span class="n">c</span><span class="p">:</span><span class="w"> </span><span class="nc">RgbConfig</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">rWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">gWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">bWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>VGA总线</p></li>
</ul>
</li>
</ol>
<pre><code>    | IO名称  |  驱动  |           描述           |
    | :-----: | :----: | :----------------------: |
    |  vSync  | master | 垂直同步，表示新帧的开始 |
    |  hSync  | master | 水平同步，表示新行的开始 |
    | colorEn | master | 当接口处于可见部分时置高 |
    |  color  | master |         携带颜色         |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    ```Scala
    case class Vga (rgbConfig: RgbConfig) extends Bundle with IMasterSlave{
      val vSync = Bool()
      val hSync = Bool()

      val colorEn = Bool()
      val color   = Rgb(rgbConfig)

      override def asMaster() : Unit = this.asOutput()
    }
    ```
    这个Vga `Bundle`使用了`IMasterSlave`特性，它允许用户使用以下方式创建主/从Vga接口:
    ```
    master(Vga(...))
    slave(Vga(...))
    ```

- VGA时序

    VGA接口通过使用8种不同的时序来驱动。下面是一个能够携带它们的`Bundle`的简单例子。

    ```Scala
    case class VgaTimings(timingsWidth: Int) extends Bundle {
      val hSyncStart  = UInt(timingsWidth bits)
      val hSyncEnd    = UInt(timingsWidth bits)
      val hColorStart = UInt(timingsWidth bits)
      val hColorEnd   = UInt(timingsWidth bits)
      val vSyncStart  = UInt(timingsWidth bits)
      val vSyncEnd    = UInt(timingsWidth bits)
      val vColorStart = UInt(timingsWidth bits)
      val vColorEnd   = UInt(timingsWidth bits)
    }
    ```
    但这不是一个很好的方式来指定它，因为它对于垂直和水平时间信号来说是多余的。

    用更清晰的方式来写:
    ```Scala
    case class VgaTimingsHV(timingsWidth: Int) extends Bundle {
      val colorStart = UInt(timingsWidth bits)
      val colorEnd   = UInt(timingsWidth bits)
      val syncStart  = UInt(timingsWidth bits)
      val syncEnd    = UInt(timingsWidth bits)
    }

    case class VgaTimings(timingsWidth: Int) extends Bundle {
      val h = VgaTimingsHV(timingsWidth)
      val v = VgaTimingsHV(timingsWidth)
    }
    ```

    然后可以添加一些函数来设置特定分辨率和帧率的时间:
    ```Scala
    case class VgaTimingsHV(timingsWidth: Int) extends Bundle {
      val colorStart = UInt(timingsWidth bits)
      val colorEnd   = UInt(timingsWidth bits)
      val syncStart  = UInt(timingsWidth bits)
      val syncEnd    = UInt(timingsWidth bits)
    }

    case class VgaTimings(timingsWidth: Int) extends Bundle {
      val h = VgaTimingsHV(timingsWidth)
      val v = VgaTimingsHV(timingsWidth)

      def setAs_h640_v480_r60: Unit = {
        h.syncStart := 96 - 1
        h.syncEnd := 800 - 1
        h.colorStart := 96 + 16 - 1
        h.colorEnd := 800 - 48 - 1
        v.syncStart := 2 - 1
        v.syncEnd := 525 - 1
        v.colorStart := 2 + 10 - 1
        v.colorEnd := 525 - 33 - 1
      }

      def setAs_h64_v64_r60: Unit = {
        h.syncStart := 96 - 1
        h.syncEnd := 800 - 1
        h.colorStart := 96 + 16 - 1 + 288
        h.colorEnd := 800 - 48 - 1 - 288
        v.syncStart := 2 - 1
        v.syncEnd := 525 - 1
        v.colorStart := 2 + 10 - 1 + 208
        v.colorEnd := 525 - 33 - 1 - 208
      }
    }
    ```
</pre></div>
</div>
<ol class="simple">
<li><p>VGA控制器</p>
<ul class="simple">
<li><p>规范</p></li>
</ul>
</li>
</ol>
<pre><code>    |   IO名称   |  方向  |               描述                |
    | :--------: | :----: | :-------------------------------: |
    | softReset  |   in   | 重置内部计数器，保持VGA接口不激活 |
    |  timings   |   in   |       指定VGA水平和垂直时序       |
    |   pixels   | slave  |    提供给VGA控制器的RGB颜色流     |
    |   error    |  out   |         像素流太慢时置高          |
    | frameStart |  out   |         新的帧开始时置高          |
    |    vga     | master |              VGA接口              |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    控制器不集成任何像素缓冲。它直接把它们从`pixels``Stream`获取并在适当的时候把它们放在`vga.color`上。如果`pixels`无效，那么在一个周期内`error`会拉高。

- 组件和io定义

    定义一个新的VgaCtrl`Component`，它将`RgbConfig`和`timingsWidth`作为参数。将位宽设置为默认值12。
    ```Scala
    class VgaCtrl(rgbConfig: RgbConfig, timingsWidth: Int = 12) extends Component {
      val io = new Bundle {
        val softReset = in Bool
        val timings = in(VgaTimings(timingsWidth))
        val pixels = slave Stream (Rgb(rgbConfig))

        val error = out Bool
        val frameStart = out Bool
        val vga = master(Vga(rgbConfig))
      }
      ...
    }
    ```

- 水平和垂直逻辑

    产生水平和垂直同步信号的逻辑是完全相同的。有点像~PWM~。水平同步器每循环加一次，而垂直同步器使用水平同步信号作为增量。

    定义`HVArea`，它表示1个 ~PWM，然后实例化它两次:一次用于水平同步和一次用于垂直同步

    ```Scala
    class VgaCtrl(rgbConfig: RgbConfig, timingsWidth: Int = 12) extends Component {
      val io = new Bundle {...}

      case class HVArea(timingsHV: VgaTimingsHV, enable: Bool) extends Area {
        val counter = Reg(UInt(timingsWidth bits)) init(0)

        val syncStart  = counter === timingsHV.syncStart
        val syncEnd    = counter === timingsHV.syncEnd
        val colorStart = counter === timingsHV.colorStart
        val colorEnd   = counter === timingsHV.colorEnd

        when(enable) {
          counter := counter + 1
          when(syncEnd) {
            counter := 0
          }
        }

        val sync    = RegInit(False) setWhen(syncStart) clearWhen(syncEnd)
        val colorEn = RegInit(False) setWhen(colorStart) clearWhen(colorEnd)

        when(io.softReset) {
          counter := 0
          sync    := False
          colorEn := False
        }
      }
      val h = HVArea(io.timings.h, True)
      val v = HVArea(io.timings.v, h.syncEnd)
    }
    ```

    可见，这是通过使用Area完成的。这是为了避免创建一个新的`Component`，否则会变得冗长得多。

- 互联

    有了用于水平和垂直同步的定时生成器，需要驱动输出。
    ```Scala
    class VgaCtrl(rgbConfig: RgbConfig, timingsWidth: Int = 12) extends Component {
      val io = new Bundle {...}

      case class HVArea(timingsHV: VgaTimingsHV, enable: Bool) extends Area {...}
      val h = HVArea(io.timings.h, True)
      val v = HVArea(io.timings.v, h.syncEnd)

      val colorEn = h.colorEn &amp;&amp; v.colorEn
      io.pixels.ready := colorEn
      io.error := colorEn &amp;&amp; ! io.pixels.valid

      io.frameStart := v.syncEnd

      io.vga.hSync := h.sync
      io.vga.vSync := v.sync
      io.vga.colorEn := colorEn
      io.vga.color := io.pixels.payload
    }
    ```

- 奖励

    上面定义的VgaCtrl是通用的(不是特定于应用程序的)。可以想象这样一个情况，系统提供了RGB的片段流(`Stream` of `Fragment`)，这意味着系统在图像开始/结束指示之间传输像素。

    在这种情况下，可以通过在`error`发生时激活它来自动管理`softReset`输入，然后等待当前`pixel`图片的结束来无效`error`。

    向`VgaCtrl`添加一个函数，可以通过使用RGB片段流从父组件调用该函数来提供`VgaCtrl`。

    ```Scala
    class VgaCtrl(rgbConfig: RgbConfig, timingsWidth: Int = 12) extends Component {
      ...
      def feedWith(that : Stream[Fragment[Rgb]]): Unit ={
        io.pixels &lt;&lt; that.toStreamOfFragment

        val error = RegInit(False)
        when(io.error){
          error := True
        }
        when(that.isLast){
          error := False
        }

        io.softReset := error
        when(error){
          that.ready := True
        }
      }
    }
    ```
</pre></div>
</div>
</section>
</section>
<section id="id122">
<h2>高级实例<a class="headerlink" href="#id122" title="Permalink to this heading"></a></h2>
<section id="jtag-tap">
<h3>一、JTAG TAP<a class="headerlink" href="#jtag-tap" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<blockquote>
<div><p><strong>重要：本章节的目的是为了展示一个JTAG TAP的非常规实现方法</strong></p>
</div></blockquote>
<blockquote>
<div><p><strong>重要：该实现并不简单，它混合了面向对象编程、抽象接口解耦、硬件生成和硬件描述。当然，简单的JTAG TAP实现只需要一个简单的硬件描述就可以完成，但这里的目标实际上是更进一步，创建一个可重用和可扩展的JTAG TAP生成器</strong></p>
</div></blockquote>
<blockquote>
<div><p><strong>本章节将会解释JTAG是如何工作的。也可见https://www.fpga4fun.com/JTAG.html的手册</strong></p>
</div></blockquote>
<p>常用的HDL和Spinal之间的一个很大的区别是，SpinalHDL允许用户定义硬件生成器/构建器。这与描述硬件非常不同。以下面的例子为例，因为生成/构建/描述之间的区别看起来像是“玩弄文字”，或者可以用不同的方式解释。</p>
<p>下面的例子是一个JTAG TAP，它允许JTAG主程序读取<code class="docutils literal notranslate"><span class="pre">switchs</span></code>/<code class="docutils literal notranslate"><span class="pre">keys</span></code>的输入和写入<code class="docutils literal notranslate"><span class="pre">leds</span></code>的输出。通过使用UID 0x87654321，主服务器也可以识别这个TAP。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">SimpleJtagTap</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">jtag</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">Jtag</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">switchs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w">  </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">keys</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w">  </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">leds</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">tap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">JtagTap</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">jtag</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">idcodeArea</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">tap</span><span class="p">.</span><span class="n">idcode</span><span class="p">(</span><span class="nc">B</span><span class="s">&quot;x87654321&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">instructionId</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">switchsArea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tap</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">switchs</span><span class="p">)</span><span class="w">     </span><span class="p">(</span><span class="n">instructionId</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">keysArea</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">tap</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">keys</span><span class="p">)</span><span class="w">        </span><span class="p">(</span><span class="n">instructionId</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">ledsArea</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">tap</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">leds</span><span class="p">)</span><span class="w">       </span><span class="p">(</span><span class="n">instructionId</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>可见，创建了一个JtagTap，然后调用一些Generator/Builder函数(idcode、read、write)来创建每个JTAG指令。这就是所说的“硬件生成器/构建器”，然后这些生成器/构建器被用户用来描述硬件。最重要的一点是，在通常的HDL中，用户只能描述硬件，这意味着许多繁琐的工作。</p>
<p>该JTAG TAP教程基于https://github.com/SpinalHDL/SpinalHDL/tree/master/lib/src/main/scala/spinal/lib/com/jtag实现。</p>
</li>
<li><p>JTAG总线</p>
<p>首先我们要定义一个JTAG总线类</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Jtag</span><span class="p">()</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">IMasterSlave</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">tms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">tdi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">tdo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">asMaster</span><span class="p">()</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">out</span><span class="p">(</span><span class="n">tdi</span><span class="p">,</span><span class="w"> </span><span class="n">tms</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">in</span><span class="p">(</span><span class="n">tdo</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>该总线未包含TCK引脚因为时钟域会提供</p>
</li>
<li><p>JTAG状态机</p>
<p>根据https://www.fpga4fun.com/JTAG2.html的指导定义JTAG状态机</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">JtagState</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">SpinalEnum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="nc">RESET</span><span class="p">,</span><span class="w"> </span><span class="nc">IDLE</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nc">IR_SELECT</span><span class="p">,</span><span class="w"> </span><span class="nc">IR_CAPTURE</span><span class="p">,</span><span class="w"> </span><span class="nc">IR_SHIFT</span><span class="p">,</span><span class="w"> </span><span class="nc">IR_EXIT1</span><span class="p">,</span><span class="w"> </span><span class="nc">IR_PAUSE</span><span class="p">,</span><span class="w"> </span><span class="nc">IR_EXIT2</span><span class="p">,</span><span class="w"> </span><span class="nc">IR_UPDATE</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="nc">DR_SELECT</span><span class="p">,</span><span class="w"> </span><span class="nc">DR_CAPTURE</span><span class="p">,</span><span class="w"> </span><span class="nc">DR_SHIFT</span><span class="p">,</span><span class="w"> </span><span class="nc">DR_EXIT1</span><span class="p">,</span><span class="w"> </span><span class="nc">DR_PAUSE</span><span class="p">,</span><span class="w"> </span><span class="nc">DR_EXIT2</span><span class="p">,</span><span class="w"> </span><span class="nc">DR_UPDATE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newElement</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">JtagFsm</span><span class="p">(</span><span class="n">jtag</span><span class="p">:</span><span class="w"> </span><span class="nc">Jtag</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">import</span><span class="w"> </span><span class="nc">JtagState</span><span class="p">.</span><span class="n">_</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">stateNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">JtagState</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">RegNext</span><span class="p">(</span><span class="n">stateNext</span><span class="p">)</span><span class="w"> </span><span class="n">randBoot</span><span class="p">()</span><span class="w"></span>

<span class="w">  </span><span class="n">stateNext</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">mux</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">default</span><span class="w">    </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">RESET</span><span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="nc">IDLE</span><span class="p">),</span><span class="w">           </span><span class="c1">//RESET</span>
<span class="w">    </span><span class="nc">IDLE</span><span class="w">       </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">DR_SELECT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nc">IDLE</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nc">IR_SELECT</span><span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">RESET</span><span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="nc">IR_CAPTURE</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nc">IR_CAPTURE</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">IR_EXIT1</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="nc">IR_SHIFT</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nc">IR_SHIFT</span><span class="w">   </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">IR_EXIT1</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="nc">IR_SHIFT</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nc">IR_EXIT1</span><span class="w">   </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">IR_UPDATE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nc">IR_PAUSE</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nc">IR_PAUSE</span><span class="w">   </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">IR_EXIT2</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="nc">IR_PAUSE</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nc">IR_EXIT2</span><span class="w">   </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">IR_UPDATE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nc">IR_SHIFT</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nc">IR_UPDATE</span><span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">DR_SELECT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nc">IDLE</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nc">DR_SELECT</span><span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">IR_SELECT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nc">DR_CAPTURE</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nc">DR_CAPTURE</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">DR_EXIT1</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="nc">DR_SHIFT</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nc">DR_SHIFT</span><span class="w">   </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">DR_EXIT1</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="nc">DR_SHIFT</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nc">DR_EXIT1</span><span class="w">   </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">DR_UPDATE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nc">DR_PAUSE</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nc">DR_PAUSE</span><span class="w">   </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">DR_EXIT2</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="nc">DR_PAUSE</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nc">DR_EXIT2</span><span class="w">   </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">DR_UPDATE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nc">DR_SHIFT</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="nc">DR_UPDATE</span><span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nc">DR_SELECT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nc">IDLE</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p><strong>注意：<code class="docutils literal notranslate"><span class="pre">state</span></code>中的<code class="docutils literal notranslate"><span class="pre">randBoot()</span></code>将会被随机状态初始化。仅是为了仿真用</strong></p>
</div></blockquote>
</li>
<li><p>JTAG TAP</p>
<p>下面将不用任何指令，只用最基本的指令寄存器控制和旁路控制来实现JTAG TAP的核</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">JtagTap</span><span class="p">(</span><span class="kd">val</span><span class="w"> </span><span class="n">jtag</span><span class="p">:</span><span class="w"> </span><span class="nc">Jtag</span><span class="p">,</span><span class="w"> </span><span class="n">instructionWidth</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Area</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">fsm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">JtagFsm</span><span class="p">(</span><span class="n">jtag</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="n">instructionWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">instructionShift</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="n">instructionWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">bypass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bool</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="n">jtag</span><span class="p">.</span><span class="n">tdo</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">bypass</span><span class="w"></span>

<span class="w">  </span><span class="n">switch</span><span class="p">(</span><span class="n">fsm</span><span class="p">.</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="nc">JtagState</span><span class="p">.</span><span class="nc">IR_CAPTURE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">instructionShift</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">instruction</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="nc">JtagState</span><span class="p">.</span><span class="nc">IR_SHIFT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">instructionShift</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">jtag</span><span class="p">.</span><span class="n">tdi</span><span class="w"> </span><span class="o">##</span><span class="w"> </span><span class="n">instructionShift</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="n">jtag</span><span class="p">.</span><span class="n">tdo</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">instructionShift</span><span class="p">.</span><span class="n">lsb</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="nc">JtagState</span><span class="p">.</span><span class="nc">IR_UPDATE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">instruction</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">instructionShift</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">is</span><span class="p">(</span><span class="nc">JtagState</span><span class="p">.</span><span class="nc">DR_SHIFT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">bypass</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">jtag</span><span class="p">.</span><span class="n">tdi</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>JTAG指令</p>
<p>JTAG TAP核心已经完成，可以考虑如何通过可重用的方式实现JTAG指令。</p>
<ul>
<li><p>JTAG TAP类的接口</p>
<p>首先，需要定义一条指令如何与JTAG TAP核心交互。当然可以直接使用JtagTap区域，但这不是很好，因为在某些情况下，JTAG TAP核心是由另一个IP提供的(例如Altera虚拟JTAG)。</p>
<p>所以定义一个JTAP TAP核与指令间的简单抽象接口：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">trait</span><span class="w"> </span><span class="nc">JtagTapAccess</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">getTdi</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">getTms</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">setTdo</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">getState</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">JtagState</span><span class="p">.</span><span class="nc">T</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">getInstruction</span><span class="p">()</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Bits</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">setInstruction</span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Bits</span><span class="p">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Unit</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>随后让JtagTap实现该抽象接口：</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">JtagTap</span><span class="p">(</span><span class="kd">val</span><span class="w"> </span><span class="n">jtag</span><span class="p">:</span><span class="w"> </span><span class="nc">Jtag</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nc">JtagTapAccess</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>

<span class="w">  </span><span class="c1">//JtagTapAccess impl</span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">getTdi</span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jtag</span><span class="p">.</span><span class="n">tdi</span><span class="w"></span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">setTdo</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="p">):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jtag</span><span class="p">.</span><span class="n">tdo</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">getTms</span><span class="p">:</span><span class="w"> </span><span class="nc">Bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jtag</span><span class="p">.</span><span class="n">tms</span><span class="w"></span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">getState</span><span class="p">:</span><span class="w"> </span><span class="nc">JtagState</span><span class="p">.</span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fsm</span><span class="p">.</span><span class="n">state</span><span class="w"></span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">getInstruction</span><span class="p">():</span><span class="w"> </span><span class="nc">Bits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instruction</span><span class="w"></span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">setInstruction</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">Bits</span><span class="p">):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>基类</p>
<p>为JTAG指令定义一个有用的基类，根据所选指令和JTAG TAP的状态提供一些回调(doCapture/doShift/doUpdate/doReset):</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">JtagInstruction</span><span class="p">(</span><span class="n">tap</span><span class="p">:</span><span class="w"> </span><span class="nc">JtagTapAccess</span><span class="p">,</span><span class="kd">val</span><span class="w"> </span><span class="n">instructionId</span><span class="p">:</span><span class="w"> </span><span class="nc">Bits</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">doCapture</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">doShift</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">doUpdate</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">doReset</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">instructionHit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tap</span><span class="p">.</span><span class="n">getInstruction</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">instructionId</span><span class="w"></span>

<span class="w">  </span><span class="nc">Component</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">addPrePopTask</span><span class="p">(()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">instructionHit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="n">tap</span><span class="p">.</span><span class="n">getState</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">JtagState</span><span class="p">.</span><span class="nc">DR_CAPTURE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">doCapture</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="n">tap</span><span class="p">.</span><span class="n">getState</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">JtagState</span><span class="p">.</span><span class="nc">DR_SHIFT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">doShift</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">when</span><span class="p">(</span><span class="n">tap</span><span class="p">.</span><span class="n">getState</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">JtagState</span><span class="p">.</span><span class="nc">DR_UPDATE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">doUpdate</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">when</span><span class="p">(</span><span class="n">tap</span><span class="p">.</span><span class="n">getState</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nc">JtagState</span><span class="p">.</span><span class="nc">RESET</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">doReset</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p><strong>注意：关于Component.current.addPrePopTask(…)：这允许用户在当前组件构造结束时调用给定的代码。由于JtagInstruction面向对象的特性，doCapture, doShift, doUpdate和doReset不应该在子类构造之前调用(因为子类会使用它作为回调来执行一些逻辑)</strong></p>
</div></blockquote>
</li>
<li><p>读指令</p>
<p>实现一条允许JTAG读取信号的指令。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">JtagInstructionRead</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">tap</span><span class="p">:</span><span class="w"> </span><span class="nc">JtagTapAccess</span><span class="p">,</span><span class="n">instructionId</span><span class="p">:</span><span class="w"> </span><span class="nc">Bits</span><span class="p">)</span><span class="k">extends</span><span class="w"> </span><span class="nc">JtagInstruction</span><span class="p">(</span><span class="n">tap</span><span class="p">,</span><span class="n">instructionId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">shifter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">getBitsWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">doCapture</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">shifter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">asBits</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">doShift</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">shifter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">tap</span><span class="p">.</span><span class="n">getTdi</span><span class="w"> </span><span class="o">##</span><span class="w"> </span><span class="n">shifter</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="n">tap</span><span class="p">.</span><span class="n">setTdo</span><span class="p">(</span><span class="n">shifter</span><span class="p">.</span><span class="n">lsb</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>写指令</p>
<p>实现一条指令，允许JTAG写入寄存器(同时读取其当前值)。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">JtagInstructionWrite</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">tap</span><span class="p">:</span><span class="w"> </span><span class="nc">JtagTapAccess</span><span class="p">,</span><span class="n">instructionId</span><span class="p">:</span><span class="w"> </span><span class="nc">Bits</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">JtagInstruction</span><span class="p">(</span><span class="n">tap</span><span class="p">,</span><span class="n">instructionId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">shifter</span><span class="p">,</span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">getBitsWidth</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">doCapture</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">shifter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">store</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">doShift</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">shifter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">tap</span><span class="p">.</span><span class="n">getTdi</span><span class="w"> </span><span class="o">##</span><span class="w"> </span><span class="n">shifter</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="n">tap</span><span class="p">.</span><span class="n">setTdo</span><span class="p">(</span><span class="n">shifter</span><span class="p">.</span><span class="n">lsb</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">doUpdate</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">store</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">shifter</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">data</span><span class="p">.</span><span class="n">assignFromBits</span><span class="p">(</span><span class="n">store</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Idcode指令</p>
<p>实现向JTAG返回idcode的指令，并且，当复位时，将指令寄存器(IR)设置为它自己的instructionId。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">JtagInstructionIdcode</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">Bits</span><span class="p">)(</span><span class="n">tap</span><span class="p">:</span><span class="w"> </span><span class="nc">JtagTapAccess</span><span class="p">,</span><span class="w"> </span><span class="n">instructionId</span><span class="p">:</span><span class="w"> </span><span class="nc">Bits</span><span class="p">)</span><span class="k">extends</span><span class="w"> </span><span class="nc">JtagInstruction</span><span class="p">(</span><span class="n">tap</span><span class="p">,</span><span class="n">instructionId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">shifter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">doShift</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">shifter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="n">tap</span><span class="p">.</span><span class="n">getTdi</span><span class="w"> </span><span class="o">##</span><span class="w"> </span><span class="n">shifter</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="n">tap</span><span class="p">.</span><span class="n">setTdo</span><span class="p">(</span><span class="n">shifter</span><span class="p">.</span><span class="n">lsb</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">override</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">doReset</span><span class="p">():</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">shifter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">value</span><span class="w"></span>
<span class="w">    </span><span class="n">tap</span><span class="p">.</span><span class="n">setInstruction</span><span class="p">(</span><span class="n">instructionId</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>用户友好型包装(User friendly wrapper)</p>
<p>向JtagTapAccess添加一些用户友好的函数，使指令实例化更容易。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">trait</span><span class="w"> </span><span class="nc">JtagTapAccess</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">idcode</span><span class="p">(</span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">Bits</span><span class="p">)(</span><span class="n">instructionId</span><span class="p">:</span><span class="w"> </span><span class="nc">Bits</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nc">JtagInstructionIdcode</span><span class="p">(</span><span class="n">value</span><span class="p">)(</span><span class="bp">this</span><span class="p">,</span><span class="n">instructionId</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">)(</span><span class="n">instructionId</span><span class="p">:</span><span class="w"> </span><span class="nc">Bits</span><span class="p">)</span><span class="w">   </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nc">JtagInstructionRead</span><span class="p">(</span><span class="n">data</span><span class="p">)(</span><span class="bp">this</span><span class="p">,</span><span class="n">instructionId</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">[</span><span class="nc">T</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Data</span><span class="p">](</span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w">  </span><span class="n">cleanUpdate</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">readable</span><span class="p">:</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">)(</span><span class="n">instructionId</span><span class="p">:</span><span class="w"> </span><span class="nc">Bits</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nc">JtagInstructionWrite</span><span class="p">[</span><span class="nc">T</span><span class="p">](</span><span class="n">data</span><span class="p">,</span><span class="n">cleanUpdate</span><span class="p">,</span><span class="n">readable</span><span class="p">)(</span><span class="bp">this</span><span class="p">,</span><span class="n">instructionId</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>使用演示</p>
<p>现在，可以非常容易地创建应用程序特定的JTAG TAP，而不需要编写任何逻辑或任何互连。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">SimpleJtagTap</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">jtag</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">slave</span><span class="p">(</span><span class="nc">Jtag</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">switchs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w">  </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">keys</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w">  </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">leds</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bits</span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">tap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">JtagTap</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">jtag</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">idcodeArea</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">tap</span><span class="p">.</span><span class="n">idcode</span><span class="p">(</span><span class="nc">B</span><span class="s">&quot;x87654321&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">instructionId</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">switchsArea</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tap</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">switchs</span><span class="p">)</span><span class="w">     </span><span class="p">(</span><span class="n">instructionId</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">keysArea</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">tap</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">keys</span><span class="p">)</span><span class="w">        </span><span class="p">(</span><span class="n">instructionId</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">ledsArea</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">tap</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">leds</span><span class="p">)</span><span class="w">       </span><span class="p">(</span><span class="n">instructionId</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>这种方式(生成硬件)也可以应用于，例如，生成一个APB/AHB/AXI从端总线。</p>
</li>
</ol>
</section>
<section id="uart-memory-mapped-uart">
<h3>二、内存映射UART(Memory mapped UART)<a class="headerlink" href="#uart-memory-mapped-uart" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>该例子将会以之前的Uart例子来实现一个内存映射的UART。</p>
</li>
<li><p>规范</p>
<p>该实现将基于一个带RX FIFO的APB3总线。</p>
<p>以下是寄存器映射表：
|     名称     |        类型         | 接入  | 地址  |                             描述                             |
| :———-: | :—————–: | :—: | :—: | :———————————————————-: |
| clockDivider |        UInt         |  RW   |   0   |                    设置UartCtrl时钟分频器                    |
|    frame     | UartCtrlFrameConfig |  RW   |   4   |               设置数据长度，校验位和停止位配置               |
|   writeCmd   |        Bits         |   W   |   8   |                   向UartCtrl发送一条写命令                   |
|  writeBusy   |        Bool         |   R   |   8   |      当一条新的writeCmd可以被发送时，操作Bit 0 =&gt; zero       |
|     read     |     Bool / Bits     |   R   |  12   | Bits 7 downto 0 =&gt; rx payload <br>Bit 31 =&gt; rx payload valid |</p>
</li>
<li><p>实现</p>
<p>在该实现中，Apb3SlaveFactory工具将会被使用。它允许用户用优美的语法定义一个APB3从端。可以从https://spinalhdl.github.io/SpinalDoc-RTD/master/SpinalHDL/Libraries/bus_slave_factory.html#bus-slave-factory找到该工具的文档。</p>
<p>首先，我们只需要定义控制器将要使用的<code class="docutils literal notranslate"><span class="pre">Apb3Config</span></code>。它被定义为Scala object里的一个函数。</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span><span class="w"> </span><span class="nc">Apb3UartCtrl</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">getApb3Config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3Config</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">addressWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">dataWidth</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="w"></span>
<span class="w">  </span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>随后我们可以定义一个<code class="docutils literal notranslate"><span class="pre">Apb3UartCtrl</span></code>组件来实例化一个<code class="docutils literal notranslate"><span class="pre">UartCtrl</span></code>并且在它和APB3总线之间创建一个内存映射逻辑：
<img alt="image/memory_mapped_uart.svg" src="image/memory_mapped_uart.svg" /></p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Apb3UartCtrl</span><span class="p">(</span><span class="n">uartCtrlConfig</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">UartCtrlGenerics</span><span class="p">,</span><span class="w"> </span><span class="n">rxFifoDepth</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">bus</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">slave</span><span class="p">(</span><span class="nc">Apb3</span><span class="p">(</span><span class="nc">Apb3UartCtrl</span><span class="p">.</span><span class="n">getApb3Config</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">uart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master</span><span class="p">(</span><span class="nc">Uart</span><span class="p">())</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">//实例化一个简单的uart控制器</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">uartCtrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">UartCtrl</span><span class="p">(</span><span class="n">uartCtrlConfig</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">uart</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">uart</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 建立一个被io.bus驱动的apb3SlaveFactory实例</span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">busCtrl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Apb3SlaveFactory</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">bus</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 请求busCtrl以在地址0创建一个可读写寄存器并且驱动uartCtrl.io.config.clockDivider</span>
<span class="w">  </span><span class="n">busCtrl</span><span class="p">.</span><span class="n">driveAndRead</span><span class="p">(</span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">clockDivider</span><span class="p">,</span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 与上面做同样的事，但是是驱动地址4的uartCtrl.io.config.frame</span>
<span class="w">  </span><span class="n">busCtrl</span><span class="p">.</span><span class="n">driveAndRead</span><span class="p">(</span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 请求busCtrl以在地址8创建一个可写Flow[Bits]</span>
<span class="w">  </span><span class="c1">// 随后将其转化为Stream并且使用寄存器连接到uartCtrl.io.write</span>
<span class="w">  </span><span class="n">busCtrl</span><span class="p">.</span><span class="n">createAndDriveFlow</span><span class="p">(</span><span class="nc">Bits</span><span class="p">(</span><span class="n">uartCtrlConfig</span><span class="p">.</span><span class="n">dataWidthMax</span><span class="w"> </span><span class="n">bits</span><span class="p">),</span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">).</span><span class="n">toStream</span><span class="w"> </span><span class="o">&gt;-&gt;</span><span class="w"> </span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">write</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 为了避免在上面的流到流转换之间丢失写命令，使uartCtrl.io.write的占用在地址8处可读</span>
<span class="w">  </span><span class="n">busCtrl</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">write</span><span class="p">.</span><span class="n">valid</span><span class="p">,</span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 读取uartCtrl.io并转换成流，随后连接到64个元素的FIFO的输入。然后使用非阻塞协议使FIFO的输出在地址12处可读</span>
<span class="w">  </span><span class="c1">// (Bit 7 downto 0 =&gt; read data &lt;br&gt; Bit 31 =&gt; read data valid )</span>
<span class="w">  </span><span class="n">busCtrl</span><span class="p">.</span><span class="n">readStreamNonBlocking</span><span class="p">(</span><span class="n">uartCtrl</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">read</span><span class="p">.</span><span class="n">toStream</span><span class="p">.</span><span class="n">queue</span><span class="p">(</span><span class="n">rxFifoDepth</span><span class="p">),</span><span class="w"></span>
<span class="w">                                </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="n">validBitOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">31</span><span class="p">,</span><span class="w"> </span><span class="n">payloadBitOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<blockquote>
<div><p><strong>重要：是的，以上就是全部。它同样是可综合的。Apb3SlaveFactory工具并不是硬编码到SpinalHDL编译器中的东西。它是用SpinalHDL规则硬件描述语法实现的。</strong></p>
</div></blockquote>
</li>
</ol>
</section>
<section id="pinesec">
<h3>三、Pinesec<a class="headerlink" href="#pinesec" title="Permalink to this heading"></a></h3>
<p>原著未撰写</p>
</section>
<section id="timer">
<h3>四、计时器(Timer)<a class="headerlink" href="#timer" title="Permalink to this heading"></a></h3>
<ol>
<li><p>简介</p>
<p>计时器模块可能是最基本的硬件部件之一。但即使对于一个计时器，也可以用SpinalHDL做一些有趣的事情。这个例子将定义一个简单的计时器组件，它集成了一个总线桥接工具。</p>
</li>
<li><p>计时器</p>
<p>首先从<code class="docutils literal notranslate"><span class="pre">Timer</span></code>组件开始。</p>
<ul>
<li><p>规范</p>
<p>该<code class="docutils literal notranslate"><span class="pre">Timer</span></code>组件将有一个单独的构造参数：
| 名称  | 类型  |           描述           |
| :—: | :—: | :———————-: |
| width |  Int  | 指明时间计数器的比特位宽 |</p>
<p>并且有一些输入/输出：
| 名称  | 方向  | 类型  |                          描述                           |
| :—: | :—: | :—: | :—————————————————–: |
| tick  |  in   | Bool  |       当<code class="docutils literal notranslate"><span class="pre">tick</span></code>为True时，计时器会一直计数到<code class="docutils literal notranslate"><span class="pre">limit</span></code>       |
| clear |  in   | Bool  | 当<code class="docutils literal notranslate"><span class="pre">tick</span></code>为True时，计时器设置为零。<code class="docutils literal notranslate"><span class="pre">Clear</span></code>优先于<code class="docutils literal notranslate"><span class="pre">tick</span></code>。 |</p>
</li>
<li><p>实现</p>
<div class="highlight-Scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Timer</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">Component</span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">io</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">Bundle</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">tick</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">clear</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">limit</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">full</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">Bool</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">value</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kd">val</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="nc">UInt</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="n">bits</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">tick</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">io</span><span class="p">.</span><span class="n">full</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">when</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">clear</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">full</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">limit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">tick</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">counter</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>桥接函数(Bridging function)</p>
<p>可以从这个例子的主要目的开始:定义一个总线桥接函数。为此，将使用两种技术:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> - 利用https://spinalhdl.github.io/SpinalDoc-RTD/master/SpinalHDL/Libraries/bus_slave_factory.html#bus-slave-factory下的`BusSlaveFactory`工具
 - 在`Timer`组件内部定义一个函数，可以从父组件调用该函数，以抽象的方式驱动`Timer`的IO。
</pre></div>
</div>
<ul class="simple">
<li><p>规范</p></li>
</ul>
</li>
</ol>
<pre><code>    |    名称     |      类型       |                     描述                      |
    | :---------: | :-------------: | :-------------------------------------------: |
    |   busCtrl   | BusSlaveFactory | 函数将使用`BusSlaveFactory`实例创建桥接逻辑。 |
    | baseAddress |     BigInt      |          桥接逻辑应该被映射的基地址           |
    |    ticks    |    Seq[Bool]    |           可用作tick信号的逻辑资源            |
    |   clears    |    Seq[Bool]    |           可用作clear信号的逻辑资源           |
</code></pre><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    该寄存器映射会假设总线系统是32比特位宽：
    |     名称     | 接入  |    位宽     | 地址偏移 | 比特偏移 |
    | :----------: | :---: | :---------: | :------: | :------: |
    | ticksEnable  |  RW   | len(ticks)  |    0     |    0     |
    | clearsEnable |  RW   | len(clears) |    0     |    16    |
    |    limit     |  RW   |    width    |    4     |    0     |
    |    value     |   R   |    width    |    8     |    0     |
    |    clear     |   W   |             |    8     |          |

- 实现

    将桥接函数加入`Timer`组件
    ```Scala
    case class Timer(width : Int) extends Component{
      val io = new Bundle{
        val tick      = in Bool()
        val clear     = in Bool()
        val limit     = in UInt(width bits)

        val full  = out Bool()
        val value     = out UInt(width bits)
      }

      // 之前定义的逻辑
      // ....

      // 使用Scala函数名(arg1,arg2)(arg3,arg3)的函数圆形
      // 可以以更优雅的方式调用函数
      // 该函数同样返回一个area, 可以保持生成的Verilog内的信号名.
      def driveFrom(busCtrl : BusSlaveFactory,baseAddress : BigInt)(ticks : Seq[Bool],clears : Seq[Bool]) = new Area {
        //Address 0 =&gt; clear/tick masks + bus
        val ticksEnable  = busCtrl.createReadWrite(Bits(ticks.length bits),baseAddress + 0,0) init(0)
        val clearsEnable = busCtrl.createReadWrite(Bits(clears.length bits),baseAddress + 0,16) init(0)
        val busClearing  = False

        io.clear := (clearsEnable &amp; clears.asBits).orR | busClearing
        io.tick  := (ticksEnable  &amp; ticks.asBits ).orR

        //Address 4 =&gt; read/write limit (+ auto clear)
        busCtrl.driveAndRead(io.limit,baseAddress + 4)
        busClearing setWhen(busCtrl.isWriting(baseAddress + 4))

        //Address 8 =&gt; read timer value / write =&gt; clear timer value
        busCtrl.read(io.value,baseAddress + 8)
        busClearing setWhen(busCtrl.isWriting(baseAddress + 8))
      }
    }
    ```

- 使用

    下面是一些演示代码，它非常接近于Pinsec SoC计时器模块中使用的代码。基本上，它实例化了以下元素:

        - 一个16比特的预分频器
        - 一个32比特的计数器
        - 三个16比特的计数器

    然后，通过使用Apb3SlaveFactory和在计时器中定义的函数，它在APB3总线和所有实例化组件之间创建桥接逻辑。

    ```Scala
    val io = new Bundle{
      val apb = Apb3(ApbConfig(addressWidth = 8, dataWidth = 32))
      val interrupt = in Bool()
      val external = new Bundle{
        val tick  = Bool()
        val clear = Bool()
      }
    }

    //预分频器和计时器很相似, 它主要集成了一些自动预载逻辑
    val prescaler = Prescaler(width = 16)

    val timerA = Timer(width = 32)
    val timerB,timerC,timerD = Timer(width = 16)

    val busCtrl = Apb3SlaveFactory(io.apb)
    val prescalerBridge = prescaler.driveFrom(busCtrl,0x00)

    val timerABridge = timerA.driveFrom(busCtrl,0x40)(
      // 第一个单元是True,  这允许你有一个计时器总是在计数的模式。
      ticks  = List(True, prescaler.io.overflow),
      // 通过将计时器完全循环到清除，允许用户创建一个自动重新加载模式。
      clears = List(timerA.io.full)
    )

    val timerBBridge = timerB.driveFrom(busCtrl,0x50)(
      //external.tick允许创建一个脉冲计数模式
      ticks  = List(True, prescaler.io.overflow, io.external.tick),
      //external.clear允许创建一个超时模式
      clears = List(timerB.io.full, io.external.clear)
    )

    val timerCBridge = timerC.driveFrom(busCtrl,0x60)(
      ticks  = List(True, prescaler.io.overflow, io.external.tick),
      clears = List(timerC.io.full, io.external.clear)
    )

    val timerDBridge = timerD.driveFrom(busCtrl,0x70)(
      ticks  = List(True, prescaler.io.overflow, io.external.tick),
      clears = List(timerD.io.full, io.external.clear)
    )

    val interruptCtrl = InterruptCtrl(4)
    val interruptCtrlBridge = interruptCtrl.driveFrom(busCtrl,0x10)
    interruptCtrl.io.inputs(0) := timerA.io.full
    interruptCtrl.io.inputs(1) := timerB.io.full
    interruptCtrl.io.inputs(2) := timerC.io.full
    interruptCtrl.io.inputs(3) := timerD.io.full
    io.interrupt := interruptCtrl.io.pendings.orR
    ```
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to SpinalHDL_Chinese_Doc’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, spinal.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>